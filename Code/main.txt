Sections:
00: "seg0" (0-8000)
01: "seg8000" (8000-FD00)
02: "segfd00" (FD00-FE00)
03: "segfe00" (FE00-FF00)
04: "segff00" (FF00-FFFF)


Source: "main.asm"
                        	     1: ; --------------------------------------------------------------------------------------------------------------
                        	     2: ;         :::::::::     ::::::::       :::::::            :::::::::     :::::::::::     ::::::::       :::::::: 
                        	     3: ;             :+:     :+:    :+:     :+:   :+:           :+:    :+:        :+:        :+:    :+:     :+:    :+: 
                        	     4: ;           +:+      +:+    +:+     +:+   +:+           +:+    +:+        +:+        +:+    +:+     +:+         
                        	     5: ;         +#+        +#++:++#      +#+   +:+           +#++:++#+         +#+        +#+    +:+     +#++:++#++   
                        	     6: ;       +#+        +#+    +#+     +#+   +#+           +#+    +#+        +#+        +#+    +#+            +#+    
                        	     7: ;     #+#         #+#    #+#     #+#   #+#           #+#    #+#        #+#        #+#    #+#     #+#    #+#     
                        	     8: ;   #########     ########       #######            #########     ###########     ########       ########       
                        	     9: ; ------------------------------------------------------------------------------------------------------
                        	    10: 
                        	    11: ; *********************************************************************************************************************
                        	    12: ; * Z80 Project by Frédéric Segard, a.k.a. MicroHobbyist
                        	    13: ; * https://www.youtube.com/@microhobbyist
                        	    14: ; * https://github.com/FredericSegard
                        	    15: ; *
                        	    16: ; * Copyright (C) 2023 Frédéric Segard
                        	    17: ; *
                        	    18: ; * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
                        	    19: ; * Public License as published by the Free Software Foundation. You can use all or part of the code, regardless of
                        	    20: ; * the version. But there is no warrenty of any kind.
                        	    21: ; *
                        	    22: ; * Reference:	ASCII text: https://www.messletters.com/en/big-text/ (alligator, standard)
                        	    23: ; *				Editor tab-stops set to 4
                        	    24: ; *				Assembler: VASM  (BIN: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fbin -o %1.out -L %1.txt)
                        	    25: ; *								 (HEX: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fihex)
                        	    26: ; * Version 0.7
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: 
                        	    30: ;   ____                         _                     _         
                        	    31: ;  / ___|   ___    _ __    ___  | |_    __ _   _ __   | |_   ___ 
                        	    32: ; | |      / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
                        	    33: ; | |___  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
                        	    34: ;  \____|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
                        	    35: ;
                        	    36: ; ---------------------------------------------------------------------------------------------------------------------
                        	    37: ; VARIOUS CONSTANTS AND ADDRESSES USED IN THE CODE
                        	    38: 
                        	    39: ; GENERAL EQUATES
                        	    40: NULL			= $00
                        	    41: CTRLC			= $03				; Control-C (Break)
                        	    42: CTRLG			= $07				; Control-G (Bell)
                        	    43: BKSP			= $08				; Backspace
                        	    44: TAB				= $09				; Horizontal tab
                        	    45: LF				= $0A				; Line-feed character
                        	    46: CS				= $0C				; Clear Screen
                        	    47: CR				= $0D				; Carriage-return character
                        	    48: CTRLO			= $0F				; Control "O"
                        	    49: CTRLQ			= $11				; Control "Q"
                        	    50: CTRLR			= $12				; Control "R"
                        	    51: CTRLS			= $13				; Control "S"
                        	    52: CTRLU			= $15				; Control "U"
                        	    53: ESC				= $1B				; Escape
                        	    54: SPACE			= $20				; Space character
                        	    55: DEL				= $7F				; Delete
                        	    56: 
                        	    57: DELIMITER		= " "				; Space delimiter between command line parameters
                        	    58: ERRORPTR		= "^"				; Error pointer symbol (used for pointing to the error position on command line)
                        	    59: QUOTE			= $22
                        	    60: JUMP			= $C3				; Delimiter for command list items (It's the actual jp command opcode)
                        	    61: HELP			= $0F
                        	    62: EOT				= $FF				; End of table
                        	    63: 
                        	    64: ;PARAMETERS
                        	    65: HorizTextRes	= 40				; Horizontal text resolution (40 or 80)
                        	    66: VertTextRes		= 24				; Vertical text resolution (typical 24 or 25)
                        	    67: ErrorPtrOffset	= 8					; Take into account the command prompt width
                        	    68: BytesFree		= (VectorTable-EndOfCode)+(StartOfCode-InterruptVectorEnd)	; Base free bytes
                        	    69: 
                        	    70: ; I/O ADDRESSES
                        	    71: SIO_PortA_Data	= $00				; SIO data port A
                        	    72: SIO_PortB_Data	= $01				; SIO data port B
                        	    73: SIO_PortA_Ctrl	= $02				; SIO control port A
                        	    74: SIO_PortB_Ctrl	= $03				; SIO control port B
                        	    75: ClockSelect		= $28				; Clock speed selection address (values $00 to $03)
                        	    76: BankSelect		= $30				; RAM bank select address (values ($00 to $0E)
                        	    77: RomDisable		= $38				; ROM dissable address (any value)
                        	    78: 
                        	    79: ; STATUS INDICATOR FLAGS (BIT NUMBER... 3 and 5 are not used
                        	    80: Carry			= 0					; (F) Carry flag
                        	    81: Negative		= 1					; (N) Add/substract flag
                        	    82: Parity			= 2					; (P) Parity flag (Same bit position as bellow, depends on the instruction)
                        	    83: Overflow		= 2					; (V) Overflow flag (Same bit position as above, depends on the instruction)
                        	    84: HalfCarry		= 4					; (H) Half-carry flag
                        	    85: Zero			= 6					; (Z) Zero flag
                        	    86: Sign			= 7					; (S) Sign flag
                        	    87: 
                        	    88: 
                        	    89: ;  ___           _                                          _    __     __                _                        
                        	    90: ; |_ _|  _ __   | |_    ___   _ __   _ __   _   _   _ __   | |_  \ \   / /   ___    ___  | |_    ___    _ __   ___ 
                        	    91: ;  | |  | '_ \  | __|  / _ \ | '__| | '__| | | | | | '_ \  | __|  \ \ / /   / _ \  / __| | __|  / _ \  | '__| / __|
                        	    92: ;  | |  | | | | | |_  |  __/ | |    | |    | |_| | | |_) | | |_    \ V /   |  __/ | (__  | |_  | (_) | | |    \__ \
                        	    93: ; |___| |_| |_|  \__|  \___| |_|    |_|     \__,_| | .__/   \__|    \_/     \___|  \___|  \__|  \___/  |_|    |___/
                        	    94: ;                                                  |_|                                                             
                        	    95: ; ---------------------------------------------------------------------------------------------------------------------
                        	    96: ; RESET AND INTERRUPT VECTORS (8-BYTE VECTORS EACH)
                        	    97: 
                        	    98: 	.org	$0000
                        	    99: 	
                        	   100: RST00:								; Reset vector 0: Standard boot up reset vector
00:0000 C38000          	   101: 	jp		ShadowCopy				; Shadow copy BIOS and vectors
00:0003 FF              	   102: 	ds		$0008-$,$FF
00:0004 *
                        	   103: 
                        	   104: RST08:								; Reset Vector 1
00:0008 76              	   105: 	halt
00:0009 FF              	   106: 	ds		$0010-$,$FF
00:000A *
                        	   107: 
                        	   108: RST10:								; Reset Vector 2
00:0010 76              	   109: 	halt
00:0011 FF              	   110: 	ds		$0018-$,$FF
00:0012 *
                        	   111: 	
                        	   112: RST18:								; Reset Vector 3
00:0018 76              	   113: 	halt
00:0019 FF              	   114: 	ds		$0020-$,$FF
00:001A *
                        	   115: 
                        	   116: RST20:								; Reset Vector 4
00:0020 76              	   117: 	halt
00:0021 FF              	   118: 	ds		$0028-$,$FF
00:0022 *
                        	   119: 
                        	   120: RST28:								; Reset Vector 5
00:0028 76              	   121: 	halt
00:0029 FF              	   122: 	ds		$0030-$,$FF
00:002A *
                        	   123: 
                        	   124: RST30:								; Reset Vector 6
00:0030 76              	   125: 	halt
00:0031 FF              	   126: 	ds		$0038-$,$FF
00:0032 *
                        	   127: 
                        	   128: RST38:								; Reset vector 7: Interrupt Mode 1
00:0038 76              	   129: 	halt
00:0039 FF              	   130: 	ds		$0066-$,$FF
00:003A *
                        	   131: 
                        	   132: NMI66:								; Non-masquable interreupt vector
00:0066 76              	   133: 	halt
00:0067 FF              	   134: 	ds		$0080-$,$FF
00:0068 *
                        	   135: 
                        	   136: InterruptVectorEnd:
                        	   137: 
                        	   138: 
                        	   139: ;  ____    _                   _                         ____                         
                        	   140: ; / ___|  | |__     __ _    __| |   ___   __      __    / ___|   ___    _ __    _   _ 
                        	   141: ; \___ \  | '_ \   / _` |  / _` |  / _ \  \ \ /\ / /   | |      / _ \  | '_ \  | | | |
                        	   142: ;  ___) | | | | | | (_| | | (_| | | (_) |  \ V  V /    | |___  | (_) | | |_) | | |_| |
                        	   143: ; |____/  |_| |_|  \__,_|  \__,_|  \___/    \_/\_/      \____|  \___/  | .__/   \__, |
                        	   144: ;                                                                      |_|      |___/ 
                        	   145: ; ---------------------------------------------------------------------------------------------------------------------
                        	   146: ; SHADOW COPY VECTORS AND BIOS FROM FLASH TO RAM
                        	   147: 
                        	   148: ShadowCopy:
00:0080 F3              	   149: 	di								; Disable interrupts
                        	   150: 	
                        	   151: ; COPY INTERRUPT VECTORS TO ALL BANKS
00:0081 3E0E            	   152: 	ld		A,$0E					; Starting bank number
                        	   153: BankCopyLoop:						; Loop to copy reset vectors to all banks
00:0083 D330            	   154: 	out		(BankSelect),A			; Sets bank number to value in accumulator
                        	   155: 	; Perform vector copy
00:0085 210000          	   156: 	ld      HL,$0000				; Set start at address $0000 (ROM)
00:0088 110000          	   157: 	ld      DE,$0000				; Set destination address (RAM)
00:008B 018000          	   158: 	ld      BC,InterruptVectorEnd	; Set counter to copy the interrupt vector table only
00:008E EDB0            	   159: 	ldir							; Copy, paste, and repeat, until the end of BC has been reached
                        	   160: 	; Check for next iteration
00:0090 3D              	   161: 	dec		A						; Decrement accumulator to move on to next bank
00:0091 FEFF            	   162: 	cp		$FF						; Has accumulator reached the end of the loop (past zero)?
00:0093 20EE            	   163: 	jr		nz,BankCopyLoop			; If not then do next bank the loop, else Bank 0 is already pre-selected
00:0095 328FB0          	   164: 	ld		(CurrentBank),A			; Save Current Bank
                        	   165: 
                        	   166: ; COPY THE BIOS TO RAM
                        	   167: ROMCopy:
00:0098 210080          	   168:     ld      HL,StartOfCode			; Source address
00:009B 110080          	   169:     ld      DE,StartOfCode			; Destination address
00:009E 01B630          	   170:     ld      BC,EndOfCode-StartOfCode; Bytes to copy
00:00A1 EDB0            	   171:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   172: 
                        	   173: ; COPY THE VECTORS AND BLANK STACK TO RAM
                        	   174: VectorCopy:
00:00A3 2100FD          	   175:     ld      HL,VectorTable			; Source address
00:00A6 1100FD          	   176:     ld      DE,VectorTable			; Destination address
00:00A9 01FF02          	   177:     ld      BC,$FFFF-VectorTable	; Bytes to copy
00:00AC EDB0            	   178:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   179: 
00:00AE C30080          	   180: 	jp		StartOfCode
                        	   181: 
00:00B1 FF              	   182: 	ds		StartOfCode-$,$FF		; Fill the rest of memory to start of code with $FF for fast FLASH programming
00:00B2 *
                        	   183: 
                        	   184: 
                        	   185: ;  ___           _   _     _           _   _              
                        	   186: ; |_ _|  _ __   (_) | |_  (_)   __ _  | | (_)  ____   ___ 
                        	   187: ;  | |  | '_ \  | | | __| | |  / _` | | | | | |_  /  / _ \
                        	   188: ;  | |  | | | | | | | |_  | | | (_| | | | | |  / /  |  __/
                        	   189: ; |___| |_| |_| |_|  \__| |_|  \__,_| |_| |_| /___|  \___|
                        	   190: ;
                        	   191: ; ---------------------------------------------------------------------------------------------------------------------
                        	   192: ; START OF CODE
                        	   193: 
                        	   194: 	.org	$8000					; Start of code at beginning of high memory
                        	   195: 
                        	   196: StartOfCode:
01:8000 D338            	   197: 	out		(RomDisable),A			; Disable the ROM
01:8002 31FFFF          	   198: 	ld      SP,$FFFF				; Set top of stack pointer to page FF
                        	   199: 	
01:8005 CD4B81          	   200: 	call	SIO_Init				; Initializes the SIO
                        	   201: 
                        	   202: 	; Print Boot message with bytes free
01:8008 CDAA82          	   203: 	call	ClearScreen				; Clear the terminal screen (with ANSI codes)
01:800B 212FA8          	   204: 	ld		HL,BootMsg
01:800E CDAE80          	   205: 	call	PrintString				; Print first line of boot message
01:8011 CD8C80          	   206: 	call	PrintLine				; Print a separator line
01:8014 CDAE80          	   207: 	call	PrintString				; Print second line of boot message
01:8017 E5              	   208: 	push	HL
01:8018 21CACB          	   209: 	ld		HL,BytesFree			; Load the amount of bytes free
01:801B CD5880          	   210: 	call	PrintDec
01:801E E1              	   211: 	pop		HL
01:801F CDAE80          	   212: 	call	PrintString
                        	   213: 
01:8022 210000          	   214: 	ld		HL,$0000				; Set default current address
01:8025 2290B0          	   215: 	ld		(CurrentAddress),HL		; Save in CurrentAddress variable
01:8028 3E00            	   216: 	ld		A,0
01:802A D330            	   217: 	out		(BankSelect),A			; Set the bank to number 0
01:802C 328FB0          	   218: 	ld		(CurrentBank),A			; Save the Current Bank
                        	   219: 
                        	   220: 	; Clear the registers
01:802F 3E00            	   221: 	ld		A,0
01:8031 010000          	   222: 	ld		BC,0
01:8034 110000          	   223: 	ld		DE,0
01:8037 210000          	   224: 	ld		HL,0
01:803A DD210000        	   225: 	ld		IX,0
01:803E FD210000        	   226: 	ld		IY,0
01:8042 C5              	   227: 	push	BC						; LSB to clear the flag
01:8043 F1              	   228: 	pop		AF						; Clear flag
                        	   229: 
                        	   230: ;	ei								; Enable interrupts
                        	   231: 
                        	   232: 
                        	   233: ;  __  __           _         
                        	   234: ; |  \/  |   __ _  (_)  _ __  
                        	   235: ; | |\/| |  / _` | | | | '_ \ 
                        	   236: ; | |  | | | (_| | | | | | | |
                        	   237: ; |_|  |_|  \__,_| |_| |_| |_|
                        	   238: ;
                        	   239: ; ----------------------------
                        	   240: ; MAIN LOOP
                        	   241: 
                        	   242: Main:
01:8044 CD9F88          	   243: 	call	CommandPrompt			; Print the command prompt (0000>)
                        	   244: 	
01:8047 C5              	   245: 	push	BC
01:8048 E5              	   246: 	push	HL
                        	   247: 	
01:8049 061E            	   248: 	ld		B,30					; Set the maximum number of bytes to read
01:804B 216EB0          	   249: 	ld		HL,CommandBuffer		; Set the memory area to read the string to
01:804E CDEE80          	   250: 	call	ReadString				; Read a string from console (HL is the address of buffer, BC is character count)
                        	   251: 	
01:8051 E1              	   252: 	pop		HL
01:8052 C1              	   253: 	pop		BC
                        	   254: 	
01:8053 CD5489          	   255: 	call	Parser					; Parse the entered command
                        	   256: 	
01:8056 18EC            	   257: 	jr		Main
                        	   258: 
                        	   259: 
                        	   260: ;  ____            _                              _     _                      
                        	   261: ; / ___|   _   _  | |__    _ __    ___    _   _  | |_  (_)  _ __     ___   ___ 
                        	   262: ; \___ \  | | | | | '_ \  | '__|  / _ \  | | | | | __| | | | '_ \   / _ \ / __|
                        	   263: ;  ___) | | |_| | | |_) | | |    | (_) | | |_| | | |_  | | | | | | |  __/ \__ \
                        	   264: ; |____/   \__,_| |_.__/  |_|     \___/   \__,_|  \__| |_| |_| |_|  \___| |___/
                        	   265: ;
                        	   266: ; ---------------------------------------------------------------------------------------------------------------------
                        	   267: ; ALL SUBROUTINES ARE EMBEDED IN VARIOUS INCLUDE FILES
                        	   268: 
                        	   269: 	.include	"io.asm"			; Input and output subroutines

Source: "io.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- PrintChar		[A ->]
                        	     4: ;	- PrintString	[HL ->]
                        	     5: ;	- PrintCRLF
                        	     6: ;	- PrintNibble	[A ->]
                        	     7: ;	- PrintByte		[A ->]
                        	     8: ;	- PrintWord		[HL ->]
                        	     9: ;	- ReadChar		[-> A]
                        	    10: ;	- ReadString	[HL ->]
                        	    11: ;	- ReadByte		[-> A]
                        	    12: ;	- ReadWord		[-> HL]
                        	    13: ;	- SIO_Init
                        	    14: 
                        	    15: 
                        	    16: ;  ____           _           _     ____                
                        	    17: ; |  _ \   _ __  (_)  _ __   | |_  |  _ \    ___    ___ 
                        	    18: ; | |_) | | '__| | | | '_ \  | __| | | | |  / _ \  / __|
                        	    19: ; |  __/  | |    | | | | | | | |_  | |_| | |  __/ | (__ 
                        	    20: ; |_|     |_|    |_| |_| |_|  \__| |____/   \___|  \___|
                        	    21: ;
                        	    22: ;
                        	    23: ; *********************************************************************************************************************
                        	    24: ; Prints a hex number to Decimal on the console
                        	    25: ;	- Input:	HL = 16-bit hex number
                        	    26: ;	- Ouput:	HL = Untouched 16-bit hex number
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: PrintDec:
01:8058 E5              	    30: 	push	HL
01:8059 CD0C82          	    31: 	call	Hex2Dec
01:805C CDAE80          	    32: 	call	PrintString
01:805F E1              	    33: 	pop		HL
01:8060 C9              	    34: 	ret
                        	    35: 
                        	    36: 
                        	    37: ;  ____           _           _     ____            _          
                        	    38: ; |  _ \   _ __  (_)  _ __   | |_  | __ )   _   _  | |_    ___ 
                        	    39: ; | |_) | | '__| | | | '_ \  | __| |  _ \  | | | | | __|  / _ \
                        	    40: ; |  __/  | |    | | | | | | | |_  | |_) | | |_| | | |_  |  __/
                        	    41: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__, |  \__|  \___|
                        	    42: ;                                           |___/              
                        	    43: ;
                        	    44: ; *********************************************************************************************************************
                        	    45: ; Prints a byte to the console
                        	    46: ;	- Input:	A (Byte to print)
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: PrintByte:
01:8061 F5              	    50: 	push	AF
01:8062 F5              	    51: 	push	AF
01:8063 CB3F            	    52: 	srl		A					; Push the uppermost nibble to the lower half
01:8065 CB3F            	    53: 	srl		A
01:8067 CB3F            	    54: 	srl		A
01:8069 CB3F            	    55: 	srl		A
01:806B CD9E80          	    56: 	call	PrintNibble			; Print the first nibble of the byte
01:806E F1              	    57: 	pop		AF
01:806F CD9E80          	    58: 	call	PrintNibble			; Print the second nibble of the byte
01:8072 F1              	    59: 	pop		AF
01:8073 C9              	    60: 	ret
                        	    61: 
                        	    62: 
                        	    63: ;  ____           _           _      ____   _                    
                        	    64: ; |  _ \   _ __  (_)  _ __   | |_   / ___| | |__     __ _   _ __ 
                        	    65: ; | |_) | | '__| | | | '_ \  | __| | |     | '_ \   / _` | | '__|
                        	    66: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | (_| | | |   
                        	    67: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| |_|  \__,_| |_|   
                        	    68: ;
                        	    69: 
                        	    70: ; *********************************************************************************************************************
                        	    71: ; Print a character to the console
                        	    72: ;	- Input: A (Character to transmit)
                        	    73: ; *********************************************************************************************************************
                        	    74: 
                        	    75: PrintChar:
01:8074 F5              	    76: 	push	AF
                        	    77: PrintCharTxWait:
01:8075 DB02            	    78: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in accumulator
01:8077 E604            	    79: 	and		%00000100				; Isolate bit 2: TX Buffer Empty
01:8079 28FA            	    80: 	jr		z,PrintCharTxWait		; If it's busy, then wait
01:807B F1              	    81: 	pop		AF
01:807C D300            	    82: 	out		(SIO_PortA_Data),A		; Transmit the character in accumulator
01:807E C9              	    83: 	ret
                        	    84: 
                        	    85: 
                        	    86: ;  ____           _           _      ____   ____    _       _____ 
                        	    87: ; |  _ \   _ __  (_)  _ __   | |_   / ___| |  _ \  | |     |  ___|
                        	    88: ; | |_) | | '__| | | | '_ \  | __| | |     | |_) | | |     | |_   
                        	    89: ; |  __/  | |    | | | | | | | |_  | |___  |  _ <  | |___  |  _|  
                        	    90: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| \_\ |_____| |_|    
                        	    91: 
                        	    92: 
                        	    93: ; *********************************************************************************************************************
                        	    94: ; Print a carriage-return and line-feed to serial port A
                        	    95: ; *********************************************************************************************************************
                        	    96: 
                        	    97: PrintCRLF:
01:807F F5              	    98: 	push	AF
01:8080 3E0D            	    99: 	ld		A,CR
01:8082 CD7480          	   100: 	call	PrintChar				; Print carriage-return
01:8085 3E0A            	   101: 	ld		A,LF
01:8087 CD7480          	   102: 	call	PrintChar				; Print line-feed
01:808A F1              	   103: 	pop		AF
01:808B C9              	   104: 	ret
                        	   105: 
                        	   106: 
                        	   107: ;  ____           _           _     _       _                
                        	   108: ; |  _ \   _ __  (_)  _ __   | |_  | |     (_)  _ __     ___ 
                        	   109: ; | |_) | | '__| | | | '_ \  | __| | |     | | | '_ \   / _ \
                        	   110: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | | |  __/
                        	   111: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_| |_| |_|  \___|
                        	   112: 
                        	   113: 
                        	   114: ; *********************************************************************************************************************
                        	   115: ; Prints a line (the size of HorizTextRes)
                        	   116: ; *********************************************************************************************************************
                        	   117: 
                        	   118: PrintLine:
01:808C F5              	   119: 	push	AF
01:808D C5              	   120: 	push	BC
01:808E 3E28            	   121: 	ld		A,HorizTextRes			; Load the screen width constant
01:8090 47              	   122: 	ld		B,A						; Place it register B
01:8091 3E2D            	   123: 	ld		A,"-"					; Load the dash character
                        	   124: PrintLineLoop:
01:8093 CD7480          	   125: 	call	PrintChar				; Print the dash
01:8096 10FB            	   126: 	djnz	PrintLineLoop			; Decrement B, and loop until B is 0
01:8098 CD7F80          	   127: 	call	PrintCRLF				; Change line
01:809B C1              	   128: 	pop		BC
01:809C F1              	   129: 	pop		AF
01:809D C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____           _           _     _   _   _   _       _       _        
                        	   134: ; |  _ \   _ __  (_)  _ __   | |_  | \ | | (_) | |__   | |__   | |   ___ 
                        	   135: ; | |_) | | '__| | | | '_ \  | __| |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	   136: ; |  __/  | |    | | | | | | | |_  | |\  | | | | |_) | | |_) | | | |  __/
                        	   137: ; |_|     |_|    |_| |_| |_|  \__| |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	   138: 
                        	   139: 
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Prints a nibble to the console
                        	   142: ;	- Input:	A (LSB to print)
                        	   143: ; *********************************************************************************************************************
                        	   144: 
                        	   145: PrintNibble:
01:809E F5              	   146: 	push	AF
01:809F E60F            	   147: 	and		$0F						; Filter out MSB
01:80A1 C630            	   148: 	add     "0"						; Add ASCII character 0
01:80A3 FE3A            	   149: 	cp      "9"+1					; Is the value numeric values?
01:80A5 3802            	   150: 	jr		c,PrintNibbleEnd		; Yes, then exit with 0 through 9
01:80A7 C607            	   151: 	add     "A"-"9"-1				; No, then exit with A through F
                        	   152: PrintNibbleEnd:
01:80A9 CD7480          	   153: 	call	PrintChar				; Print the nibble
01:80AC F1              	   154: 	pop		AF
01:80AD C9              	   155: 	ret
                        	   156: 	
                        	   157: 	
                        	   158: ;  ____           _           _     ____    _            _                 
                        	   159: ; |  _ \   _ __  (_)  _ __   | |_  / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   160: ; | |_) | | '__| | | | '_ \  | __| \___ \  | __| | '__| | | | '_ \   / _` |
                        	   161: ; |  __/  | |    | | | | | | | |_   ___) | | |_  | |    | | | | | | | (_| |
                        	   162: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   163: ;                                                                    |___/ 
                        	   164: ;
                        	   165: ; *********************************************************************************************************************
                        	   166: ; Prints a string to serial port A, until the null character is reached
                        	   167: ;	- Input:	HL = Address pointer of string to transmit
                        	   168: ;	- Output:	HL = Address pointer to the next character, past NULL (Practical for printing lines in between text)
                        	   169: ; *********************************************************************************************************************
                        	   170: 
                        	   171: PrintString:
01:80AE F5              	   172: 	push	AF
                        	   173: PrintStringLoop:
01:80AF 7E              	   174: 	ld		A,(HL)					; Load character to print in accumulator
01:80B0 23              	   175: 	inc		HL						; Increment HL to next character to print
01:80B1 FE00            	   176: 	cp		0					; Is it the end of the string?
01:80B3 2805            	   177: 	jr		z,PrintStringEnd		; Yes, then exit routine
01:80B5 CD7480          	   178: 	call	PrintChar				; Print the character
01:80B8 18F5            	   179: 	jr		PrintStringLoop			; Repeat the loop until null character is reached
                        	   180: PrintStringEnd:
01:80BA F1              	   181: 	pop		AF
01:80BB C9              	   182: 	ret
                        	   183: 
                        	   184: 
                        	   185: ;  ____           _           _    __        __                     _ 
                        	   186: ; |  _ \   _ __  (_)  _ __   | |_  \ \      / /   ___    _ __    __| |
                        	   187: ; | |_) | | '__| | | | '_ \  | __|  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   188: ; |  __/  | |    | | | | | | | |_    \ V  V /   | (_) | | |    | (_| |
                        	   189: ; |_|     |_|    |_| |_| |_|  \__|    \_/\_/     \___/  |_|     \__,_|
                        	   190: 
                        	   191: 
                        	   192: ; *********************************************************************************************************************
                        	   193: ; Prints a 16-bit word (double-byte) to the console
                        	   194: ;	- Input: HL (Word to print)
                        	   195: ; *********************************************************************************************************************
                        	   196: 
                        	   197: PrintWord:
01:80BC F5              	   198: 	push	AF
01:80BD 7C              	   199: 	ld		A,H						; Get the first byte in accumulator
01:80BE CD6180          	   200: 	call	PrintByte				; Print first byte
01:80C1 7D              	   201: 	ld		A,L						; Get the second byte in accumulator
01:80C2 CD6180          	   202: 	call	PrintByte				; Print second byte
01:80C5 F1              	   203: 	pop		AF
01:80C6 C9              	   204: 	ret
                        	   205: 
                        	   206: 
                        	   207: ;  ____                       _    ____   _                    
                        	   208: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __ 
                        	   209: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__|
                        	   210: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |   
                        	   211: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|   
                        	   212: 
                        	   213: 
                        	   214: ; *********************************************************************************************************************
                        	   215: ; Read a character from the console (waiting)
                        	   216: ;	- Output:	Character received in A
                        	   217: ; *********************************************************************************************************************
                        	   218: 
                        	   219: ReadChar:
01:80C7 DB02            	   220: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80C9 E601            	   221: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80CB 28FA            	   222: 	jr		z,ReadChar				; If there's no character in buffer, loop until one is present
01:80CD DB00            	   223: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80CF C9              	   224: 	ret
                        	   225: 
                        	   226: 
                        	   227: ;  ____                       _    ____   _                      _   _          __        __          _   _   
                        	   228: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __  | \ | |   ___   \ \      / /   __ _  (_) | |_ 
                        	   229: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__| |  \| |  / _ \   \ \ /\ / /   / _` | | | | __|
                        	   230: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |    | |\  | | (_) |   \ V  V /   | (_| | | | | |_ 
                        	   231: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|    |_| \_|  \___/     \_/\_/     \__,_| |_|  \__|
                        	   232: ;
                        	   233: ;
                        	   234: ; *********************************************************************************************************************
                        	   235: ; Read a character from the console if present (non-waiting)
                        	   236: ;	- Output:	Character in A if received.
                        	   237: ;				A = 0 if no character received.
                        	   238: ;				Z = not ready, NZ = has character
                        	   239: ; *********************************************************************************************************************
                        	   240: 
                        	   241: ReadCharNoWait:
01:80D0 DB02            	   242: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80D2 E601            	   243: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80D4 3E00            	   244: 	ld		A,$00					; Put nothing in A
01:80D6 C8              	   245: 	ret		z						; Return if not ready
01:80D7 DB00            	   246: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80D9 B7              	   247: 	or		A						; Resets the carry flag (and zero)
01:80DA C9              	   248: 	ret
                        	   249: 
                        	   250: 
                        	   251: ;  ____                       _   ____            _          
                        	   252: ; |  _ \    ___    __ _    __| | | __ )   _   _  | |_    ___ 
                        	   253: ; | |_) |  / _ \  / _` |  / _` | |  _ \  | | | | | __|  / _ \
                        	   254: ; |  _ <  |  __/ | (_| | | (_| | | |_) | | |_| | | |_  |  __/
                        	   255: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__, |  \__|  \___|
                        	   256: ;                                         |___/              
                        	   257: ;
                        	   258: ; *********************************************************************************************************************
                        	   259: ; Read a byte (2 ASCII Hex characters) from the console (waiting)
                        	   260: ;	- Output: Byte received in A
                        	   261: ; *********************************************************************************************************************
                        	   262: 
                        	   263: ReadByte:
01:80DB E5              	   264: 	push	HL
01:80DC 2192B0          	   265: 	ld		HL,DigitString			; Point to staging area to convert ASCII Characters to a byte
01:80DF CDC780          	   266: 	call	ReadChar				; Read first character
01:80E2 77              	   267: 	ld		(HL),A					; Store it
01:80E3 23              	   268: 	inc		HL						; Point to the next cell
01:80E4 CDC780          	   269: 	call	ReadChar				; Read second character
01:80E7 77              	   270: 	ld		(HL),A					; Store it
01:80E8 2B              	   271: 	dec		HL						; Point back to the beginning
01:80E9 CD8D81          	   272: 	call	Ascii2HexByte
01:80EC E1              	   273: 	pop		HL
01:80ED C9              	   274: 	ret
                        	   275: 
                        	   276: 
                        	   277: ;  ____                       _   ____    _            _                 
                        	   278: ; |  _ \    ___    __ _    __| | / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   279: ; | |_) |  / _ \  / _` |  / _` | \___ \  | __| | '__| | | | '_ \   / _` |
                        	   280: ; |  _ <  |  __/ | (_| | | (_| |  ___) | | |_  | |    | | | | | | | (_| |
                        	   281: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   282: ;                                                                  |___/ 
                        	   283: 
                        	   284: ; *********************************************************************************************************************
                        	   285: ; Read a string from console
                        	   286: ;	- Input:	HL = Points to the memory area to store string
                        	   287: ;				B = Bytes to count
                        	   288: ;	- Output:	HL = Points to the start of string
                        	   289: ; *********************************************************************************************************************
                        	   290: 
                        	   291: ReadString:
01:80EE F5              	   292: 	push	AF
01:80EF C5              	   293: 	push	BC
01:80F0 D5              	   294: 	push	DE
01:80F1 E5              	   295: 	push	HL						; Store the start position
                        	   296: 
01:80F2 0E00            	   297: 	ld		C,0						; Character counter initialized to zero
01:80F4 E5              	   298: 	push	HL						; Save HL's start position...
01:80F5 D1              	   299: 	pop		DE						; in DE for later use
                        	   300: ;	ld		HL,CommandBuffer		; Load CommandBuffer location in HL
                        	   301: 
                        	   302: ; READ A CHARACTER AND VALIDATE
                        	   303: ReadStringChar:	
01:80F6 CDC780          	   304: 	call	ReadChar				; Read a character from console
01:80F9 FE08            	   305: 	cp		BKSP					; Is it the backspace?
01:80FB 281C            	   306: 	jr		z,ReadStringBS			; If it is, then erase last character
01:80FD FE1B            	   307: 	cp		ESC						; Is it the escape key?
01:80FF 2831            	   308: 	jr		z,ReadStringESC			; If it is, then ignore whatever has been entered
01:8101 FE0D            	   309: 	cp		CR						; Is it the carriage return?
01:8103 282E            	   310: 	jr		z,ReadStringCR			; If it is, then end the routine
01:8105 FE80            	   311: 	cp		$80						; Is it a character above or equal to the ASCII value $80?
01:8107 30ED            	   312: 	jr		nc,ReadStringChar		; Loop to get a valid ASCII character
01:8109 FE20            	   313: 	cp		$20						; Is it any other non-printable character?
01:810B 38E9            	   314: 	jr		c,ReadStringChar		; Loop to get a valid ASCII character
                        	   315: 
                        	   316: ; STORE THE CHARACTER IN THE BUFFER
                        	   317: ReadStringSave:
01:810D CD7480          	   318: 	call	PrintChar				; Echo typed character on screen
                        	   319: ;	call	UpperCase				; *** (Optional) *****************************
01:8110 77              	   320: 	ld		(HL),A					; Store character in memory
01:8111 23              	   321: 	inc		HL						; Increment buffer to next spot
01:8112 0C              	   322: 	inc		C						; Increment bytes counter
01:8113 78              	   323: 	ld		A,B						; Load total bytes to read in accumulator
01:8114 B9              	   324: 	cp		C						; Has the total number of characters been read?
01:8115 3802            	   325: 	jr		c,ReadStringBS			; If it was one too many characters, backspace
01:8117 18DD            	   326: 	jr		ReadStringChar			; Else, loop to get the next character
                        	   327: 
                        	   328: ReadStringBS:
01:8119 79              	   329: 	ld		A,C						; Load characther counter in accumulator
01:811A FE00            	   330: 	cp		0						; Are there any characters to erase?
01:811C CAF680          	   331: 	jp		z,ReadStringChar		; No, then go read another character
01:811F 0D              	   332: 	dec		C						; Else, decrement character counter by one
01:8120 2B              	   333: 	dec		HL						; And decrement buffer to previous spot
01:8121 3E08            	   334: 	ld		A,BKSP					; Erace character on screen...
01:8123 CD7480          	   335: 	call	PrintChar				; Go back one previous character
01:8126 3E20            	   336: 	ld		A," "					;
01:8128 CD7480          	   337: 	call	PrintChar				; Overwrite the character with a space
01:812B 3E08            	   338: 	ld		A,BKSP					;
01:812D CD7480          	   339: 	call	PrintChar				; Then go back one character again
01:8130 18C4            	   340: 	jr		ReadStringChar			; Get the next character
                        	   341: 	
                        	   342: ReadStringESC:
01:8132 EB              	   343: 	ex		DE,HL					; Restore start position of HL
                        	   344: ;	ld		HL,CommandBuffer		; Point CommandBuffer to start
                        	   345: 
                        	   346: ReadStringCR:
01:8133 3600            	   347: 	ld		(HL),0					; Write NULL character in buffer to indicate end of string
01:8135 CD7F80          	   348: 	call	PrintCRLF				; Change line
                        	   349: 	
01:8138 E1              	   350: 	pop		HL						; Points to the start of the string
01:8139 D1              	   351: 	pop		DE
01:813A C1              	   352: 	pop		BC
01:813B F1              	   353: 	pop		AF
01:813C C9              	   354: 	ret
                        	   355: 
                        	   356: 
                        	   357: ;  ____                       _  __        __                     _ 
                        	   358: ; |  _ \    ___    __ _    __| | \ \      / /   ___    _ __    __| |
                        	   359: ; | |_) |  / _ \  / _` |  / _` |  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   360: ; |  _ <  |  __/ | (_| | | (_| |   \ V  V /   | (_) | | |    | (_| |
                        	   361: ; |_| \_\  \___|  \__,_|  \__,_|    \_/\_/     \___/  |_|     \__,_|
                        	   362: 
                        	   363: 
                        	   364: ; *********************************************************************************************************************
                        	   365: ; Read a word (4 ASCII Hex characters) from the console (waiting)
                        	   366: ;	- Output: Word received in HL
                        	   367: ; *********************************************************************************************************************
                        	   368: 
                        	   369: ReadWord:
01:813D F5              	   370: 	push	AF
01:813E CDDB80          	   371: 	call	ReadByte			; Read first byte (first and second ASCII character)
01:8141 67              	   372: 	ld		H,A					; Store the MSB
01:8142 CDDB80          	   373: 	call	ReadByte			; Read second byte (third and fourth ASCII character)
01:8145 6F              	   374: 	ld		L,A					; Store the LSB
01:8146 CDAC81          	   375: 	call	Ascii2HexWord		; Convert the ASCII characters to a word, result in BC
01:8149 F1              	   376: 	pop		AF
01:814A C9              	   377: 	ret
                        	   378: 
                        	   379: 	
                        	   380: ;  ____    ___    ___            ___           _   _   
                        	   381: ; / ___|  |_ _|  / _ \          |_ _|  _ __   (_) | |_ 
                        	   382: ; \___ \   | |  | | | |          | |  | '_ \  | | | __|
                        	   383: ;  ___) |  | |  | |_| |          | |  | | | | | | | |_ 
                        	   384: ; |____/  |___|  \___/   _____  |___| |_| |_| |_|  \__|
                        	   385: ;                       |_____|                        
                        	   386: 
                        	   387: ; *********************************************************************************************************************
                        	   388: ; Initializes SIO port A
                        	   389: ;   - Destroys: AF, HL, BC (There's usually no need to save registers in the init stage)
                        	   390: ; *********************************************************************************************************************
                        	   391: 
                        	   392: SIO_Init:
01:814B 3E18            	   393: 	ld		A,%00011000				; Perform channel reset
01:814D D302            	   394: 	out		(SIO_PortA_Ctrl),A		; Requires four extra clock cycles for the SIO reset time
01:814F 00              	   395: 	nop
01:8150 3E04            	   396: 	ld		A,%00000100				; WR0: select register 4
01:8152 D302            	   397: 	out		(SIO_PortA_Ctrl),A
01:8154 3E44            	   398: 	ld		A,%01000100				; WR4: 1/16 (115200 @ 1.8432MHZ), 8-bit sync, 1 stop bit, no parity
01:8156 D302            	   399: 	out		(SIO_PortA_Ctrl),A
01:8158 3E03            	   400: 	ld		A,%00000011				; WR0: select register 3
01:815A D302            	   401: 	out		(SIO_PortA_Ctrl),A
01:815C 3EC1            	   402: 	ld		A,%11000001				; WR3: 8-bits/char, RX enabled
01:815E D302            	   403: 	out		(SIO_PortA_Ctrl),A
01:8160 3E05            	   404: 	ld		A,%00000101				; WR0: select register 5
01:8162 D302            	   405: 	out		(SIO_PortA_Ctrl),A
01:8164 3E68            	   406: 	ld		A,%01101000				; WR5: DTR=0, 8-bits/char, TX enabled
01:8166 D302            	   407: 	out		(SIO_PortA_Ctrl),A
01:8168 C9              	   408: 	ret
                        	   409: 

Source: "main.asm"
                        	   270: 	.include	"convert.asm"		; Convert and process data subroutines

Source: "convert.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- Ascii2HexNibble	[A -> A]
                        	     4: ;	- Ascii2HexByte		[HL -> A]
                        	     5: ;	- Ascii2HexWord		[HL -> BC]
                        	     6: ;	- UpperCase			[A -> A]
                        	     7: 
                        	     8: ; *********************************************************************************************************************
                        	     9: ; Converts a single decimal digit to BCD
                        	    10: ;	- Input:	A = Contains the ASCII character to convert to BCD
                        	    11: ;	- Output:	A = Contains the 4-bit BCD value in LSB
                        	    12: ;				Carry set if valid; Carry clear if error
                        	    13: ; *********************************************************************************************************************
                        	    14: 
                        	    15: Ascii2BcdDigit:
                        	    16: 
                        	    17: ;     _                   _   _   ____    _   _                 _   _   _   _       _       _        
                        	    18: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | \ | | (_) | |__   | |__   | |   ___ 
                        	    19: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	    20: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |\  | | | | |_) | | |_) | | | |  __/
                        	    21: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	    22: ;
                        	    23: 
                        	    24: ; *********************************************************************************************************************
                        	    25: ; Converts a single ASCII hex character to a nibble, and validate if it's ok
                        	    26: ;	- Input:	A = Contains the ASCII character to convert to hex value
                        	    27: ;	- Output:	A = Converted 4-bit value in LSB
                        	    28: ;				Carry set if valid; Carry clear if error
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: Ascii2HexNibble:
01:8169 CD9F82          	    32: 	call	UpperCase				; Convert a-f to uppercase
01:816C FE30            	    33: 	cp		"0"						; If it's anything bellow 0
01:816E 381B            	    34: 	jr		c,Ascii2HexNibbleErr	; Then indicate an error
01:8170 FE47            	    35: 	cp		"F"+1					; If it's anything above F
01:8172 3017            	    36: 	jr		nc,Ascii2HexNibbleErr	; Then indicate an error
01:8174 FE3A            	    37: 	cp		"9"+1					; Check if it's less then 9
01:8176 3806            	    38: 	jr		c,Ascii2HexNibbleOK		; Then it's a valid 0-9 digit
01:8178 FE41            	    39: 	cp		"A"						; Check if it's above A
01:817A 3002            	    40: 	jr		nc,Ascii2HexNibbleOK	; Then it's a valid A-F hex digit
01:817C 180D            	    41: 	jr		Ascii2HexNibbleErr		; Else, anything in between is an error
                        	    42: 
                        	    43: Ascii2HexNibbleOK:
01:817E D630            	    44: 	sub		$30						; Substract $30 to transform character 0-9 into a number
01:8180 FE0A            	    45: 	cp		9+1						; Is it a decimal 0-9 digit?
01:8182 3802            	    46: 	jr		c,Ascii2HexNibbleEnd	; If it's then return value it as is
01:8184 D607            	    47: 	sub		$07						; If not, then substract the alpha offset to get A-F
                        	    48: 
                        	    49: Ascii2HexNibbleEnd:
01:8186 CD4A89          	    50: 	call	IncErrorPointer			; Increment command line error pointer
01:8189 37              	    51: 	scf								; Set carry flag
01:818A C9              	    52: 	ret
                        	    53: 
                        	    54: Ascii2HexNibbleErr:
01:818B B7              	    55: 	or		A						; Clear carry flag
01:818C C9              	    56: 	ret
                        	    57: 
                        	    58: 
                        	    59: ;     _                   _   _   ____    _   _                 ____            _          
                        	    60: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	    61: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	    62: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	    63: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	    64: ;                                                                       |___/              
                        	    65: ;
                        	    66: ; *********************************************************************************************************************
                        	    67: ; Converts a pair of ASCII hex characters to a byte and validate if it's ok
                        	    68: ;	- Input:	HL = Points to the two characters to convert
                        	    69: ;	- Output:	A = Converted 8-bit byte
                        	    70: ;				HL = points to the next position
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: Ascii2HexByte:
01:818D C5              	    75: 	push	BC
01:818E 7E              	    76: 	ld		A,(HL)
01:818F 23              	    77: 	inc		HL
01:8190 CD6981          	    78: 	call	Ascii2HexNibble			; Convert the first character (MSB)
01:8193 3014            	    79: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:8195 CB27            	    80: 	sla		A						; Place result to the MSB position...
01:8197 CB27            	    81: 	sla		A						;	by shifting it 4 times to the left...
01:8199 CB27            	    82: 	sla		A						;	and zeroing out the LSB in the process
01:819B CB27            	    83: 	sla		A						;
01:819D 47              	    84: 	ld		B,A						; Save resulting MSB
01:819E 7E              	    85: 	ld		A,(HL)
01:819F 23              	    86: 	inc		HL
01:81A0 CD6981          	    87: 	call	Ascii2HexNibble			; Convert the second character (LSB)
01:81A3 3004            	    88: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:81A5 B0              	    89: 	or		B						; Merge MSB with LSB, result in A
01:81A6 C1              	    90: 	pop		BC
01:81A7 37              	    91: 	scf								; Set carry flag
01:81A8 C9              	    92: 	ret
                        	    93: 
                        	    94: Ascii2HexByteErr:
01:81A9 C1              	    95: 	pop		BC
01:81AA B7              	    96: 	or		A						; Clear carry flag
01:81AB C9              	    97: 	ret
                        	    98: 
                        	    99: 
                        	   100: ;     _                   _   _   ____    _   _                 ____            _          
                        	   101: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	   102: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	   103: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	   104: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	   105: ;                                                                       |___/              
                        	   106: ;
                        	   107: ; *********************************************************************************************************************
                        	   108: ; Converts four ASCII hex characters to a 16-bit word and validate if it's ok
                        	   109: ;	- Input:	HL = Points to the 4 characters to be converted
                        	   110: ;	- Output:	BC = Contains the 16-bit value
                        	   111: ;				HL = points to the next position
                        	   112: ;				Carry set if valid; Carry clear if error
                        	   113: ; *********************************************************************************************************************
                        	   114: 
                        	   115: Ascii2HexWord:
01:81AC F5              	   116: 	push	AF
01:81AD CD8D81          	   117: 	call	Ascii2HexByte			; Convert the upper 2 characters (MSB)
01:81B0 300A            	   118: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B2 47              	   119: 	ld		B,A						; Save the MSB result to B
01:81B3 CD8D81          	   120: 	call	Ascii2HexByte			; Convert the lower 2 characters (LSB)
01:81B6 3004            	   121: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B8 4F              	   122: 	ld		C,A						; Save the the LSB
01:81B9 F1              	   123: 	pop		AF
01:81BA 37              	   124: 	scf								; Set carry flag
01:81BB C9              	   125: 	ret
                        	   126: 	
                        	   127: Ascii2HexWordErr:
01:81BC F1              	   128: 	pop		AF
01:81BD B7              	   129: 	or		A						; Clear carry flag
01:81BE C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____                  ____    _   _               
                        	   134: ; |  _ \    ___    ___  |___ \  | | | |   ___  __  __
                        	   135: ; | | | |  / _ \  / __|   __) | | |_| |  / _ \ \ \/ /
                        	   136: ; | |_| | |  __/ | (__   / __/  |  _  | |  __/  >  < 
                        	   137: ; |____/   \___|  \___| |_____| |_| |_|  \___| /_/\_\
                        	   138: ;
                        	   139: ;
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Convert decimal digits in a string to a hex number
                        	   142: ;	- Input:	HL = Points to the string the decimal characters are
                        	   143: ;	- Output:	BC = 16-bit hex value
                        	   144: ;				HL = Points to the next position after the last decimal number
                        	   145: ; *********************************************************************************************************************
                        	   146: 
                        	   147: Dec2Hex:
01:81BF F5              	   148: 	push	AF
01:81C0 D5              	   149: 	push	DE
                        	   150: 	
01:81C1 CD378B          	   151: 	call	SkipSpaces
01:81C4 EB              	   152: 	ex		DE,HL					; HL is normally processed for strings, but ADD requires HL in this routine
01:81C5 210000          	   153: 	ld		HL,0
                        	   154: Dec2HexLoop:		
01:81C8 1A              	   155: 	ld		A,(DE)					; HL is required for add, so DE is used to grab the string instead of HL
01:81C9 FE00            	   156: 	cp		0
01:81CB 2829            	   157: 	jr		z,Dec2HexShuffleRegs
01:81CD FE20            	   158: 	cp		DELIMITER
01:81CF 2825            	   159: 	jr		z,Dec2HexShuffleRegs
                        	   160: 	
01:81D1 FE30            	   161: 	cp		"0"						; If it's anything bellow 0
01:81D3 382D            	   162: 	jr		c,Dec2HexInvalidDec		; Then indicate an error
01:81D5 FE3A            	   163: 	cp		"9"+1					; Check if it's less then 9
01:81D7 3029            	   164: 	jr		nc,Dec2HexInvalidDec	; Then indicate an error
                        	   165: 
01:81D9 D630            	   166: 	sub		$30						; Convert ASCII decimal to BCD
01:81DB 13              	   167: 	inc		DE						; Increment buffer pointer
01:81DC CD4A89          	   168: 	call	IncErrorPointer
                        	   169: 
01:81DF E5              	   170: 	push	HL
01:81E0 C1              	   171: 	pop		BC
                        	   172: 
01:81E1 29              	   173: 	add		HL,HL
01:81E2 3818            	   174: 	jr		c,Dec2HexOutOfRange
01:81E4 29              	   175: 	add		HL,HL	
01:81E5 3815            	   176: 	jr		c,Dec2HexOutOfRange
01:81E7 09              	   177: 	add		HL,BC	
01:81E8 3812            	   178: 	jr		c,Dec2HexOutOfRange
01:81EA 29              	   179: 	add		HL,HL
01:81EB 380F            	   180: 	jr		c,Dec2HexOutOfRange
                        	   181: 	
01:81ED 85              	   182: 	add		L	
01:81EE 6F              	   183: 	ld		L,A	
01:81EF 30D7            	   184: 	jr		nc,Dec2HexLoop
01:81F1 24              	   185: 	inc		H
01:81F2 3808            	   186: 	jr		c,Dec2HexOutOfRange
01:81F4 18D2            	   187: 	jr		Dec2HexLoop
                        	   188: 
                        	   189: Dec2HexShuffleRegs:
01:81F6 E5              	   190: 	push	HL						; Push result in BC
01:81F7 C1              	   191: 	pop		BC						;
01:81F8 EB              	   192: 	ex		DE,HL					; Place buffer pointer in HL
01:81F9 37              	   193: 	scf								; Set Carry
01:81FA 180D            	   194: 	jr		Dec2HexEnd
                        	   195: 
                        	   196: Dec2HexOutOfRange:
01:81FC CD4DB0          	   197: 	call	NumberOutOfRange
01:81FF B7              	   198: 	or		A
01:8200 1807            	   199: 	jr		Dec2HexEnd
                        	   200: 	
                        	   201: Dec2HexInvalidDec:
01:8202 CDBC89          	   202: 	call	PrintErrorPointer
01:8205 CD56B0          	   203: 	call	InvalidDecimalNumber
01:8208 B7              	   204: 	or		A
                        	   205: 	
                        	   206: Dec2HexEnd:
01:8209 D1              	   207: 	pop		DE
01:820A F1              	   208: 	pop		AF
01:820B C9              	   209: 	ret
                        	   210: 
                        	   211: 
                        	   212: ;  _   _                 ____    ____                
                        	   213: ; | | | |   ___  __  __ |___ \  |  _ \    ___    ___ 
                        	   214: ; | |_| |  / _ \ \ \/ /   __) | | | | |  / _ \  / __|
                        	   215: ; |  _  | |  __/  >  <   / __/  | |_| | |  __/ | (__ 
                        	   216: ; |_| |_|  \___| /_/\_\ |_____| |____/   \___|  \___|
                        	   217: ;
                        	   218: ;
                        	   219: ; *********************************************************************************************************************
                        	   220: ; Convert a 16-bit a hex binary data to a decimal string
                        	   221: ;	- Input:	HL = 16-bit hex number
                        	   222: ;	- Output:	HL = Start of string pointer (DigitString variable) - Ends with null
                        	   223: ; *********************************************************************************************************************
                        	   224: ; B is the first non-zero flag, so as not to print leading zero's
                        	   225: 
                        	   226: Hex2Dec:
01:820C F5              	   227: 	push	AF
01:820D C5              	   228: 	push	BC
01:820E D5              	   229: 	push	DE
01:820F DDE5            	   230: 	push	IX
                        	   231: 
01:8211 0600            	   232: 	ld		B,0
01:8213 DD2192B0        	   233: 	ld		IX,DigitString
                        	   234: Hex2Dec10000:
                        	   235: 	; CALCULATE THE 10,000's
01:8217 3EFF            	   236: 	ld		A,-1					; Start at -1
                        	   237: Hex2Dec10000Loop:
01:8219 3C              	   238: 	inc		A						; Add 1
01:821A B7              	   239: 	or		A						; Clear carry
01:821B 111027          	   240: 	ld		DE,10000
01:821E ED52            	   241: 	sbc		HL,DE					; Substract 10,000
01:8220 30F7            	   242: 	jr		nc,Hex2Dec10000Loop		; Continue if not reached negative
01:8222 19              	   243: 	add		HL,DE					; Add 10,000 back to make it positive
01:8223 FE00            	   244: 	cp		0
01:8225 2002            	   245: 	jr		nz,Hex2Dec10000Set
01:8227 1809            	   246: 	jr		Hex2Dec1000				; If it's not set
                        	   247: Hex2Dec10000Set
01:8229 CBC0            	   248: 	set		0,B
01:822B C630            	   249: 	add		$30
01:822D DD7700          	   250: 	ld		(IX),A
01:8230 DD23            	   251: 	inc		IX
                        	   252: 
                        	   253: 	; CALCULATE THE 1,000's
                        	   254: Hex2Dec1000:
01:8232 3EFF            	   255: 	ld		A,-1					; Start at -1
                        	   256: Hex2Dec1000Loop:
01:8234 3C              	   257: 	inc		A						; Add 1
01:8235 B7              	   258: 	or		A						; Clear carry
01:8236 11E803          	   259: 	ld		DE,1000
01:8239 ED52            	   260: 	sbc		HL,DE					; Substract 1,000
01:823B 30F7            	   261: 	jr		nc,Hex2Dec1000Loop		; Continue if not reached negative
01:823D 19              	   262: 	add		HL,DE					; Add 1,000 back to make it positive
01:823E FE00            	   263: 	cp		0
01:8240 2004            	   264: 	jr		nz,Hex2Dec1000Set
01:8242 CB40            	   265: 	bit		0,B						; Check the flag
01:8244 2809            	   266: 	jr		z,Hex2Dec100			; If it's not set
                        	   267: Hex2Dec1000Set
01:8246 CBC0            	   268: 	set		0,B						
01:8248 C630            	   269: 	add		$30
01:824A DD7700          	   270: 	ld		(IX),A
01:824D DD23            	   271: 	inc		IX
                        	   272: 
                        	   273: 	; CALCULATE THE 100's
                        	   274: Hex2Dec100:
01:824F 3EFF            	   275: 	ld		A,-1					; Start at -1
                        	   276: Hex2Dec100Loop:
01:8251 3C              	   277: 	inc		A						; Add 1
01:8252 B7              	   278: 	or		A						; Clear carry
01:8253 116400          	   279: 	ld		DE,100
01:8256 ED52            	   280: 	sbc		HL,DE					; Substract 100
01:8258 30F7            	   281: 	jr		nc,Hex2Dec100Loop		; Continue if not reached negative
01:825A 19              	   282: 	add		HL,DE					; Add 100 back to make it positive
01:825B FE00            	   283: 	cp		0
01:825D 2004            	   284: 	jr		nz,Hex2Dec100Set
01:825F CB40            	   285: 	bit		0,B						; Check the flag
01:8261 2809            	   286: 	jr		z,Hex2Dec10				; If it's not set
                        	   287: Hex2Dec100Set
01:8263 CBC0            	   288: 	set		0,B						
01:8265 C630            	   289: 	add		$30
01:8267 DD7700          	   290: 	ld		(IX),A
01:826A DD23            	   291: 	inc		IX
                        	   292: 
                        	   293: 
                        	   294: 	; CALCULATE THE 10's
                        	   295: Hex2Dec10:
01:826C 3EFF            	   296: 	ld		A,-1					; Start at -1
                        	   297: Hex2Dec10Loop:
01:826E 3C              	   298: 	inc		A						; Add 1
01:826F B7              	   299: 	or		A						; Clear carry
01:8270 110A00          	   300: 	ld		DE,10
01:8273 ED52            	   301: 	sbc		HL,DE					; Substract 10
01:8275 30F7            	   302: 	jr		nc,Hex2Dec10Loop		; Continue if not reached negative
01:8277 19              	   303: 	add		HL,DE					; Add 10 back to make it positive
01:8278 FE00            	   304: 	cp		0
01:827A 2004            	   305: 	jr		nz,Hex2Dec10Set
01:827C CB40            	   306: 	bit		0,B						; Check the flag
01:827E 2809            	   307: 	jr		z,Hex2Dec1				; If it's not set
                        	   308: Hex2Dec10Set
01:8280 CBC0            	   309: 	set		0,B						
01:8282 C630            	   310: 	add		$30
01:8284 DD7700          	   311: 	ld		(IX),A
01:8287 DD23            	   312: 	inc		IX
                        	   313: 
                        	   314: 	; STORE THE 1's
                        	   315: Hex2Dec1:
01:8289 7D              	   316: 	ld		A,L
01:828A C630            	   317: 	add		$30
01:828C DD7700          	   318: 	ld		(IX),A
01:828F DD23            	   319: 	inc		IX
01:8291 3E00            	   320: 	ld		A,0
01:8293 DD7700          	   321: 	ld		(IX),A					; End string with null character
                        	   322: 	
                        	   323: Hex2DecEnd:
01:8296 2192B0          	   324: 	ld		HL,DigitString			; Point to decimal string to output
                        	   325: 	
01:8299 DDE1            	   326: 	pop		IX
01:829B D1              	   327: 	pop		DE
01:829C C1              	   328: 	pop		BC
01:829D F1              	   329: 	pop		AF
01:829E C9              	   330: 	ret
                        	   331: 
                        	   332: 
                        	   333: ;  _   _                                  ____                      
                        	   334: ; | | | |  _ __    _ __     ___   _ __   / ___|   __ _   ___    ___ 
                        	   335: ; | | | | | '_ \  | '_ \   / _ \ | '__| | |      / _` | / __|  / _ \
                        	   336: ; | |_| | | |_) | | |_) | |  __/ | |    | |___  | (_| | \__ \ |  __/
                        	   337: ;  \___/  | .__/  | .__/   \___| |_|     \____|  \__,_| |___/  \___|
                        	   338: ;         |_|     |_|                                               
                        	   339: ;
                        	   340: ; *********************************************************************************************************************
                        	   341: ; Converts a character to uppercase
                        	   342: ;	- INPUT:	A = Character to uppercase
                        	   343: ;	- OUTPUT:	A = Uppercased character
                        	   344: ; *********************************************************************************************************************
                        	   345: 
                        	   346: UpperCase:
01:829F FE61            	   347: 	cp		"a"						; Is the value less then lowercase a?
01:82A1 3806            	   348: 	jr		c,UpperCaseEnd			; If so, then end routine
01:82A3 FE7B            	   349: 	cp		"z"+1					; Is the value more then lowercase z?
01:82A5 3002            	   350: 	jr		nc,UpperCaseEnd			; If so, then end routine
01:82A7 D620            	   351: 	sub		32						; Substract the ASCII difference
                        	   352: UpperCaseEnd:
01:82A9 C9              	   353: 	ret
                        	   354: 	

Source: "main.asm"
                        	   271: 	.include	"monitor.asm"		; Monitor command subroutines

Source: "monitor.asm"
                        	     1: ; Command routines in this include file:
                        	     2: ; --------------------------------------
                        	     3: ;	- ClearScreen					; {}
                        	     4: ;	- Diagnostics					; {}
                        	     5: ;	- Fill							; {SSSS EEEE BB}
                        	     6: ;	- HexDump 						; {AAAA LL}
                        	     7: ;	- IntelHex  					; {}
                        	     8: ;	- List  						; {}
                        	     9: ;	- Peek							; [AAAA]
                        	    10: ;	- Poke							; AAAA BB
                        	    11: ;	- Registers  					; {}
                        	    12: ;	- Run  							; {AAAA}
                        	    13: ;	- SetAddress					; [AAAA]
                        	    14: ;	- SetBank						; [N]
                        	    15: ;	- SysInfo 						; {}
                        	    16: ;	- Write							; AAAA BB [BB] [BB] [BB] [BB] [BB]
                        	    17: ;	- Zero							; {}
                        	    18: 
                        	    19: 
                        	    20: ;   ____   _                         ____                                      
                        	    21: ;  / ___| | |   ___    __ _   _ __  / ___|    ___   _ __    ___    ___   _ __  
                        	    22: ; | |     | |  / _ \  / _` | | '__| \___ \   / __| | '__|  / _ \  / _ \ | '_ \ 
                        	    23: ; | |___  | | |  __/ | (_| | | |     ___) | | (__  | |    |  __/ |  __/ | | | |
                        	    24: ;  \____| |_|  \___|  \__,_| |_|    |____/   \___| |_|     \___|  \___| |_| |_|
                        	    25: ;
                        	    26: 
                        	    27: ; *********************************************************************************************************************
                        	    28: ; ClearScreen: Clears the VT terminal screen
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: ClearScreen:
01:82AA E5              	    32: 	push	HL
01:82AB 218DAB          	    33: 	ld		HL,ClearScreenSeq
01:82AE CDAE80          	    34: 	call	PrintString
01:82B1 E1              	    35: 	pop		HL
01:82B2 C9              	    36: 	ret
                        	    37: 
                        	    38: 
                        	    39: ;   ____                           ____    _                  _    
                        	    40: ;  / ___|   ___    _ __    _   _  | __ )  | |   ___     ___  | | __
                        	    41: ; | |      / _ \  | '_ \  | | | | |  _ \  | |  / _ \   / __| | |/ /
                        	    42: ; | |___  | (_) | | |_) | | |_| | | |_) | | | | (_) | | (__  |   < 
                        	    43: ;  \____|  \___/  | .__/   \__, | |____/  |_|  \___/   \___| |_|\_\
                        	    44: ;                 |_|      |___/
                        	    45: ;
                        	    46: ; *********************************************************************************************************************
                        	    47: ; Copy data from source to destination
                        	    48: ; - Input:	HL = Source address
                        	    49: ;			DE = Destination address
                        	    50: ;			BC = Number of bytes to move
                        	    51: ; *********************************************************************************************************************
                        	    52: 
                        	    53: CopyBlock:
01:82B3 F5              	    54: 	push	AF
01:82B4 C5              	    55: 	push	BC
01:82B5 D5              	    56: 	push	DE
01:82B6 E5              	    57: 	push	HL
                        	    58: 
01:82B7 2A8CB0          	    59: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	    60: 	
                        	    61: CopySourceAddress:
01:82BA CDC988          	    62: 	call	GetHexParameter			; Get the first parameter, start address
01:82BD D21383          	    63: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82C0 FE00            	    64: 	cp		0						; Is there a first parameter?
01:82C2 2847            	    65: 	jr		z,CopyNoParameter		; No, then print error message
01:82C4 ED43ABB0        	    66: 	ld		(StartAddress),BC		; Save source address
                        	    67: 
                        	    68: CopyDestinationAddress:
01:82C8 CDC988          	    69: 	call	GetHexParameter			; Get the first parameter, start address
01:82CB D21383          	    70: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82CE FE00            	    71: 	cp		0						; Is there a first parameter?
01:82D0 2839            	    72: 	jr		z,CopyNoParameter		; No, then print error message
01:82D2 ED43ADB0        	    73: 	ld		(EndAddress),BC			; Save destination address
                        	    74: 
                        	    75: CopyNumberOfBytes:
01:82D6 CDC988          	    76: 	call	GetHexParameter			; Get the first parameter, start address
01:82D9 D21383          	    77: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82DC FE00            	    78: 	cp		0						; Is there a first parameter?
01:82DE 282B            	    79: 	jr		z,CopyNoParameter		; No, then print error message
                        	    80: 
                        	    81: 	; Check if the number of bytes is zero
01:82E0 78              	    82: 	ld		A,B
01:82E1 B1              	    83: 	or		C
01:82E2 282C            	    84: 	jr		z,CopyNothing
                        	    85: 
01:82E4 2AABB0          	    86: 	ld		HL,(StartAddress)		; Restore HL
                        	    87: 	
                        	    88: 	; Does destination area overlap source area?
01:82E7 ED5BABB0        	    89: 	ld		DE,(StartAddress)
01:82EB 2AADB0          	    90: 	ld		HL,(EndAddress)
01:82EE B7              	    91: 	or		A						; Clear carry
01:82EF ED52            	    92: 	sbc		HL,DE
01:82F1 B7              	    93: 	or		A						; Clear carry
01:82F2 ED42            	    94: 	sbc		HL,BC
01:82F4 2AABB0          	    95: 	ld		HL,(StartAddress)
01:82F7 ED5BADB0        	    96: 	ld		DE,(EndAddress)
01:82FB 300A            	    97: 	jr		nc,CopyNoOverlap
                        	    98: 	
                        	    99: 	; Destination overlaps, copy from highest address to avoid destroying data
01:82FD 09              	   100: 	add		HL,BC
01:82FE 2B              	   101: 	dec		HL
01:82FF EB              	   102: 	ex		DE,HL
01:8300 09              	   103: 	add		HL,BC
01:8301 2B              	   104: 	dec		HL
01:8302 EB              	   105: 	ex		DE,HL
01:8303 EDB8            	   106: 	lddr
01:8305 180C            	   107: 	jr		CopyEnd
                        	   108: 
                        	   109: CopyNoOverlap:
01:8307 EDB0            	   110: 	ldir
01:8309 1808            	   111: 	jr		CopyEnd
                        	   112: 
                        	   113: CopyNoParameter:
01:830B CD26B0          	   114: 	call	NoParameter
01:830E 1803            	   115: 	jr		CopyEnd
                        	   116: 
                        	   117: CopyNothing:
01:8310 CD5FB0          	   118: 	call	NothingToCopy
                        	   119: 
                        	   120: CopyEnd:	
01:8313 E1              	   121: 	pop		HL
01:8314 D1              	   122: 	pop		DE
01:8315 C1              	   123: 	pop		BC
01:8316 F1              	   124: 	pop		AF
01:8317 C9              	   125: 	ret
                        	   126: 
                        	   127: 
                        	   128: ;  ____    _                                         _     _              
                        	   129: ; |  _ \  (_)   __ _    __ _   _ __     ___    ___  | |_  (_)   ___   ___ 
                        	   130: ; | | | | | |  / _` |  / _` | | '_ \   / _ \  / __| | __| | |  / __| / __|
                        	   131: ; | |_| | | | | (_| | | (_| | | | | | | (_) | \__ \ | |_  | | | (__  \__ \
                        	   132: ; |____/  |_|  \__,_|  \__, | |_| |_|  \___/  |___/  \__| |_|  \___| |___/
                        	   133: ;                      |___/                                              
                        	   134: ;
                        	   135: ;
                        	   136: ; *********************************************************************************************************************
                        	   137: ; Test system RAM, except the range of this routine
                        	   138: ; *********************************************************************************************************************
                        	   139: 
                        	   140: Diagnostics:
01:8318 F5              	   141: 	push	AF
01:8319 C5              	   142: 	push	BC
01:831A D5              	   143: 	push	DE
01:831B E5              	   144: 	push	HL
01:831C DDE5            	   145: 	push	IX
01:831E FDE5            	   146: 	push	IY
                        	   147: 	
                        	   148: ; TEST BANK MEMORY
                        	   149: ; ----------------
01:8320 3E00            	   150: 	ld		A,0						; Set Bank number to 0
01:8322 FD210000        	   151: 	ld		IY,0
                        	   152: DiagnosticsBankLoop:
01:8326 2111AE          	   153: 	ld		HL,TestingBankNumberMsg
01:8329 CDAE80          	   154: 	call	PrintString
01:832C CD9E80          	   155: 	call	PrintNibble
01:832F CD7F80          	   156: 	call	PrintCRLF
01:8332 DD210000        	   157: 	ld		IX,$0000				; Set start address
01:8336 21FF7F          	   158: 	ld		HL,$7FFF				; Set end address
01:8339 D330            	   159: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:833B CD6183          	   160: 	call	DiagnosticsTest
01:833E 3C              	   161: 	inc		A
01:833F FD6F            	   162: 	ld		IYL,A					; Save the bank number for error printing
01:8341 FE0F            	   163: 	cp		$F
01:8343 20E1            	   164: 	jr		nz,DiagnosticsBankLoop
                        	   165: 
                        	   166: ; TEST HIGH MEMORY (BETWEEN START OF BIOS AND START OF DIAG CODE)
                        	   167: ; ---------------------------------------------------------------
01:8345 2124AE          	   168: 	ld		HL,TestingHighRamMsg
01:8348 CDAE80          	   169: 	call	PrintString
01:834B DD210080        	   170: 	ld		IX,$8000				; Set start address
01:834F 216183          	   171: 	ld		HL,DiagnosticsTest		; Set end address
01:8352 CD6183          	   172: 	call	DiagnosticsTest
                        	   173: 
                        	   174: ; TEST HIGH MEMORY (AFTER DIAG CODE TILL THE END)
                        	   175: ; -----------------------------------------------
01:8355 DD21CF83        	   176: 	ld		IX,DiagnosticsEnd		; Set start address
01:8359 21FFFF          	   177: 	ld		HL,$FFFF				; Set end address
01:835C CD6183          	   178: 	call	DiagnosticsTest
                        	   179: 
01:835F 186E            	   180: 	jr		DiagnosticsEnd
                        	   181: 
                        	   182: ; ACTUAL MEMORY TEST SUBROUTINE WITHN THE SUBROUTINE
                        	   183: ; --------------------------------------------------
                        	   184: DiagnosticsTest:	
01:8361 F5              	   185: 	push	AF
                        	   186: 	
01:8362 DD2B            	   187: 	dec		IX						; Start with one less, since the increment starts at the start of the loop
                        	   188: DiagnosticsTestLoop:
01:8364 DD23            	   189: 	inc		IX						; Increment address pointer
01:8366 DD4600          	   190: 	ld		B,(IX)					; Save the original byte in B
                        	   191: 	
                        	   192: 	; Write pattern 55
01:8369 3E55            	   193: 	ld		A,$55					; Use $55 as the first pattern value
01:836B DD7700          	   194: 	ld		(IX),A					; Write it to the memory location
01:836E 4F              	   195: 	ld		C,A						; Save expected byte for error messages
01:836F DD7E00          	   196: 	ld		A,(IX)					; Read from same memory location
01:8372 FE55            	   197: 	cp		$55						; Compare if the it's the same
01:8374 C49583          	   198: 	call	nz,DiagMemoryError
                        	   199: 
                        	   200: 	; Write pattern AA
01:8377 3EAA            	   201: 	ld		A,$AA					; Use $55 as the first pattern value
01:8379 DD7700          	   202: 	ld		(IX),A					; Write it to the memory location
01:837C 4F              	   203: 	ld		C,A						; Save expected byte for error messages
01:837D DD7E00          	   204: 	ld		A,(IX)					; Read from same memory location
01:8380 FEAA            	   205: 	cp		$AA						; Compare if the it's the same
01:8382 C49583          	   206: 	call	nz,DiagMemoryError
                        	   207: 
01:8385 DD7000          	   208: 	ld		(IX),B					; Attempt to save the original value back in it's original place
                        	   209: 	
                        	   210: 	; Check for end of range
01:8388 DDE5            	   211: 	push	IX
01:838A D1              	   212: 	pop		DE
01:838B B7              	   213: 	or		A						; Clear carry flag
01:838C E5              	   214: 	push	HL
01:838D ED52            	   215: 	sbc		HL,DE					; HL = HL - DE
01:838F E1              	   216: 	pop		HL
01:8390 C26483          	   217: 	jp		nz,DiagnosticsTestLoop	; If reached the end of range, exit
                        	   218: 
01:8393 F1              	   219: 	pop		AF
01:8394 C9              	   220: 	ret
                        	   221: 
                        	   222: ; PRINT ERROR MESSAGE IF MEMORY IS BAD
                        	   223: ; ------------------------------------
                        	   224: DiagMemoryError:
01:8395 F5              	   225: 	push	AF
01:8396 E5              	   226: 	push	HL
                        	   227: 
                        	   228: 	; Print "Error at"
01:8397 21E2AD          	   229: 	ld		HL,BadMemory1Err
01:839A CDAE80          	   230: 	call	PrintString
                        	   231: 	
                        	   232: 	; Print bank number it it's in low memory
01:839D F5              	   233: 	push	AF
01:839E FD7D            	   234: 	ld		A,IYL
01:83A0 FE0F            	   235: 	cp		$0F
01:83A2 3008            	   236: 	jr		nc,DiagMemoryAddr
01:83A4 CD9E80          	   237: 	call	PrintNibble
01:83A7 3E3A            	   238: 	ld		A,":"
01:83A9 CD7480          	   239: 	call	PrintChar
                        	   240: 	
                        	   241: 	; Print address of error
                        	   242: DiagMemoryAddr
01:83AC F1              	   243: 	pop		AF
01:83AD DDE5            	   244: 	push	IX
01:83AF E1              	   245: 	pop		HL
01:83B0 CDBC80          	   246: 	call	PrintWord
                        	   247: 	
                        	   248: 	; Print "got"
01:83B3 21ECAD          	   249: 	ld		HL,BadMemory2Err
01:83B6 CDAE80          	   250: 	call	PrintString
                        	   251: 	
                        	   252: 	; Print the read back data
01:83B9 F5              	   253: 	push	AF
01:83BA 78              	   254: 	ld		A,B
01:83BB CD6180          	   255: 	call	PrintByte
01:83BE F1              	   256: 	pop		AF
                        	   257: 	
                        	   258: 	; Print "expected"
01:83BF CDAE80          	   259: 	call	PrintString
                        	   260: 	
                        	   261: 	; Print the pattern that was written
01:83C2 79              	   262: 	ld		A,C
01:83C3 CD6180          	   263: 	call	PrintByte
01:83C6 CD7F80          	   264: 	call	PrintCRLF
                        	   265: 	
01:83C9 FD2601          	   266: 	ld		IYH,1					; Indicate an error has occured
01:83CC E1              	   267: 	pop		HL
01:83CD F1              	   268: 	pop		AF
01:83CE C9              	   269: 	ret
                        	   270: 
                        	   271: DiagnosticsEnd:
01:83CF 3E00            	   272: 	ld		A,$0
01:83D1 D330            	   273: 	out		(BankSelect),A			; Sets bank number to 0
                        	   274: 	
01:83D3 FD7C            	   275: 	ld		A,IYH
01:83D5 FE01            	   276: 	cp		1
01:83D7 2806            	   277: 	jr		z,DiagnosticsEnd2		; If memory test failed, exit, as there was warning errors
01:83D9 2137AE          	   278: 	ld		HL,MemoryTestPassedMsg	; Else print test passed
01:83DC CDAE80          	   279: 	call	PrintString
                        	   280: 
                        	   281: DiagnosticsEnd2:
01:83DF FDE1            	   282: 	pop		IY
01:83E1 DDE1            	   283: 	pop		IX
01:83E3 E1              	   284: 	pop		HL
01:83E4 D1              	   285: 	pop		DE
01:83E5 C1              	   286: 	pop		BC
01:83E6 F1              	   287: 	pop		AF
01:83E7 C9              	   288: 	ret
                        	   289: 
                        	   290: 
                        	   291: ;  _____   _   _   _   __  __                                           
                        	   292: ; |  ___| (_) | | | | |  \/  |   ___   _ __ ___     ___    _ __   _   _ 
                        	   293: ; | |_    | | | | | | | |\/| |  / _ \ | '_ ` _ \   / _ \  | '__| | | | |
                        	   294: ; |  _|   | | | | | | | |  | | |  __/ | | | | | | | (_) | | |    | |_| |
                        	   295: ; |_|     |_| |_| |_| |_|  |_|  \___| |_| |_| |_|  \___/  |_|     \__, |
                        	   296: ;                                                                 |___/ 
                        	   297: 
                        	   298: ; *********************************************************************************************************************
                        	   299: ; Fill a memory address range with a byte. Does not fill all banks, only the current one. It will exclude
                        	   300: ; shadow ROM (otherwise it will corrupt the BIOS), as well as vector pages.
                        	   301: ;		- Parameter 1 = Start address
                        	   302: ;		- Parameter 2 = End address
                        	   303: ;		- Parameter 3 = The byte to write
                        	   304: ; *********************************************************************************************************************
                        	   305: ; 	Wishlist:
                        	   306: ;		- Verify after write
                        	   307: ;		- Add: Filled xxxx bytes in decimal
                        	   308: 
                        	   309: FillMemory:
01:83E8 F5              	   310: 	push	AF
01:83E9 C5              	   311: 	push	BC
01:83EA D5              	   312: 	push	DE
01:83EB E5              	   313: 	push	HL
                        	   314: 	
01:83EC 2A8CB0          	   315: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   316: 	
                        	   317: ; GET ALL THE PARAMETERS AND STORE THEM IN MEMORY
                        	   318: FillStartAddr:
01:83EF CDC988          	   319: 	call	GetHexParameter			; Get the first parameter, start address
01:83F2 D28284          	   320: 	jp		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:83F5 FE00            	   321: 	cp		0						; Is there a first parameter?
01:83F7 287D            	   322: 	jr		z,FillNoParameter		; No, then print error message
01:83F9 FE0F            	   323: 	cp		HELP
01:83FB 287F            	   324: 	jr		z,FillPrintHelp
01:83FD ED43ABB0        	   325: 	ld		(StartAddress),BC		; Store start address
01:8401 ED43AFB0        	   326: 	ld		(StartAddressAlt),BC	; Store start address
                        	   327: 	
                        	   328: FillEndAddr:
01:8405 CDC988          	   329: 	call	GetHexParameter			; Get the second parameter, end address
01:8408 3078            	   330: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:840A FE00            	   331: 	cp		0						; Is there a second parameter?
01:840C 2868            	   332: 	jr		z,FillNoParameter		; No, then print error message
01:840E ED43ADB0        	   333: 	ld		(EndAddress),BC			; Store end address
                        	   334: 
                        	   335: FillByte:
01:8412 CDC988          	   336: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8415 306B            	   337: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:8417 FE00            	   338: 	cp		0						; Is there a third parameter?
01:8419 285B            	   339: 	jr		z,FillNoParameter		; No, then print error message
01:841B 79              	   340: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:841C 32B3B0          	   341: 	ld		(ByteTransfer),A		; Store the byte to write
                        	   342: 	
01:841F CDD489          	   343: 	call	RangeValidation			; Check if Fill can write to a valid range of RAM space (excluse BIOS and Vectors)
01:8422 385E            	   344: 	jr		c,FillMemoryEnd
                        	   345: 	
                        	   346: FillRange1:
                        	   347: 	; Detect amout of bytes to copy in high range
01:8424 C5              	   348: 	push	BC
01:8425 CB49            	   349: 	bit		1,C
01:8427 2823            	   350: 	jr		z,FillRange2
01:8429 2AB1B0          	   351: 	ld		HL,(EndAddressAlt)		; Load end address
01:842C ED5BAFB0        	   352: 	ld		DE,(StartAddressAlt)	; Load start
01:8430 B7              	   353: 	or		A						; Clear carry flag
01:8431 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:8433 E5              	   355: 	push	HL						; Put result of byte count
01:8434 C1              	   356: 	pop		BC						; Into the byte count register
01:8435 2AAFB0          	   357: 	ld		HL,(StartAddressAlt)	; Set source address
01:8438 3AB3B0          	   358: 	ld		A,(ByteTransfer)		; Grab byte to write
01:843B 77              	   359: 	ld		(HL),A					; Save it at the source address
01:843C ED5BAFB0        	   360: 	ld		DE,(StartAddressAlt)	; Place destination address
01:8440 13              	   361: 	inc		DE						; Destination address +1
01:8441 EDB0            	   362: 	ldir
01:8443 ED4BAFB0        	   363: 	ld		BC,(StartAddressAlt)	; Set CurrentAddress to start of available RAM
01:8447 ED4390B0        	   364: 	ld		(CurrentAddress),BC
01:844B 37              	   365: 	scf								; Set carry
                        	   366: 
                        	   367: FillRange2:
                        	   368: 	; Detect amout of bytes to copy in low range
01:844C C1              	   369: 	pop		BC
01:844D CB41            	   370: 	bit		0,C
01:844F 2831            	   371: 	jr		z,FillMemoryEnd
01:8451 2AADB0          	   372: 	ld		HL,(EndAddress)			; Load end address
01:8454 ED5BABB0        	   373: 	ld		DE,(StartAddress)		; Load start
01:8458 B7              	   374: 	or		A						; Clear carry flag
01:8459 ED52            	   375: 	sbc		HL,DE					; HL = HL - DE
01:845B E5              	   376: 	push	HL						; Put result of byte count
01:845C C1              	   377: 	pop		BC						; Into the byte count register
01:845D 2AABB0          	   378: 	ld		HL,(StartAddress)		; Set source address
01:8460 3AB3B0          	   379: 	ld		A,(ByteTransfer)		; Grab byte to write
01:8463 77              	   380: 	ld		(HL),A					; Save it at the source address
01:8464 ED5BABB0        	   381: 	ld		DE,(StartAddress)		; Place destination address
01:8468 13              	   382: 	inc		DE						; Destination address +1
01:8469 EDB0            	   383: 	ldir
01:846B ED4BABB0        	   384: 	ld		BC,(StartAddress)		; Set CurrentAddress to start of available RAM
01:846F ED4390B0        	   385: 	ld		(CurrentAddress),BC
01:8473 37              	   386: 	scf								; Set Carry, indicates no error to calling program
01:8474 180C            	   387: 	jr		FillMemoryEnd
                        	   388: 
                        	   389: FillNoParameter:
01:8476 CD26B0          	   390: 	call	NoParameter
01:8479 B7              	   391: 	or		A						; Clear Carry, indicates error to calling program
01:847A 1806            	   392: 	jr		FillMemoryEnd
                        	   393: 
                        	   394: FillPrintHelp:
01:847C 21E6AE          	   395: 	ld		HL,FillHelp
01:847F CDAE80          	   396: 	call	PrintString
                        	   397: 
                        	   398: FillMemoryEnd:
01:8482 E1              	   399: 	pop		HL
01:8483 D1              	   400: 	pop		DE
01:8484 C1              	   401: 	pop		BC
01:8485 F1              	   402: 	pop		AF
01:8486 C9              	   403: 	ret
                        	   404: 
                        	   405: 
                        	   406: ;  _   _                 ____                              
                        	   407: ; | | | |   ___  __  __ |  _ \   _   _   _ __ ___    _ __  
                        	   408: ; | |_| |  / _ \ \ \/ / | | | | | | | | | '_ ` _ \  | '_ \ 
                        	   409: ; |  _  | |  __/  >  <  | |_| | | |_| | | | | | | | | |_) |
                        	   410: ; |_| |_|  \___| /_/\_\ |____/   \__,_| |_| |_| |_| | .__/ 
                        	   411: ;                                                   |_|    
                        	   412: ;
                        	   413: ; *********************************************************************************************************************
                        	   414: ; Prints the content of memory to serial port A
                        	   415: ; Parameters:	[AAAA], [LL] (where AAAA is the address to start displaying, and LL is the number of lines to display)
                        	   416: ; *********************************************************************************************************************
                        	   417: ;
                        	   418: ; Registers and variables used:
                        	   419: ;	- B is the number of bytes/characters per line
                        	   420: ;	- C is the line counter per page
                        	   421: ;	- DE is the number of lines to print
                        	   422: ;	- HL is the address to display
                        	   423: 
                        	   424: ; Wish list:
                        	   425: ;	- End at $FFFF
                        	   426: ;	- When more then a page long, pause every page and wait for ENTER to continues, or ESC to quit
                        	   427: 
                        	   428: HexDump:
01:8487 F5              	   429: 	push	AF
01:8488 C5              	   430: 	push	BC
01:8489 D5              	   431: 	push	DE
01:848A E5              	   432: 	push	HL
                        	   433: 	
01:848B 2A8CB0          	   434: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:848E CDC988          	   435: 	call	GetHexParameter			; Get the first parameter: the address to display
01:8491 306B            	   436: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:8493 FE0F            	   437: 	cp		HELP
01:8495 2861            	   438: 	jr		z,HexDumpPrintHelp
01:8497 FE00            	   439: 	cp		0						; Is there a parameter?
01:8499 2004            	   440: 	jr		nz,HexLinesToRead		; If There's a parameter, go check second parameter
01:849B ED4B90B0        	   441: 	ld		BC,(CurrentAddress)		; Since it's no parameter, then place CurrentAddress as default address
                        	   442: 
                        	   443: HexLinesToRead:
01:849F C5              	   444: 	push	BC						; Save the first parameter's address...
01:84A0 D1              	   445: 	pop		DE						;    to be later recovered as HL
01:84A1 CDC988          	   446: 	call	GetHexParameter			; Get the secode parameter: the number of lines to display
01:84A4 3058            	   447: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:84A6 FE00            	   448: 	cp		0						; Is there a parameter?
01:84A8 2808            	   449: 	jr		z,HexDefaultLines		; There is no parameter, so go load the default line number
01:84AA FE01            	   450: 	cp		1						; Is it a one byte parameter
01:84AC 2806            	   451: 	jr		z,HexDisplayContent		; If it is, C already contains the number of lines, so start printing content
01:84AE 0EFF            	   452: 	ld		C,$FF					; Else, if it's a 2 byte or more parameter, set maximum lines to $FF
01:84B0 1802            	   453: 	jr		HexDisplayContent		; Start printing hex dump
                        	   454: HexDefaultLines:
01:84B2 0E15            	   455: 	ld		C,VertTextRes-3			; Get number of vertical lines
                        	   456: 
                        	   457: HexDisplayContent:
01:84B4 EB              	   458: 	ex		DE,HL					; Restore address from first parameter read
                        	   459: 	
                        	   460: ; PRINT ADDRESS AT BEGINNING
                        	   461: HexNextLine:
01:84B5 E5              	   462: 	push	HL						; Save HL for later use (character portion of memory dump)
01:84B6 CDBC80          	   463: 	call	PrintWord				; Print address
01:84B9 0608            	   464: 	ld		B,8						; Setup byte counter per line
01:84BB 3E3A            	   465: 	ld		A,":"
01:84BD CD7480          	   466: 	call	PrintChar				; Print colon
01:84C0 3E20            	   467: 	ld		A," "
01:84C2 CD7480          	   468: 	call	PrintChar				; Print space
                        	   469: 
                        	   470: ; PRINT EIGHT BYTES
                        	   471: HexNextByte:
01:84C5 7E              	   472: 	ld		A,(HL)
01:84C6 CD6180          	   473: 	call	PrintByte				; Print byte contained in address HL
01:84C9 3E20            	   474: 	ld		A," "
01:84CB CD7480          	   475: 	call	PrintChar				; Print space
01:84CE 23              	   476: 	inc		HL						; Increment HL for next byte
01:84CF 05              	   477: 	dec		B						; Decrement byte counter
01:84D0 20F3            	   478: 	jr		nz,HexNextByte			; If the 8 bytes have not all been printed, then loop again
                        	   479: 
                        	   480: ; PRINT EIGHT CHARACTERS
01:84D2 CD7480          	   481: 	call	PrintChar				; Print an extra space (to space out bytes from character printout)
01:84D5 0608            	   482: 	ld		B,8						; Reset the counter to count characters instead
01:84D7 E1              	   483: 	pop		HL						; Reset HL so we can print the characters instead of the bytes at the end of the line
                        	   484: HexNextChar:
01:84D8 7E              	   485: 	ld		A,(HL)
01:84D9 FE20            	   486: 	cp		$20						; Compare A with first displayable character
01:84DB 3806            	   487: 	jr		c,HexReplaceDot			; If it's lower, then replace with a period
01:84DD FE7F            	   488: 	cp		$7F						; Is it higher or equal to the DEL character?
01:84DF 3002            	   489: 	jr		nc,HexReplaceDot		; Then replace that with a period
01:84E1 1802            	   490: 	jr		HexPrintChar
                        	   491: HexReplaceDot:
01:84E3 3E2E            	   492: 	ld		A,"."					; No, then replace it with a period
                        	   493: HexPrintChar:
01:84E5 CD7480          	   494: 	call	PrintChar				; Print the character representation of the byte
01:84E8 23              	   495: 	inc		HL						; Increment HL for next character
01:84E9 05              	   496: 	dec		B						; Decrement character counter
01:84EA 20EC            	   497: 	jr		nz,HexNextChar			; If the 8 characters have not all been printed, then loop again
01:84EC CD7F80          	   498: 	call	PrintCRLF				; Change line
01:84EF 0D              	   499: 	dec		C						; 
01:84F0 C2B584          	   500: 	jp		nz,HexNextLine
01:84F3 2290B0          	   501: 	ld		(CurrentAddress),HL		; Save Current Address to where Hex left off
01:84F6 1806            	   502: 	jr		HexDumpEnd
                        	   503: 	
                        	   504: HexDumpPrintHelp:
01:84F8 2151AF          	   505: 	ld		HL,HexDumpHelp
01:84FB CDAE80          	   506: 	call	PrintString
                        	   507: 	
                        	   508: HexDumpEnd:
01:84FE E1              	   509: 	pop		HL
01:84FF D1              	   510: 	pop		DE
01:8500 C1              	   511: 	pop		BC
01:8501 F1              	   512: 	pop		AF
01:8502 C9              	   513: 	ret
                        	   514: 
                        	   515: 
                        	   516: ;  ___           _            _   _   _               
                        	   517: ; |_ _|  _ __   | |_    ___  | | | | | |   ___  __  __
                        	   518: ;  | |  | '_ \  | __|  / _ \ | | | |_| |  / _ \ \ \/ /
                        	   519: ;  | |  | | | | | |_  |  __/ | | |  _  | |  __/  >  < 
                        	   520: ; |___| |_| |_|  \__|  \___| |_| |_| |_|  \___| /_/\_\
                        	   521: ;
                        	   522: 
                        	   523: ; *********************************************************************************************************************
                        	   524: ; Transfer programs via Intel Hex (i8HEX) - Press ESC to exit
                        	   525: ; - Input:	Upload an i8Hex file from a terminal program on your computer (Transfer File)
                        	   526: ; - Output:	Sets (CurrentAddress) variable to the start address declared in the IntelHex file
                        	   527: 
                        	   528: ; File Format:	SBBAAAARRDDDDDDCC termintated by (CR) and/or (LF)
                        	   529: ;				:0300300002337A1E
                        	   530: ;					S = : is the start code
                        	   531: ;					BB = it the data byte count ($20 is the typical)
                        	   532: ;					AAAA = The 16-bit beginning memory address offset of the data
                        	   533: ;					RR = Record type, 00 = Data, 01 = End of File
                        	   534: ;					DD = Data
                        	   535: ;					CC = Checksum from BB to the last DD (Two's complement)
                        	   536: ; *********************************************************************************************************************
                        	   537: ;	- B = Byte couter
                        	   538: ;	- C = Checksum
                        	   539: ;	- D = Flags (Start address, Checksum error, Last record)
                        	   540: ;	- HL = Address offset pointer
                        	   541: 
                        	   542: StartAddr	= 0						; Start address flag bit
                        	   543: ChecksumErr	= 1						; Checksum error flag bit
                        	   544: LastRec		= 7						; Last record flag bit
                        	   545: 
                        	   546: IntelHex:
01:8503 F5              	   547: 	push	AF
01:8504 C5              	   548: 	push	BC
01:8505 D5              	   549: 	push	DE
01:8506 E5              	   550: 	push	HL
01:8507 DDE5            	   551: 	push	IX
                        	   552: 	
01:8509 CD378B          	   553: 	call	SkipSpaces
01:850C 7E              	   554: 	ld		A,(HL)					; Read a character form the CommandBuffer	
01:850D FE0F            	   555: 	cp		HELP
01:850F CAC685          	   556: 	jp		z,IntelHexPrintHelp
                        	   557: 
01:8512 217AAE          	   558: 	ld		HL,IntelHexLoadMsg		; Print load message, or ESC to exit
01:8515 CDAE80          	   559: 	call	PrintString				;
01:8518 1600            	   560: 	ld		D,0						; Clear the flags register
01:851A DD210000        	   561: 	ld		IX,0					; Clear byte counter
01:851E DD22B4B0        	   562: 	ld		(UserCodeSize),IX		; Clear user code byte counter
                        	   563: 	
                        	   564: ; *** START CODE
                        	   565: IntelHexStartCode:
01:8522 CDC780          	   566: 	call	ReadChar				; Read a character form the console
01:8525 FE1B            	   567: 	cp		ESC						; Did the user press ESCAPE?
01:8527 CAA885          	   568: 	jp		z,IntelHexAbort			; Yes, then exit
01:852A FE3A            	   569: 	cp		":"						; Is it the start code
01:852C 2802            	   570: 	jr		z,IntelHexByteCount		; Yes, then read byte count
01:852E 18F2            	   571: 	jr		IntelHexStartCode		; No, then read a new character until ":" is present
                        	   572: 	
                        	   573: ; *** BYTE COUNT
                        	   574: IntelHexByteCount:
01:8530 CDDB80          	   575: 	call	ReadByte				; Read the byte count
01:8533 47              	   576: 	ld		B,A						; Store byte counter in B
01:8534 4F              	   577: 	ld		C,A						; copy value of accumulator in checksum register
                        	   578: 
                        	   579: ; *** ADDRESS
                        	   580: IntelHexAddress:
01:8535 CDDB80          	   581: 	call	ReadByte				; Read the MSB characters and convert it to a byte
01:8538 67              	   582: 	ld		H,A						; Store the address's MSB
01:8539 81              	   583: 	add		C						; Add checksum
01:853A 4F              	   584: 	ld		C,A						; Store back result in checksum accumulator
01:853B CDDB80          	   585: 	call	ReadByte				; Read the LSB characters and convert it to a byte
01:853E 6F              	   586: 	ld		L,A						; Store the address's LSB
01:853F 81              	   587: 	add		C						; Add checksum
01:8540 4F              	   588: 	ld		C,A						; Store back result in checksum accumulator
01:8541 CB42            	   589: 	bit		StartAddr,D				; Check if it's the first time the address has been read...
01:8543 2005            	   590: 	jr		nz,IntelHexRecordType	;	If it's not the first line, then go get record type
01:8545 2290B0          	   591: 	ld		(CurrentAddress),HL		; Else store the starting address
01:8548 CBC2            	   592: 	set		StartAddr,D				; Set first line start address flag
                        	   593: ;	ld		E,1						; Set first pass flag
                        	   594: 
                        	   595: ; *** RECORD TYPE
                        	   596: IntelHexRecordType:
01:854A CDDB80          	   597: 	call	ReadByte				; Read the record type byte
01:854D F5              	   598: 	push	AF
01:854E 81              	   599: 	add		C						; Add checksum
01:854F 4F              	   600: 	ld		C,A						; Store back result in checksum accumulator
01:8550 F1              	   601: 	pop		AF
01:8551 FE00            	   602: 	cp		00						; Is it data?
01:8553 2808            	   603: 	jr		z,IntelHexData
01:8555 FE01            	   604: 	cp		01						; Is it the end of file record type
01:8557 2057            	   605: 	jr		nz,IntelHexUnsupported		
01:8559 CBFA            	   606: 	set		LastRec,D	
01:855B 180B            	   607: 	jr		IntelHexChecksum		; Get checksum
                        	   608: 
                        	   609: ; *** DATA
                        	   610: IntelHexData:
01:855D CDDB80          	   611: 	call	ReadByte				; Get data byte
01:8560 77              	   612: 	ld		(HL),A					; Store data byte in memory
01:8561 23              	   613: 	inc		HL						; Point to the next address
01:8562 DD23            	   614: 	inc		IX						; Count the total number of bytes
01:8564 81              	   615: 	add		C						; Add checksum
01:8565 4F              	   616: 	ld		C,A						; Store back result in checksum accumulator
01:8566 10F5            	   617: 	djnz	IntelHexData			; Decrement count, and go to next data if not finished
                        	   618: 
                        	   619: ; *** CHECKSUM
                        	   620: IntelHexChecksum:
01:8568 CDDB80          	   621: 	call	ReadByte				; Read the checksum for that record
01:856B ED44            	   622: 	neg								; Do a 2s compliment on A (saves instructions if I swapped C with A)
01:856D B9              	   623: 	cp		C						; Compare the transmited checksum with the calculated checksum
01:856E 2806            	   624: 	jr		z,IntelHexCheckOk		; Is it the same?
01:8570 3E78            	   625: 	ld		A,"x"					; Display an "x" if checksum do not match
01:8572 CBCA            	   626: 	set		ChecksumErr,D			; Indicate an error in checksum flag
01:8574 1802            	   627: 	jr		IntelHexPrintStatus		;
                        	   628: IntelHexCheckOk:
01:8576 3E2E            	   629: 	ld		A,"."					; Display a "." if checksum is a match
                        	   630: IntelHexPrintStatus:
01:8578 CD7480          	   631: 	call	PrintChar				; Print the checksum validity character
01:857B CB7A            	   632: 	bit		LastRec,D				; Check if it's the last record
01:857D CA2285          	   633: 	jp		z,IntelHexStartCode		; No, then continue reading more lines
01:8580 CDC780          	   634: 	call	ReadChar				; Flush CR
                        	   635: 
                        	   636: IntelHexPrintEndMsg:
01:8583 CD7F80          	   637: 	call	PrintCRLF
01:8586 215BAE          	   638: 	ld		HL,IntelHexFinishedMsg	; Print the end message
01:8589 CDAE80          	   639: 	call	PrintString
01:858C 216BAE          	   640: 	ld		HL,IntelHexSuccessMsg	; Point to "unsuccessful"
01:858F CB4A            	   641: 	bit		ChecksumErr,D			; Cneck if there was an error that was flagged
01:8591 2002            	   642: 	jr		nz,IntelHexPrintNotOk	; If the ChecksumErr flag was set, then print unsuccessful
01:8593 23              	   643: 	inc		HL						; Push pointer to letters..
01:8594 23              	   644: 	inc		HL						;   so it becomes "successful"
                        	   645: IntelHexPrintNotOk:
01:8595 CDAE80          	   646: 	call	PrintString				; Print the sucess level
01:8598 E5              	   647: 	push	HL
01:8599 DDE5            	   648: 	push	IX						; Copy byte counter
01:859B E1              	   649: 	pop		HL						; To HL to be printed
01:859C CD5880          	   650: 	call	PrintDec				; Print the decimal number
01:859F 21D2AE          	   651: 	ld		HL,DownloadedBytesMsg	; 
01:85A2 CDAE80          	   652: 	call	PrintString				; Print bytes loaded text
01:85A5 E1              	   653: 	pop		HL
01:85A6 1824            	   654: 	jr		IntelHexEnd				; And end load
                        	   655: 
                        	   656: IntelHexAbort:
01:85A8 21B7AE          	   657: 	ld		HL,IntelHexAbortedMsg	; Abort message
01:85AB CDAE80          	   658: 	call	PrintString				;
01:85AE 181C            	   659: 	jr		IntelHexEnd
                        	   660: 
                        	   661: IntelHexUnsupported:
01:85B0 2128AD          	   662: 	ld		HL,IntelHexUnsupportedErr	; Unsupported record type message
01:85B3 CDAE80          	   663: 	call	PrintString				;
01:85B6 CD6180          	   664: 	call	PrintByte				; Print the record number
01:85B9 CD7F80          	   665: 	call	PrintCRLF
01:85BC 180E            	   666: 	jr		IntelHexEnd
                        	   667: 
                        	   668: IntelHexParamError:
01:85BE 21EEAC          	   669: 	ld		HL,UnrecognizedParamErr
01:85C1 CDAE80          	   670: 	call	PrintString
01:85C4 1806            	   671: 	jr		IntelHexEnd
                        	   672: 
                        	   673: IntelHexPrintHelp:
01:85C6 21B6AF          	   674: 	ld		HL,IntelHexHelp
01:85C9 CDAE80          	   675: 	call	PrintString
                        	   676: 	
                        	   677: IntelHexEnd:
01:85CC DDE1            	   678: 	pop		IX
01:85CE E1              	   679: 	pop		HL
01:85CF D1              	   680: 	pop		DE
01:85D0 C1              	   681: 	pop		BC
01:85D1 F1              	   682: 	pop		AF
01:85D2 C9              	   683: 	ret
                        	   684: 
                        	   685: 
                        	   686: ;  _       _         _   
                        	   687: ; | |     (_)  ___  | |_ 
                        	   688: ; | |     | | / __| | __|
                        	   689: ; | |___  | | \__ \ | |_ 
                        	   690: ; |_____| |_| |___/  \__|
                        	   691: 
                        	   692: 
                        	   693: ; *********************************************************************************************************************
                        	   694: ; Prints a list of available commands
                        	   695: ; *********************************************************************************************************************
                        	   696: 
                        	   697: ListCmd:
01:85D3 E5              	   698: 	push	HL
01:85D4 2132A9          	   699: 	ld		HL,ListOfCommands
01:85D7 CDAE80          	   700: 	call	PrintString				; Print first line
01:85DA CD8C80          	   701: 	call	PrintLine				; Print a line
01:85DD CDAE80          	   702: 	call	PrintString				; Print the rest
01:85E0 E1              	   703: 	pop		HL
01:85E1 C9              	   704: 	ret
                        	   705: 
                        	   706: 
                        	   707: ;  ____                  _    
                        	   708: ; |  _ \    ___    ___  | | __
                        	   709: ; | |_) |  / _ \  / _ \ | |/ /
                        	   710: ; |  __/  |  __/ |  __/ |   < 
                        	   711: ; |_|      \___|  \___| |_|\_\
                        	   712: 
                        	   713: 
                        	   714: ; *********************************************************************************************************************
                        	   715: ; Read a byte of memory
                        	   716: ; *********************************************************************************************************************
                        	   717: 
                        	   718: PeekCmd:
01:85E2 F5              	   719: 	push	AF
01:85E3 C5              	   720: 	push	BC
01:85E4 E5              	   721: 	push	HL
                        	   722: 	
01:85E5 2A8CB0          	   723: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   724: 	
                        	   725: PeekAddress:
01:85E8 CDC988          	   726: 	call	GetHexParameter			; Get the first parameter, start address
01:85EB D20D86          	   727: 	jp		nc,PeekEnd				; Exit routine if there was an error in the parameter
01:85EE FE00            	   728: 	cp		0						; Is there a first parameter?
01:85F0 2802            	   729: 	jr		z,PeekDefault			; No, then print error message
01:85F2 1804            	   730: 	jr		PeekRead
                        	   731: 
                        	   732: PeekDefault
01:85F4 ED4B90B0        	   733: 	ld		BC,(CurrentAddress)
                        	   734: 
                        	   735: PeekRead:
01:85F8 C5              	   736: 	push	BC
01:85F9 E1              	   737: 	pop		HL
01:85FA CDBC80          	   738: 	call	PrintWord
01:85FD 3E3A            	   739: 	ld		A,":"
01:85FF CD7480          	   740: 	call	PrintChar
01:8602 0A              	   741: 	ld		A,(BC)
01:8603 CD6180          	   742: 	call	PrintByte
01:8606 CD7F80          	   743: 	call	PrintCRLF
01:8609 ED4390B0        	   744: 	ld		(CurrentAddress),BC
                        	   745: 
                        	   746: PeekEnd
01:860D E1              	   747: 	pop		HL
01:860E C1              	   748: 	pop		BC
01:860F F1              	   749: 	pop		AF
01:8610 C9              	   750: 	ret
                        	   751: 
                        	   752: 
                        	   753: ;  ____            _           
                        	   754: ; |  _ \    ___   | | __   ___ 
                        	   755: ; | |_) |  / _ \  | |/ /  / _ \
                        	   756: ; |  __/  | (_) | |   <  |  __/
                        	   757: ; |_|      \___/  |_|\_\  \___|
                        	   758: 
                        	   759: 
                        	   760: ; *********************************************************************************************************************
                        	   761: ; Write a byte to a specific memory address
                        	   762: ;	- Input:	Parameters: Address & Byte
                        	   763: ; *********************************************************************************************************************
                        	   764: 
                        	   765: PokeCmd:
01:8611 F5              	   766: 	push 	AF
01:8612 C5              	   767: 	push	BC
01:8613 E5              	   768: 	push	HL
                        	   769: 	
01:8614 2A8CB0          	   770: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   771: 	
                        	   772: PokeAddress:
01:8617 CDC988          	   773: 	call	GetHexParameter			; Get the first parameter, start address
01:861A D24A86          	   774: 	jp		nc,PokeEnd				; Exit routine if there was an error in the parameter
01:861D FE00            	   775: 	cp		0						; Is there a first parameter?
01:861F 2826            	   776: 	jr		z,PokeNoParameter		; No, then print error message
01:8621 ED43ABB0        	   777: 	ld		(StartAddress),BC		; Store start address
                        	   778: 	
                        	   779: PokeByte:
01:8625 CDC988          	   780: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8628 3020            	   781: 	jr		nc,PokeEnd				; Exit routine if there was an error in the parameter
01:862A FE00            	   782: 	cp		0						; Is there a third parameter?
01:862C 2819            	   783: 	jr		z,PokeNoParameter		; No, then print error message
01:862E 79              	   784: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
                        	   785: 
                        	   786: PokeWrite:
01:862F 2AABB0          	   787: 	ld		HL,(StartAddress)
01:8632 77              	   788: 	ld		(HL),A
01:8633 CDBC80          	   789: 	call	PrintWord
01:8636 3E3A            	   790: 	ld		A,":"
01:8638 CD7480          	   791: 	call	PrintChar
01:863B 79              	   792: 	ld		A,C
01:863C CD6180          	   793: 	call	PrintByte
01:863F CD7F80          	   794: 	call	PrintCRLF
01:8642 2290B0          	   795: 	ld		(CurrentAddress),HL
01:8645 1803            	   796: 	jr		PokeEnd
                        	   797: 
                        	   798: PokeNoParameter:
01:8647 CD26B0          	   799: 	call	NoParameter
                        	   800: 	
                        	   801: PokeEnd
01:864A E1              	   802: 	pop		HL
01:864B C1              	   803: 	pop		BC
01:864C F1              	   804: 	pop		AF
01:864D C9              	   805: 	ret
                        	   806: 
                        	   807: 
                        	   808: ;  ____                   _         _                       
                        	   809: ; |  _ \    ___    __ _  (_)  ___  | |_    ___   _ __   ___ 
                        	   810: ; | |_) |  / _ \  / _` | | | / __| | __|  / _ \ | '__| / __|
                        	   811: ; |  _ <  |  __/ | (_| | | | \__ \ | |_  |  __/ | |    \__ \
                        	   812: ; |_| \_\  \___|  \__, | |_| |___/  \__|  \___| |_|    |___/
                        	   813: ;                 |___/                                     
                        	   814: 
                        	   815: ; *********************************************************************************************************************
                        	   816: ; Prints the contents of the registers on the console
                        	   817: ; *********************************************************************************************************************
                        	   818: ;
                        	   819: ; Wish list:
                        	   820: ;	- Modify individual registers
                        	   821: 
                        	   822: Registers:
01:864E ED73A8B0        	   823: 	ld		(StackPtr),SP			; Save the stack pointer
01:8652 F5              	   824: 	push	AF
01:8653 C5              	   825: 	push	BC
01:8654 D5              	   826: 	push	DE
01:8655 E5              	   827: 	push	HL
01:8656 DDE5            	   828: 	push	IX
01:8658 FDE5            	   829: 	push	IY
                        	   830: 	
01:865A F5              	   831: 	push	AF						; Save the flags (to be restored in C later)
01:865B 329DB0          	   832: 	ld		(RegA),A				; Save A
01:865E ED439EB0        	   833: 	ld		(RegBC),BC				; Save BC
01:8662 ED53A0B0        	   834: 	ld		(RegDE),DE				; Save DE
01:8666 22A2B0          	   835: 	ld		(RegHL),HL				; Save HL
01:8669 DD22A4B0        	   836: 	ld		(RegIX),IX				; Save IX
01:866D FD22A6B0        	   837: 	ld		(RegIY),IY				; Save IY
01:8671 C1              	   838: 	pop		BC						; Restore AF in BC to get the flags
01:8672 79              	   839: 	ld		A,C
01:8673 32AAB0          	   840: 	ld		(FlagsReg),A			; Save the flags register
                        	   841: 	
                        	   842: 	; PRINT THE ACCUMULATOR
01:8676 3E41            	   843: 	ld		A,"A"
01:8678 CD7480          	   844: 	call	PrintChar
01:867B 3E3A            	   845: 	ld		A,":"
01:867D CD7480          	   846: 	call	PrintChar
01:8680 3A9DB0          	   847: 	ld		A,(RegA)
01:8683 CD6180          	   848: 	call	PrintByte
01:8686 3E20            	   849: 	ld		A," "
01:8688 CD7480          	   850: 	call	PrintChar
                        	   851: 
                        	   852: 	; PRINT BC REGISTER PAIR
01:868B 3E42            	   853: 	ld		A,"B"
01:868D CD7480          	   854: 	call	PrintChar
01:8690 3E43            	   855: 	ld		A,"C"
01:8692 CD7480          	   856: 	call	PrintChar
01:8695 3E3A            	   857: 	ld		A,":"
01:8697 CD7480          	   858: 	call	PrintChar
01:869A 2A9EB0          	   859: 	ld		HL,(RegBC)
01:869D CDBC80          	   860: 	call	PrintWord
01:86A0 3E20            	   861: 	ld		A," "
01:86A2 CD7480          	   862: 	call	PrintChar
                        	   863: 
                        	   864: 	; PRINT DE REGISTER PAIR
01:86A5 3E44            	   865: 	ld		A,"D"
01:86A7 CD7480          	   866: 	call	PrintChar
01:86AA 3E45            	   867: 	ld		A,"E"
01:86AC CD7480          	   868: 	call	PrintChar
01:86AF 3E3A            	   869: 	ld		A,":"
01:86B1 CD7480          	   870: 	call	PrintChar
01:86B4 2AA0B0          	   871: 	ld		HL,(RegDE)
01:86B7 CDBC80          	   872: 	call	PrintWord
01:86BA 3E20            	   873: 	ld		A," "
01:86BC CD7480          	   874: 	call	PrintChar
                        	   875: 
                        	   876: 	; PRINT HL REGISTER PAIR
01:86BF 3E48            	   877: 	ld		A,"H"
01:86C1 CD7480          	   878: 	call	PrintChar
01:86C4 3E4C            	   879: 	ld		A,"L"
01:86C6 CD7480          	   880: 	call	PrintChar
01:86C9 3E3A            	   881: 	ld		A,":"
01:86CB CD7480          	   882: 	call	PrintChar
01:86CE 2AA2B0          	   883: 	ld		HL,(RegHL)
01:86D1 CDBC80          	   884: 	call	PrintWord
01:86D4 CD7F80          	   885: 	call	PrintCRLF
                        	   886: 
                        	   887: 	; PRINT IX INDEX REGISTER
01:86D7 3E49            	   888: 	ld		A,"I"
01:86D9 CD7480          	   889: 	call	PrintChar
01:86DC 3E58            	   890: 	ld		A,"X"
01:86DE CD7480          	   891: 	call	PrintChar
01:86E1 3E3A            	   892: 	ld		A,":"
01:86E3 CD7480          	   893: 	call	PrintChar
01:86E6 2AA4B0          	   894: 	ld		HL,(RegIX)
01:86E9 CDBC80          	   895: 	call	PrintWord
01:86EC 3E20            	   896: 	ld		A," "
01:86EE CD7480          	   897: 	call	PrintChar
                        	   898: 
                        	   899: 	; PRINT IY INDEX REGISTER
01:86F1 3E49            	   900: 	ld		A,"I"
01:86F3 CD7480          	   901: 	call	PrintChar
01:86F6 3E59            	   902: 	ld		A,"Y"
01:86F8 CD7480          	   903: 	call	PrintChar
01:86FB 3E3A            	   904: 	ld		A,":"
01:86FD CD7480          	   905: 	call	PrintChar
01:8700 2AA6B0          	   906: 	ld		HL,(RegIY)
01:8703 CDBC80          	   907: 	call	PrintWord
01:8706 3E20            	   908: 	ld		A," "
01:8708 CD7480          	   909: 	call	PrintChar
                        	   910: 
                        	   911: 	; PRINT THE STACK POINTER
01:870B 3E53            	   912: 	ld		A,"S"
01:870D CD7480          	   913: 	call	PrintChar
01:8710 3E50            	   914: 	ld		A,"P"
01:8712 CD7480          	   915: 	call	PrintChar
01:8715 3E3A            	   916: 	ld		A,":"
01:8717 CD7480          	   917: 	call	PrintChar
01:871A 2AA8B0          	   918: 	ld		HL,(StackPtr)
01:871D 23              	   919: 	inc		HL						; Offset stack by 2 to compensate for...
01:871E 23              	   920: 	inc		HL						;	this routine's call
01:871F CDBC80          	   921: 	call	PrintWord
01:8722 3E20            	   922: 	ld		A," "
01:8724 CD7480          	   923: 	call	PrintChar
                        	   924: 
                        	   925: 	; PRINT THE FLAGS
01:8727 3E46            	   926: 	ld		A,"F"
01:8729 CD7480          	   927: 	call	PrintChar
01:872C 3E3A            	   928: 	ld		A,":"
01:872E CD7480          	   929: 	call	PrintChar
01:8731 2187AB          	   930: 	ld		HL,FlagBits
                        	   931: 
                        	   932: 	; Sign
01:8734 7E              	   933: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8735 CB79            	   934: 	bit		Sign,C					; Check to the associated bit is set or not
01:8737 2803            	   935: 	jr		z,FlagSignClear			; If it's Set, then print lower case
01:8739 CD9F82          	   936: 	call	UpperCase				; Else, print upper case
                        	   937: FlagSignClear:
01:873C CD7480          	   938: 	call	PrintChar				; Print the flag symbol
01:873F 23              	   939: 	inc		HL						; Point to the next symbol
                        	   940: 	
                        	   941: 	; Zero
01:8740 7E              	   942: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8741 CB71            	   943: 	bit		Zero,C					; Check to the associated bit is set or not
01:8743 2803            	   944: 	jr		z,FlagZeroClear			; If it's Set, then print lower case
01:8745 CD9F82          	   945: 	call	UpperCase				; Else, print upper case
                        	   946: FlagZeroClear:
01:8748 CD7480          	   947: 	call	PrintChar				; Print the flag symbol
01:874B 23              	   948: 	inc		HL						; Point to the next symbol
                        	   949: 	
                        	   950: 	; Half-Carry
01:874C 7E              	   951: 	ld		A,(HL)					; Load the lowercase flag symbol
01:874D CB61            	   952: 	bit		HalfCarry,C				; Check to the associated bit is set or not
01:874F 2803            	   953: 	jr		z,FlagHalfClear			; If it's Set, then print lower case
01:8751 CD9F82          	   954: 	call	UpperCase				; Else, print upper case
                        	   955: FlagHalfClear:
01:8754 CD7480          	   956: 	call	PrintChar				; Print the flag symbol
01:8757 23              	   957: 	inc		HL						; Point to the next symbol
                        	   958: 	
                        	   959: 	; Overflow/Parity
01:8758 7E              	   960: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8759 CB51            	   961: 	bit		Overflow,C				; Check to the associated bit is set or not
01:875B 2803            	   962: 	jr		z,FlagOverClear			; If it's Set, then print lower case
01:875D CD9F82          	   963: 	call	UpperCase				; Else, print upper case
                        	   964: FlagOverClear:
01:8760 CD7480          	   965: 	call	PrintChar				; Print the flag symbol
01:8763 23              	   966: 	inc		HL						; Point to the next symbol
                        	   967: 	
                        	   968: 	; Add/Substract
01:8764 7E              	   969: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8765 CB49            	   970: 	bit		Negative,C				; Check to the associated bit is set or not
01:8767 2803            	   971: 	jr		z,FlagNegativeClear		; If it's Set, then print lower case
01:8769 CD9F82          	   972: 	call	UpperCase				; Else, print upper case
                        	   973: FlagNegativeClear:
01:876C CD7480          	   974: 	call	PrintChar				; Print the flag symbol
01:876F 23              	   975: 	inc		HL						; Point to the next symbol
                        	   976: 	
                        	   977: 	; Carry
01:8770 7E              	   978: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8771 CB41            	   979: 	bit		Carry,C					; Check to the associated bit is set or not
01:8773 2803            	   980: 	jr		z,FlagCarryClear		; If it's Set, then print lower case
01:8775 CD9F82          	   981: 	call	UpperCase				; Else, print upper case
                        	   982: FlagCarryClear:
01:8778 CD7480          	   983: 	call	PrintChar				; Print the flag symbol
01:877B 23              	   984: 	inc		HL						; Point to the next symbol
                        	   985: 
01:877C CD7F80          	   986: 	call	PrintCRLF
                        	   987: 
01:877F FDE1            	   988: 	pop		IY
01:8781 DDE1            	   989: 	pop		IX
01:8783 E1              	   990: 	pop		HL
01:8784 D1              	   991: 	pop		DE
01:8785 C1              	   992: 	pop		BC
01:8786 F1              	   993: 	pop		AF
01:8787 C9              	   994: 	ret
                        	   995: 
                        	   996: 
                        	   997: ;  ____                  
                        	   998: ; |  _ \   _   _   _ __  
                        	   999: ; | |_) | | | | | | '_ \ 
                        	  1000: ; |  _ <  | |_| | | | | |
                        	  1001: ; |_| \_\  \__,_| |_| |_|
                        	  1002: 
                        	  1003: 
                        	  1004: ; *********************************************************************************************************************
                        	  1005: ; Executes code at a specific address, clearing the registers at the beginning
                        	  1006: ; Parameter:	[AAAA], where AAAA is an optional address to execute from. Defaults to CurrentAddress
                        	  1007: ; *********************************************************************************************************************
                        	  1008: 
                        	  1009: RunCode:
01:8788 2A8CB0          	  1010: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:878B CDC988          	  1011: 	call	GetHexParameter			; Get the parameter
01:878E 300A            	  1012: 	jr		nc,RunEnd				; If there's an error in getting the parameter, then exit
01:8790 FE00            	  1013: 	cp		0						; Is there a parameter?
01:8792 2004            	  1014: 	jr		nz,RunCallBC			; There's a valid parameter, then execute user code
01:8794 ED4B90B0        	  1015: 	ld		BC,(CurrentAddress)		; Load the CurrentAddress in BC
                        	  1016: 
                        	  1017: RunCallBC:
01:8798 C5              	  1018: 	push	BC						; Put execution address in the stack, see bellow "ret" acting as a "call (BC)"
01:8799 C9              	  1019: 	ret								; Above "push BC" without "pop", "ret" acts as an indirect "call (BC)"
                        	  1020: 
                        	  1021: RunEnd:
01:879A C9              	  1022: 	ret
                        	  1023: 
                        	  1024: 
                        	  1025: ;  ____           _        _          _       _                           
                        	  1026: ; / ___|    ___  | |_     / \      __| |   __| |  _ __    ___   ___   ___ 
                        	  1027: ; \___ \   / _ \ | __|   / _ \    / _` |  / _` | | '__|  / _ \ / __| / __|
                        	  1028: ;  ___) | |  __/ | |_   / ___ \  | (_| | | (_| | | |    |  __/ \__ \ \__ \
                        	  1029: ; |____/   \___|  \__| /_/   \_\  \__,_|  \__,_| |_|     \___| |___/ |___/
                        	  1030: 
                        	  1031: 
                        	  1032: ; *********************************************************************************************************************
                        	  1033: ; Set current address from the command prompt
                        	  1034: ;	- Input:	An optional address parameter, defaults to $0000
                        	  1035: ; *********************************************************************************************************************
                        	  1036: 
                        	  1037: SetAddress:
01:879B F5              	  1038: 	push	AF
01:879C C5              	  1039: 	push	BC
01:879D D5              	  1040: 	push	DE
01:879E E5              	  1041: 	push	HL
                        	  1042: 	
01:879F 2A8CB0          	  1043: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87A2 CDC988          	  1044: 	call	GetHexParameter			; Get a parameter
01:87A5 3010            	  1045: 	jr		nc,SetAddressEnd		; Exit routine if there was an error in the parameter
01:87A7 FE00            	  1046: 	cp		0						; Is there a parameter returned?
01:87A9 2806            	  1047: 	jr		z,SetAddressDefault		; If there is none, select default address
01:87AB ED4390B0        	  1048: 	ld		(CurrentAddress),BC		; Save address in parameter (BC or C) in CurrentAddress global variable
01:87AF 1806            	  1049: 	jr		SetAddressEnd
                        	  1050: 
                        	  1051: SetAddressDefault:
01:87B1 210000          	  1052: 	ld		HL,0					; Default address is $0000
01:87B4 2290B0          	  1053: 	ld		(CurrentAddress),HL		; Save it in CurrentAddress global variable
                        	  1054: 
                        	  1055: SetAddressEnd:
01:87B7 E1              	  1056: 	pop		HL
01:87B8 D1              	  1057: 	pop		DE
01:87B9 C1              	  1058: 	pop		BC
01:87BA F1              	  1059: 	pop		AF
                        	  1060: 	
01:87BB C9              	  1061: 	ret
                        	  1062: 	
                        	  1063: 
                        	  1064: ;  ____           _     ____                    _    
                        	  1065: ; / ___|    ___  | |_  | __ )    __ _   _ __   | | __
                        	  1066: ; \___ \   / _ \ | __| |  _ \   / _` | | '_ \  | |/ /
                        	  1067: ;  ___) | |  __/ | |_  | |_) | | (_| | | | | | |   < 
                        	  1068: ; |____/   \___|  \__| |____/   \__,_| |_| |_| |_|\_\
                        	  1069: 
                        	  1070: 
                        	  1071: ; *********************************************************************************************************************
                        	  1072: ; Set current bank from the command prompt
                        	  1073: ;	- Input:	An optional byte parameter, defaults to 0
                        	  1074: ; *********************************************************************************************************************
                        	  1075: ; Wishlist:
                        	  1076: ;	- Validation, only a nibble, and only 0-E
                        	  1077: ;	- Choice of BCD?
                        	  1078: 
                        	  1079: SetBank:
01:87BC F5              	  1080: 	push	AF
01:87BD C5              	  1081: 	push	BC
01:87BE D5              	  1082: 	push	DE
01:87BF E5              	  1083: 	push	HL
                        	  1084: 	
01:87C0 2A8CB0          	  1085: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87C3 CDC988          	  1086: 	call	GetHexParameter			; Get a parameter
01:87C6 3020            	  1087: 	jr		nc,SetBankEnd			; Exit routine if there was an error in the parameter
01:87C8 FE00            	  1088: 	cp		0						; Is there a parameter returned?
01:87CA 2810            	  1089: 	jr		z,SetBankDefault		; If there is none, select default bank
01:87CC FE02            	  1090: 	cp		2
01:87CE 2815            	  1091: 	jr		z,SetBankError
                        	  1092: 	
01:87D0 79              	  1093: 	ld		A,C
01:87D1 FE0F            	  1094: 	cp		$0F
01:87D3 3010            	  1095: 	jr		nc,SetBankError
01:87D5 328FB0          	  1096: 	ld		(CurrentBank),A			; Save nibble in parameter (C) in CurrentBank global variable
01:87D8 D330            	  1097: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87DA 180C            	  1098: 	jr		SetBankEnd
                        	  1099: 
                        	  1100: SetBankDefault:
01:87DC 3E00            	  1101: 	ld		A,0						; Default bank is 0
01:87DE 328FB0          	  1102: 	ld		(CurrentBank),A			; Save it in CurrentBank global variable
01:87E1 D330            	  1103: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87E3 1803            	  1104: 	jr		SetBankEnd
                        	  1105: 
                        	  1106: SetBankError:
01:87E5 CD32B0          	  1107: 	call	InvalidBank
                        	  1108: 	
                        	  1109: SetBankEnd:
01:87E8 E1              	  1110: 	pop		HL
01:87E9 D1              	  1111: 	pop		DE
01:87EA C1              	  1112: 	pop		BC
01:87EB F1              	  1113: 	pop		AF
                        	  1114: 	
01:87EC C9              	  1115: 	ret
                        	  1116: 	
                        	  1117: 	
                        	  1118: ;  ____                  ___            __         
                        	  1119: ; / ___|   _   _   ___  |_ _|  _ __    / _|   ___  
                        	  1120: ; \___ \  | | | | / __|  | |  | '_ \  | |_   / _ \ 
                        	  1121: ;  ___) | | |_| | \__ \  | |  | | | | |  _| | (_) |
                        	  1122: ; |____/   \__, | |___/ |___| |_| |_| |_|    \___/ 
                        	  1123: ;          |___/                                   
                        	  1124: 
                        	  1125: ; *********************************************************************************************************************
                        	  1126: ; Prints information about the ZedEighty (WiP)
                        	  1127: ; *********************************************************************************************************************
                        	  1128: 
                        	  1129: SysInfo:
01:87ED E5              	  1130: 	push	HL
01:87EE 219AAB          	  1131: 	ld		HL,SysInfoMsg			; Point the the text message
01:87F1 CDAE80          	  1132: 	call	PrintString				; Print first line
01:87F4 CD8C80          	  1133: 	call	PrintLine				; Print a line
01:87F7 CDAE80          	  1134: 	call	PrintString				; Print the rest
                        	  1135: 	
                        	  1136: 	; Speed in MHz
01:87FA CDAE80          	  1137: 	call	PrintString
                        	  1138: 	
                        	  1139: 	; Free RAM
01:87FD E5              	  1140: 	push	HL
01:87FE 21CACB          	  1141: 	ld		HL,BytesFree			; Load the amount of bytes free
01:8801 CD5880          	  1142: 	call	PrintDec				; Print decimal value
01:8804 E1              	  1143: 	pop		HL
01:8805 CDAE80          	  1144: 	call	PrintString
                        	  1145: 	
01:8808 E1              	  1146: 	pop		HL
01:8809 C9              	  1147: 	ret
                        	  1148: 
                        	  1149: 
                        	  1150: ; __        __         _   _          
                        	  1151: ; \ \      / /  _ __  (_) | |_    ___ 
                        	  1152: ;  \ \ /\ / /  | '__| | | | __|  / _ \
                        	  1153: ;   \ V  V /   | |    | | | |_  |  __/
                        	  1154: ;    \_/\_/    |_|    |_|  \__|  \___|
                        	  1155: ;
                        	  1156: ; *********************************************************************************************************************
                        	  1157: ; Write up to 8 bytes into memory
                        	  1158: ; *********************************************************************************************************************
                        	  1159: 
                        	  1160: Write:
01:880A F5              	  1161: 	push 	AF
01:880B C5              	  1162: 	push	BC
01:880C D5              	  1163: 	push	DE
01:880D E5              	  1164: 	push	HL
                        	  1165: 	
01:880E 2A8CB0          	  1166: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	  1167: 	
                        	  1168: WriteGetAddress:
01:8811 CDC988          	  1169: 	call	GetHexParameter			; Get the first parameter, start address
01:8814 D25588          	  1170: 	jp		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8817 FE00            	  1171: 	cp		0						; Is there a first parameter?
01:8819 2837            	  1172: 	jr		z,WriteNoParameter		; No, then print error message
01:881B C5              	  1173: 	push	BC						; Store start address that's in BC
01:881C D1              	  1174: 	pop		DE						; Into DE
                        	  1175: 
                        	  1176: WriteFirstByte:
01:881D CDC988          	  1177: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8820 3033            	  1178: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8822 FE00            	  1179: 	cp		0						; Is there a second parameter?
01:8824 282C            	  1180: 	jr		z,WriteNoParameter		; No, then print error message
01:8826 FE02            	  1181: 	cp		2						; Is it bigger then a byte?
01:8828 301D            	  1182: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:882A 79              	  1183: 	ld		A,C						; Transfer byte in A
01:882B 12              	  1184: 	ld		(DE),A					; Save the byte
01:882C 13              	  1185: 	inc		DE						; Point to the next location
01:882D ED5390B0        	  1186: 	ld		(CurrentAddress),DE		; Set CurrentAddress
                        	  1187: 
                        	  1188: WriteRemainingBytes:
01:8831 CDC988          	  1189: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8834 301F            	  1190: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8836 FE00            	  1191: 	cp		0						; Is there another parameter?
01:8838 281B            	  1192: 	jr		z,WriteEnd				; No, then exit
01:883A FE02            	  1193: 	cp		2						; Is it bigger then a byte?
01:883C 3009            	  1194: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:883E 79              	  1195: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:883F 12              	  1196: 	ld		(DE),A					; Save the byte
01:8840 13              	  1197: 	inc		DE						; Point to the next location
01:8841 ED5390B0        	  1198: 	ld		(CurrentAddress),DE		; Set CurrentAddress
01:8845 18EA            	  1199: 	jr		WriteRemainingBytes		; See if there are other bytes
                        	  1200: 
                        	  1201: WriteTooManyDigits:
01:8847 CDBF88          	  1202: 	call	DecErrorPointer			; Back up pointer one
01:884A CDBC89          	  1203: 	call	PrintErrorPointer		; Print's pointer to actual error in command line
01:884D CD3BB0          	  1204: 	call	TooManyDigits			; Print invalid number of digits message	
01:8850 1803            	  1205: 	jr		WriteEnd
                        	  1206: 	
                        	  1207: WriteNoParameter:
01:8852 CD26B0          	  1208: 	call	NoParameter
                        	  1209: 	
                        	  1210: WriteEnd:
01:8855 E1              	  1211: 	pop		HL
01:8856 D1              	  1212: 	pop		DE
01:8857 C1              	  1213: 	pop		BC
01:8858 F1              	  1214: 	pop		AF
01:8859 C9              	  1215: 	ret
                        	  1216: 
                        	  1217: 
                        	  1218: ;  _____                           _      _   _   ____                      
                        	  1219: ; |__  /   ___   _ __    ___      / \    | | | | |  _ \    __ _   _ __ ___  
                        	  1220: ;   / /   / _ \ | '__|  / _ \    / _ \   | | | | | |_) |  / _` | | '_ ` _ \ 
                        	  1221: ;  / /_  |  __/ | |    | (_) |  / ___ \  | | | | |  _ <  | (_| | | | | | | |
                        	  1222: ; /____|  \___| |_|     \___/  /_/   \_\ |_| |_| |_| \_\  \__,_| |_| |_| |_|
                        	  1223: 
                        	  1224: 
                        	  1225: ; *********************************************************************************************************************
                        	  1226: ; Zero all the RAM, including all the RAM. Excludes shadow ROM (otherwise it will corrupt the BIOS), as well as
                        	  1227: ; vector pages.
                        	  1228: ; *********************************************************************************************************************
                        	  1229: 
                        	  1230: ZeroAllRam:
01:885A F5              	  1231: 	push	AF
01:885B C5              	  1232: 	push	BC
01:885C D5              	  1233: 	push	DE
01:885D E5              	  1234: 	push	HL
                        	  1235: 	
01:885E 3E0E            	  1236: 	ld		A,$E
                        	  1237: ZeroLowRange:
01:8860 D330            	  1238: 	out		(BankSelect),A
01:8862 210080          	  1239: 	ld		HL,StartOfCode			; Load end address
01:8865 2B              	  1240: 	dec		HL
01:8866 118000          	  1241: 	ld		DE,InterruptVectorEnd	; Load start
01:8869 B7              	  1242: 	or		A						; Clear carry flag
01:886A ED52            	  1243: 	sbc		HL,DE					; HL = HL - DE
01:886C E5              	  1244: 	push	HL						; Put result of byte count
01:886D C1              	  1245: 	pop		BC						; Into the byte count register
01:886E 218000          	  1246: 	ld		HL,InterruptVectorEnd	; Set source address
01:8871 F5              	  1247: 	push	AF
01:8872 3E00            	  1248: 	ld		A,0						; Grab byte to write
01:8874 77              	  1249: 	ld		(HL),A					; Save it at the source address
01:8875 F1              	  1250: 	pop		AF
01:8876 118000          	  1251: 	ld		DE,InterruptVectorEnd	; Place destination address
01:8879 13              	  1252: 	inc		DE
01:887A EDB0            	  1253: 	ldir
01:887C 3D              	  1254: 	dec		A
01:887D FEFF            	  1255: 	cp		$FF
01:887F 20DF            	  1256: 	jr		nz,ZeroLowRange
                        	  1257: 
                        	  1258: ZeroHighRange:
01:8881 2100FD          	  1259: 	ld		HL,VectorTable			; Load end address
01:8884 2B              	  1260: 	dec		HL
01:8885 11B6B0          	  1261: 	ld		DE,EndOfCode			; Load start
01:8888 B7              	  1262: 	or		A						; Clear carry flag
01:8889 ED52            	  1263: 	sbc		HL,DE					; HL = HL - DE
01:888B E5              	  1264: 	push	HL						; Put result of byte count
01:888C C1              	  1265: 	pop		BC						; Into the byte count register
01:888D 21B6B0          	  1266: 	ld		HL,EndOfCode			; Set source address
01:8890 3E00            	  1267: 	ld		A,0						; Grab byte to write
01:8892 77              	  1268: 	ld		(HL),A					; Save it at the source address
01:8893 11B6B0          	  1269: 	ld		DE,EndOfCode			; Place destination address
01:8896 13              	  1270: 	inc		DE
01:8897 EDB0            	  1271: 	ldir
                        	  1272: 
01:8899 37              	  1273: 	scf								; Set Carry, indicates no error to calling program
                        	  1274: 
                        	  1275: ZeroEnd:
01:889A E1              	  1276: 	pop		HL
01:889B D1              	  1277: 	pop		DE
01:889C C1              	  1278: 	pop		BC
01:889D F1              	  1279: 	pop		AF
01:889E C9              	  1280: 	ret
                        	  1281: 
                        	  1282: 

Source: "main.asm"
                        	   272: 	.include	"ancillary.asm"		; Anscillary subroutines for monitor commands

Source: "ancillary.asm"
                        	     1: ; Ancillary monitor routines in this include file:
                        	     2: ; ------------------------------------------------
                        	     3: ;	- CommandPrompt					; {}
                        	     4: ;	- GetHexParameter				; [(HL) -> BC,A,(HL)]
                        	     5: ;	- Parse							; (HL)
                        	     6: ;	- SkipSpaces					; [HL -> HL]
                        	     7: 
                        	     8: 
                        	     9: ;   ____                                                       _   ____                                       _   
                        	    10: ;  / ___|   ___    _ __ ___    _ __ ___     __ _   _ __     __| | |  _ \   _ __    ___    _ __ ___    _ __   | |_ 
                        	    11: ; | |      / _ \  | '_ ` _ \  | '_ ` _ \   / _` | | '_ \   / _` | | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
                        	    12: ; | |___  | (_) | | | | | | | | | | | | | | (_| | | | | | | (_| | |  __/  | |    | (_) | | | | | | | | |_) | | |_ 
                        	    13: ;  \____|  \___/  |_| |_| |_| |_| |_| |_|  \__,_| |_| |_|  \__,_| |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
                        	    14: ;                                                                                                    |_|          
                        	    15: 
                        	    16: ; *********************************************************************************************************************
                        	    17: ; Prints the prompt to console
                        	    18: ; *********************************************************************************************************************
                        	    19: 
                        	    20: CommandPrompt:
01:889F F5              	    21: 	push	AF
01:88A0 E5              	    22: 	push	HL
01:88A1 3A8FB0          	    23: 	ld		A,(CurrentBank)			; Get Current Bank number
01:88A4 CD9E80          	    24: 	call	PrintNibble				; Print it
01:88A7 3E3A            	    25: 	ld		A,":"					; 
01:88A9 CD7480          	    26: 	call	PrintChar				; Print colon symbol
01:88AC 2A90B0          	    27: 	ld		HL,(CurrentAddress)
01:88AF CDBC80          	    28: 	call	PrintWord				; Print current address poointer
01:88B2 3E3E            	    29: 	ld		A,">"					; 
01:88B4 CD7480          	    30: 	call	PrintChar				; Print prompt symbol
01:88B7 3E20            	    31: 	ld		A," "					; 
01:88B9 CD7480          	    32: 	call	PrintChar				; Print a space
01:88BC E1              	    33: 	pop		HL
01:88BD F1              	    34: 	pop		AF
01:88BE C9              	    35: 	ret
                        	    36: 
                        	    37: 
                        	    38: ;  ____                  _____                                ____            _           _                 
                        	    39: ; |  _ \    ___    ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	    40: ; | | | |  / _ \  / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	    41: ; | |_| | |  __/ | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	    42: ; |____/   \___|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	    43: ;
                        	    44: ;
                        	    45: ; *********************************************************************************************************************
                        	    46: ; Decrement error pointer by one
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: DecErrorPointer:
01:88BF F5              	    50: 	push	AF
01:88C0 3A8EB0          	    51: 	ld		A,(CmdErrorPointer)
01:88C3 3D              	    52: 	dec		A
01:88C4 328EB0          	    53: 	ld		(CmdErrorPointer),A
01:88C7 F1              	    54: 	pop		AF
01:88C8 C9              	    55: 	ret
                        	    56: 
                        	    57: 
                        	    58: ;   ____          _     _   _                 ____                                              _                 
                        	    59: ;  / ___|   ___  | |_  | | | |   ___  __  __ |  _ \    __ _   _ __    __ _   _ __ ___     ___  | |_    ___   _ __ 
                        	    60: ; | |  _   / _ \ | __| | |_| |  / _ \ \ \/ / | |_) |  / _` | | '__|  / _` | | '_ ` _ \   / _ \ | __|  / _ \ | '__|
                        	    61: ; | |_| | |  __/ | |_  |  _  | |  __/  >  <  |  __/  | (_| | | |    | (_| | | | | | | | |  __/ | |_  |  __/ | |   
                        	    62: ;  \____|  \___|  \__| |_| |_|  \___| /_/\_\ |_|      \__,_| |_|     \__,_| |_| |_| |_|  \___|  \__|  \___| |_|   
                        	    63: ;
                        	    64: ;
                        	    65: ; *********************************************************************************************************************
                        	    66: ; Read a hexadecimal parameter from the CommandBuffer
                        	    67: ;	- Input:	HL = Buffer pointer of command buffer, points to parameter
                        	    68: ;	- Output:	BC = contains the converted Hex number (if it's a byte B is 0, C is the converted byte) 
                        	    69: ;				A = 0 is no parameter, 1 is a byte, 2 is a word
                        	    70: ;				HL = New position of pointer
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: GetHexParameter:
01:88C9 CD378B          	    75: 	call	SkipSpaces				; Skip any spaces if any
01:88CC E5              	    76: 	push	HL						; Save it, restoring it after character count
01:88CD 0E00            	    77: 	ld		C,$00					; Character count set to zero
                        	    78: 	
                        	    79: GetParamCount:
01:88CF 7E              	    80: 	ld		A,(HL)					; Read a character form the CommandBuffer
01:88D0 FE00            	    81: 	cp		0						; Is it the end of the CommandBuffer?
01:88D2 280C            	    82: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88D4 FE20            	    83: 	cp		DELIMITER				; If it's the delimiter for the next parameter
01:88D6 2808            	    84: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88D8 FE3F            	    85: 	cp		"?"
01:88DA 2852            	    86: 	jr		z,GetParamHelp
01:88DC 23              	    87: 	inc		HL						; Increment buffer pointer to next character in parameter
01:88DD 0C              	    88: 	inc		C						; Add one, to the count of characters
01:88DE 18EF            	    89: 	jr		GetParamCount			; Loop if delimiter has not been reached
                        	    90: 
                        	    91: GetParamFetch:
01:88E0 79              	    92: 	ld		A,C						; Load counted characters into accumulator
01:88E1 E1              	    93: 	pop		HL						; Restore pointer back to it's original position
01:88E2 010000          	    94: 	ld		BC,$0000				; Clear the results register to store a nibble, byte or nibble+byte
                        	    95: 
                        	    96: GetParamFetch0;
01:88E5 FE00            	    97: 	cp		0						; Was a parameter specified?
01:88E7 2004            	    98: 	jr		nz,GetParamFetch1		; No then check for 1 
01:88E9 3E00            	    99: 	ld		A,0						; Returns 0 to indicate no parameters
01:88EB 183F            	   100: 	jr		GetParameterEnd			; End routine
                        	   101: 	
                        	   102: GetParamFetch1:
01:88ED FE01            	   103: 	cp		1						; Was it only one digit?
01:88EF 200C            	   104: 	jr		nz,GetParamFetch2		; No then check for 2
01:88F1 7E              	   105: 	ld		A,(HL)
01:88F2 23              	   106: 	inc		HL
01:88F3 CD6981          	   107: 	call	Ascii2HexNibble			; Convert an ASCII char in HL to a 4-bit hex value
01:88F6 304A            	   108: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:88F8 4F              	   109: 	ld		C,A						; Save value in LSB of C
01:88F9 3E01            	   110: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:88FB 182F            	   111: 	jr		GetParameterEnd			; End routine
                        	   112: 
                        	   113: GetParamFetch2:
01:88FD FE02            	   114: 	cp		2						; Was it two digits?
01:88FF 200A            	   115: 	jr		nz,GetParamFetch3		; No then check for 3
01:8901 CD8D81          	   116: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:8904 303C            	   117: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8906 4F              	   118: 	ld		C,A						; Save value in C
01:8907 3E01            	   119: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:8909 1821            	   120: 	jr		GetParameterEnd			; End routine
                        	   121: 
                        	   122: GetParamFetch3:
01:890B FE03            	   123: 	cp		3						; Was three digits?
01:890D 2012            	   124: 	jr		nz,GetParamFetch4		; No then check for 4
01:890F 7E              	   125: 	ld		A,(HL)
01:8910 23              	   126: 	inc		HL
01:8911 CD6981          	   127: 	call	Ascii2HexNibble			; Convert the first ASCII char in HL to a hex value
01:8914 302C            	   128: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8916 47              	   129: 	ld		B,A						; Save result in D
01:8917 CD8D81          	   130: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:891A 3026            	   131: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:891C 4F              	   132: 	ld		C,A						; Store resulting byte in C (LSB)
01:891D 3E02            	   133: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
01:891F 180B            	   134: 	jr		GetParameterEnd			; End routine
                        	   135: 
                        	   136: GetParamFetch4:
01:8921 FE04            	   137: 	cp		4						; Was four digits?
01:8923 200E            	   138: 	jr		nz,GetParamNumberError	; Print error message
01:8925 CDAC81          	   139: 	call	Ascii2HexWord			; Convert a 4-character hex digit pointed by HL to a hex value
01:8928 3018            	   140: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:892A 3E02            	   141: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
                        	   142: 
                        	   143: GetParameterEnd:
01:892C 37              	   144: 	scf								; Set carry to indicate all is ok
01:892D C9              	   145: 	ret
                        	   146: 
                        	   147: GetParamHelp:
01:892E F1              	   148: 	pop		AF						; Dummy pop from stack as there was a push before
01:892F 3E0F            	   149: 	ld		A,HELP
01:8931 37              	   150: 	scf
01:8932 C9              	   151: 	ret
                        	   152: 
                        	   153: GetParamNumberError:
01:8933 0604            	   154: 	ld		B,4						;
                        	   155: GetErrorPointerLoop:
01:8935 CD4A89          	   156: 	call	IncErrorPointer			;
01:8938 10FB            	   157: 	djnz	GetErrorPointerLoop		;
01:893A CDBC89          	   158: 	call	PrintErrorPointer
01:893D CD3BB0          	   159: 	call	TooManyDigits			; Print invalid number of digits message	
01:8940 1806            	   160: 	jr		GetParamErrorEnd		; End Error handling
                        	   161: 
                        	   162: GetParamHexError:
01:8942 CDBC89          	   163: 	call	PrintErrorPointer
01:8945 CD44B0          	   164: 	call	InvalidHexDigit			;Print invalid hex character message
                        	   165: 
                        	   166: GetParamErrorEnd:
01:8948 B7              	   167: 	or		A						; Clear carry
01:8949 C9              	   168: 	ret
                        	   169: 
                        	   170: 
                        	   171: ;  ___                  _____                                ____            _           _                 
                        	   172: ; |_ _|  _ __     ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   173: ;  | |  | '_ \   / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   174: ;  | |  | | | | | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   175: ; |___| |_| |_|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   176: ;
                        	   177: ;
                        	   178: ; *********************************************************************************************************************
                        	   179: ; Increment error pointer by one
                        	   180: ; *********************************************************************************************************************
                        	   181: 
                        	   182: IncErrorPointer:
01:894A F5              	   183: 	push	AF
01:894B 3A8EB0          	   184: 	ld		A,(CmdErrorPointer)
01:894E 3C              	   185: 	inc		A
01:894F 328EB0          	   186: 	ld		(CmdErrorPointer),A
01:8952 F1              	   187: 	pop		AF
01:8953 C9              	   188: 	ret
                        	   189: 
                        	   190: 
                        	   191: ;  ____                                     
                        	   192: ; |  _ \    __ _   _ __   ___    ___   _ __ 
                        	   193: ; | |_) |  / _` | | '__| / __|  / _ \ | '__|
                        	   194: ; |  __/  | (_| | | |    \__ \ |  __/ | |   
                        	   195: ; |_|      \__,_| |_|    |___/  \___| |_|   
                        	   196: ;
                        	   197: ;
                        	   198: ; *********************************************************************************************************************
                        	   199: ; Parse the string and compare the commands list and the command prompt, then execute if found
                        	   200: ;	- Output:	BufferPointer points to parameter, if any
                        	   201: ; *********************************************************************************************************************
                        	   202: ;	- A = Command buffer character
                        	   203: ;	- B	= Command list character
                        	   204: ;	- DE = Command list pointer
                        	   205: ;	- HL = Command buffer pointer
                        	   206: 
                        	   207: Parser:
01:8954 F5              	   208: 	push	AF
01:8955 C5              	   209: 	push	BC
01:8956 D5              	   210: 	push	DE
01:8957 229BB0          	   211: 	ld		(ParseSaveHL),HL		; Saves HL register, because it's not possible to push it due to routine call
                        	   212: 
01:895A CD2F8B          	   213: 	call	ResetErrorPointer		; Reset error pointer to start position
01:895D 11B8A8          	   214: 	ld		DE,CommandList			; Commands list pointer
01:8960 216EB0          	   215: 	ld		HL,CommandBuffer		; Command buffer pointer
01:8963 CD378B          	   216: 	call	SkipSpaces				; Removes any leading spaces in command buffer
01:8966 228CB0          	   217: 	ld		(BufferPointer),HL		; Save the position of the first character for later
01:8969 7E              	   218: 	ld		A,(HL)					; Read first character or delimiter of the command in command buffer
01:896A FE00            	   219: 	cp		0						; Is it the end of the string already?
01:896C 2847            	   220: 	jr		z,ParseEnd				; If so, then exit parser routine
                        	   221: 
                        	   222: ParseNextChar:
01:896E 7E              	   223: 	ld		A,(HL)					; Read a character from the command buffer
01:896F CD9F82          	   224: 	call	UpperCase				; Change the case to uppercase, as the command list is in uppercase
01:8972 47              	   225: 	ld		B,A						; Put the uppercase character read from string in B
01:8973 1A              	   226: 	ld		A,(DE)					; Load a command list character in accumulator
01:8974 FEFF            	   227: 	cp		EOT						; Has the end of the command list been reached?
01:8976 2837            	   228: 	jr		z,ParseInvalid			; Teache the End Of Table, no matching commands has been found
01:8978 FEC3            	   229: 	cp		JUMP					; Is it a command delimiter? (Which is actualy a jp opcode)
01:897A 281B            	   230: 	jr		z,ParseValidate			; Yes, then execute command
01:897C B8              	   231: 	cp		B						; Is the letter from the list matching the buffer?
01:897D 2007            	   232: 	jr		nz,ParseNextCmd			; If not the same, go to next command in the list
01:897F CD4A89          	   233: 	call	IncErrorPointer			; Increment command line error pointer
01:8982 13              	   234: 	inc		DE						; Increment command list pointer to the next character
01:8983 23              	   235: 	inc		HL						; Increment command buffer pointer to tne next character
01:8984 18E8            	   236: 	jr		ParseNextChar			; Get the next character from command list
                        	   237: 
                        	   238: ParseNextCmd:
01:8986 13              	   239: 	inc		DE						; Increment command list pointer to eventually go to next command
01:8987 1A              	   240: 	ld		A,(DE)					; Load from command list
01:8988 FEC3            	   241: 	cp		JUMP					; Is it the End Of Command delimiter?
01:898A 20FA            	   242: 	jr		nz,ParseNextCmd			; No, then repeat until found
01:898C 13              	   243: 	inc		DE						; It is then bypass jump address
01:898D 13              	   244: 	inc		DE						; Point to the first character of following command
01:898E 13              	   245: 	inc		DE						;
01:898F 2A8CB0          	   246: 	ld		HL,(BufferPointer)		; Restore location of first valid command buffer character
01:8992 CD2F8B          	   247: 	call	ResetErrorPointer		; Reset error pointer to start position
01:8995 18D7            	   248: 	jr		ParseNextChar			; Loop back to read next character in list
                        	   249: 
                        	   250: ParseValidate:
01:8997 7E              	   251: 	ld		A,(HL)					; Check for extra unwanted characters by enforcing space delimiter
01:8998 FE00            	   252: 	cp		0						; Check if it's the end of the buffer
01:899A 2804            	   253: 	jr		z,ParseExecute			; It's the end of the buffer, execute command
01:899C FE20            	   254: 	cp		DELIMITER				; Is the space delimiter present in the command buffer?
01:899E 200F            	   255: 	jr		nz,ParseInvalid			; No, then it's not valid
                        	   256: 
                        	   257: ParseExecute:
01:89A0 228CB0          	   258: 	ld		(BufferPointer),HL		; Save current command buffer pointer for jump command parameters, if applicable
01:89A3 EB              	   259: 	ex		DE,HL					; Exchange DE with HL registers to be able to use HL for jumping
                        	   260: ;	jp		(HL)					; Execute command at address in DE (now HL)
                        	   261: 
01:89A4 D1              	   262: 	pop		DE
01:89A5 C1              	   263: 	pop		BC
01:89A6 F1              	   264: 	pop		AF
01:89A7 E5              	   265: 	push	HL						; Save call address
01:89A8 2A9BB0          	   266: 	ld		HL,(ParseSaveHL)		; Restore HL
01:89AB C9              	   267: 	ret								; Perform indirect call (HL)
01:89AC C34480          	   268: 	jp		Main					; Go to main
                        	   269: 	
                        	   270: ParseInvalid:
01:89AF 215FAC          	   271: 	ld		HL,ParseInvalidErr
01:89B2 CDAE80          	   272: 	call	PrintString
                        	   273: 
                        	   274: ParseEnd:
01:89B5 2A9BB0          	   275: 	ld		HL,(ParseSaveHL)
01:89B8 D1              	   276: 	pop		DE
01:89B9 C1              	   277: 	pop		BC
01:89BA F1              	   278: 	pop		AF
                        	   279: 	
01:89BB C9              	   280: 	ret
                        	   281: 
                        	   282: 
                        	   283: ;  ____           _           _     _____                                ____            _           _                 
                        	   284: ; |  _ \   _ __  (_)  _ __   | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   285: ; | |_) | | '__| | | | '_ \  | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   286: ; |  __/  | |    | | | | | | | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   287: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   288: ;
                        	   289: ;
                        	   290: ; *********************************************************************************************************************
                        	   291: ; Print error pointer character under the command line, pointing to the culprit
                        	   292: ; *********************************************************************************************************************
                        	   293: 
                        	   294: PrintErrorPointer:
01:89BC F5              	   295: 	push	AF
01:89BD C5              	   296: 	push	BC
                        	   297: 	
01:89BE 3A8EB0          	   298: 	ld		A,(CmdErrorPointer)		; Load error pointer as counter
01:89C1 47              	   299: 	ld		B,A
                        	   300: PrintErrorLoop:
01:89C2 3E20            	   301: 	ld		A," "
01:89C4 CD7480          	   302: 	call	PrintChar				; Print a space character
01:89C7 10F9            	   303: 	djnz	PrintErrorLoop			; Decrement B, and repeat printing space, until 0
01:89C9 3E5E            	   304: 	ld		A,ERRORPTR
01:89CB CD7480          	   305: 	call	PrintChar				; Print the error pointer character
01:89CE CD7F80          	   306: 	call	PrintCRLF				; Change line
                        	   307: 	
01:89D1 C1              	   308: 	pop		BC
01:89D2 F1              	   309: 	pop		AF
01:89D3 C9              	   310: 	ret
                        	   311: 
                        	   312: 
                        	   313: ;  ____                                  __     __          _   _       _           _     _                 
                        	   314: ; |  _ \    __ _   _ __     __ _    ___  \ \   / /   __ _  | | (_)   __| |   __ _  | |_  (_)   ___    _ __  
                        	   315: ; | |_) |  / _` | | '_ \   / _` |  / _ \  \ \ / /   / _` | | | | |  / _` |  / _` | | __| | |  / _ \  | '_ \ 
                        	   316: ; |  _ <  | (_| | | | | | | (_| | |  __/   \ V /   | (_| | | | | | | (_| | | (_| | | |_  | | | (_) | | | | |
                        	   317: ; |_| \_\  \__,_| |_| |_|  \__, |  \___|    \_/     \__,_| |_| |_|  \__,_|  \__,_|  \__| |_|  \___/  |_| |_|
                        	   318: ;                          |___/                                                                            
                        	   319: 
                        	   320: ; *********************************************************************************************************************
                        	   321: ; Validates a range of addresses that can be written to with commands such as Fill and Zero. The range returns
                        	   322: ; one or two ranges (before BIOS and after BIOS). It excludes BIOS, Interrupt vectors, jump table, and stack.
                        	   323: ; - Input:	StartAddress, EndAddress
                        	   324: ; - Output:	Updated StartAddress and EndAddress for low range, and StartAddressAlt and EndAddressAlt for high range
                        	   325: ;			C = Flags: bit0 = Low bank, bit1 = High bank
                        	   326: ; *********************************************************************************************************************
                        	   327: 
                        	   328: RangeValidation:
01:89D4 F5              	   329: 	push	AF
01:89D5 D5              	   330: 	push	DE
01:89D6 E5              	   331: 	push	HL
                        	   332: 	
01:89D7 0E00            	   333: 	ld		C,0						; Clear the region flag
01:89D9 210000          	   334: 	ld		HL,0
01:89DC 22AFB0          	   335: 	ld		(StartAddressAlt),HL	; Reset alternate start address (that represents low memory)
01:89DF 22B1B0          	   336: 	ld		(EndAddressAlt),HL		; Reset alternate end address (that represents high memory)
                        	   337: 	
                        	   338: ; CHECK ORDER OF START AND END ADDRESSES, AND IF RANGE IS ZERO
                        	   339: ; ------------------------------------------------------------
                        	   340: ValCheckInverted:
01:89E2 2AABB0          	   341: 	ld		HL,(StartAddress)		; Load start address
01:89E5 ED5BADB0        	   342: 	ld		DE,(EndAddress)			; Load end address
01:89E9 B7              	   343: 	or		A						; Clear carry flag
01:89EA ED52            	   344: 	sbc		HL,DE					; HL = HL - DE
01:89EC CA1B8B          	   345: 	jp		z,ValRangeTooSmallError	; If the range is 0, then print invalid error and exit
01:89EF D2218B          	   346: 	jp		nc,ValInvertedError		; If start address is higher than the end address, then print error and exit
                        	   347: 
                        	   348: ; CHECK IF THE START AND END ADDRESSES ARE IN THE VECTOR AREAS AND AJUST THEM ACCORDINGLY
                        	   349: ; ----------------------------------------------------------------------------------------
                        	   350: ValCheckLowLimit:					; VALIDATE START ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:89F2 2AABB0          	   351: 	ld		HL,(StartAddress)		; Load start address
01:89F5 118100          	   352: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:89F8 B7              	   353: 	or		A						; Clear carry flag
01:89F9 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:89FB 3006            	   355: 	jr		nc, ValCheckLowLimit2	; If it's not in the interrupt vector table, continue to next validation 
01:89FD 218000          	   356: 	ld		HL,InterruptVectorEnd			; Load 
01:8A00 22ABB0          	   357: 	ld		(StartAddress),HL
                        	   358: 
                        	   359: ValCheckLowLimit2:					; VALIDATE END ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:8A03 2AADB0          	   360: 	ld		HL,(EndAddress)			; Load end address
01:8A06 118100          	   361: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:8A09 B7              	   362: 	or		A						; Clear carry flag
01:8A0A ED52            	   363: 	sbc		HL,DE					; HL = HL - DE
01:8A0C DA278B          	   364: 	jp		c, RangeValidationError	; If it's in the interrupt vector table, print error and exit
                        	   365: 
                        	   366: ValCheckHighLimit:					; VALIDATE END ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A0F 2AADB0          	   367: 	ld		HL,(EndAddress)			; Load start address
01:8A12 1100FD          	   368: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A15 B7              	   369: 	or		A						; Clear carry flag
01:8A16 ED52            	   370: 	sbc		HL,DE					; HL = HL - DE
01:8A18 3806            	   371: 	jr		c, ValCheckHighLimit2	; If it's not in the vector tables, continue to next validation
01:8A1A 21FFFC          	   372: 	ld		HL,VectorTable-1		; Load Start of vector table area
01:8A1D 22ADB0          	   373: 	ld		(EndAddress),HL
                        	   374: 	
                        	   375: ValCheckHighLimit2:					; VALIDATE START ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A20 2AABB0          	   376: 	ld		HL,(StartAddress)		; Load start address
01:8A23 1100FD          	   377: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A26 B7              	   378: 	or		A						; Clear carry flag
01:8A27 ED52            	   379: 	sbc		HL,DE					; HL = HL - DE
01:8A29 D2278B          	   380: 	jp		nc,RangeValidationError	; If it's in the interrupt vector table, then change upper limit 
                        	   381: 
                        	   382: ; CHECK IF THE RANGE IS COMPLETELY IN BIOS ZONE
                        	   383: ; ---------------------------------------------
                        	   384: ValCheckBiosLow:
01:8A2C 2AABB0          	   385: 	ld		HL,(StartAddress)		; Load start address
01:8A2F 110080          	   386: 	ld		DE,StartOfCode			; Load start of code to compare too
01:8A32 B7              	   387: 	or		A						; Clear carry flag
01:8A33 ED52            	   388: 	sbc		HL,DE					; HL = HL - DE
01:8A35 380E            	   389: 	jr		c,ValCheckHigh			; If start address is lower than the start of code, then check if in high RRAM
                        	   390: 
                        	   391: ValCheckBiosHi:
01:8A37 2AADB0          	   392: 	ld		HL,(EndAddress)			; Load end address
01:8A3A 11B6B0          	   393: 	ld		DE,EndOfCode			; Load end of code address to compare too
01:8A3D B7              	   394: 	or		A						; Clear carry flag
01:8A3E ED52            	   395: 	sbc		HL,DE					; HL = HL - DE
01:8A40 3003            	   396: 	jr		nc,ValCheckHigh			; If end address is higher than the end of code, then check if in high RAM
01:8A42 C3158B          	   397: 	jp		ValBiosRangeError		; Else print invalid range and exit
                        	   398: 
                        	   399: ; CHECK IF RANGE IS IN HIGH MEMORY
                        	   400: ; --------------------------------
                        	   401: ValCheckHigh:
                        	   402: 	; Is it in high memory?
01:8A45 2AABB0          	   403: 	ld		HL,(StartAddress)		; Load start address
01:8A48 110080          	   404: 	ld		DE,StartOfCode			; Load start of code address
01:8A4B B7              	   405: 	or		A						; Clear carry flag
01:8A4C ED52            	   406: 	sbc		HL,DE					; HL = HL - DE
                        	   407: 	; No, then check for low memory
01:8A4E 3829            	   408: 	jr		c,ValCheckLow
                        	   409: 
                        	   410: 	; Is it in high memory, but is it within the BIOS region?
01:8A50 2AABB0          	   411: 	ld		HL,(StartAddress)		; Load start address
01:8A53 11B6B0          	   412: 	ld		DE,EndOfCode			; Load end of code address
01:8A56 B7              	   413: 	or		A						; Clear carry flag
01:8A57 ED52            	   414: 	sbc		HL,DE					; HL = HL - DE
                        	   415: 	; Yes, then change StartAddress to upper limit of BIOS
01:8A59 3810            	   416: 	jr		c,ValCheckHighBios
                        	   417: 	; No, then only copy start and end addresses to the Alt locations
01:8A5B 2AABB0          	   418: 	ld		HL,(StartAddress)		;
01:8A5E 22AFB0          	   419: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A61 2AADB0          	   420: 	ld		HL,(EndAddress)			;
01:8A64 22B1B0          	   421: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A67 CBC9            	   422: 	set		1,C						; Flag high address
01:8A69 180E            	   423: 	jr		ValCheckLow
                        	   424: 
                        	   425: ValCheckHighBios:
01:8A6B 21B6B0          	   426: 	ld		HL,EndOfCode		;
01:8A6E 22AFB0          	   427: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A71 2AADB0          	   428: 	ld		HL,(EndAddress)			;
01:8A74 22B1B0          	   429: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A77 CBC9            	   430: 	set		1,C						; Flag high address
                        	   431: 	
                        	   432: ; CHECK IF RANGE IS IN LOW MEMORY
                        	   433: ; -------------------------------
                        	   434: ValCheckLow:
                        	   435: 	; Is it in low memory only?
01:8A79 2AADB0          	   436: 	ld		HL,(EndAddress)			; Load start address
01:8A7C 11B6B0          	   437: 	ld		DE,EndOfCode			; Load start of code address
01:8A7F B7              	   438: 	or		A						; Clear carry flag
01:8A80 ED52            	   439: 	sbc		HL,DE					; HL = HL - DE
                        	   440: 	; No, then it overlaps BIOS
01:8A82 3018            	   441: 	jr		nc,ValBiosOverlap
                        	   442: 
                        	   443: 	; Is it in low memory, but is it within the BIOS region?
01:8A84 2AADB0          	   444: 	ld		HL,(EndAddress)			; Load start address
01:8A87 110080          	   445: 	ld		DE,StartOfCode			; Load end of code address
01:8A8A B7              	   446: 	or		A						; Clear carry flag
01:8A8B ED52            	   447: 	sbc		HL,DE					; HL = HL - DE
                        	   448: 	; Yes, then change EndAddress to lower limit of BIOS
01:8A8D 3004            	   449: 	jr		nc,ValCheckLowBios
                        	   450: 	; No, then only flag low memory
01:8A8F CBC1            	   451: 	set		0,C						; Flag low address
01:8A91 1809            	   452: 	jr		ValBiosOverlap
                        	   453: 
                        	   454: ValCheckLowBios:
01:8A93 210080          	   455: 	ld		HL,StartOfCode			;
01:8A96 2B              	   456: 	dec		HL
01:8A97 22ADB0          	   457: 	ld		(EndAddress),HL			; Set start address at the end of code, in case it overlapped
01:8A9A CBC1            	   458: 	set		0,C						; Flag low address
                        	   459: 
                        	   460: ; CHECK IF RANGE OVERLAPS BIOS AREA
                        	   461: ; ---------------------------------
                        	   462: ValBiosOverlap:
01:8A9C 79              	   463: 	ld		A,C
01:8A9D FE00            	   464: 	cp		0
01:8A9F 2017            	   465: 	jr		nz,ValCheckIfZeroDataLow
                        	   466: 	; Move EndAddress to the Alternate one
01:8AA1 2AADB0          	   467: 	ld		HL,(EndAddress)
01:8AA4 22B1B0          	   468: 	ld		(EndAddressAlt),HL
                        	   469: 	; Change low memory EndAddress to beginning of BIOS -1
01:8AA7 210080          	   470: 	ld		HL,StartOfCode		
01:8AAA 2B              	   471: 	dec		HL
01:8AAB 22ADB0          	   472: 	ld		(EndAddress),HL
                        	   473: 	; Change high memory StartAddressAlt to end of BIOS
01:8AAE 21B6B0          	   474: 	ld		HL,EndOfCode
01:8AB1 22AFB0          	   475: 	ld		(StartAddressAlt),HL
01:8AB4 CBC1            	   476: 	set		0,C						; Flag low address
01:8AB6 CBC9            	   477: 	set		1,C						; Flag high address
                        	   478: 
                        	   479: ; CHECK IF RANGE(S) ARE ZERO, WITH REASSIGNMENT, IT'S POSSIBLE
                        	   480: ; ------------------------------------------------------------
                        	   481: ValCheckIfZeroDataLow:
01:8AB8 CB41            	   482: 	bit		0,C
01:8ABA 280C            	   483: 	jr		z,ValCheckIfZeroDataHigh
01:8ABC 2AABB0          	   484: 	ld		HL,(StartAddress)		; Load start address
01:8ABF ED5BADB0        	   485: 	ld		DE,(EndAddress)			; Load end address
01:8AC3 B7              	   486: 	or		A						; Clear carry flag
01:8AC4 ED52            	   487: 	sbc		HL,DE					; HL = HL - DE
01:8AC6 2853            	   488: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   489: 
                        	   490: ValCheckIfZeroDataHigh:
01:8AC8 CB49            	   491: 	bit		1,C
01:8ACA 280C            	   492: 	jr		z,ValPrintRange
01:8ACC 2AAFB0          	   493: 	ld		HL,(StartAddressAlt)	; Load alternate start address
01:8ACF ED5BB1B0        	   494: 	ld		DE,(EndAddressAlt)		; Load alternate end address
01:8AD3 B7              	   495: 	or		A						; Clear carry flag
01:8AD4 ED52            	   496: 	sbc		HL,DE					; HL = HL - DE
01:8AD6 2843            	   497: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   498: 
                        	   499: 	; PRINTS ADDRESS RANGE
                        	   500: ValPrintRange:
01:8AD8 CDF9AF          	   501: 	call	Range
                        	   502: 
                        	   503: ValPrintRange1:
01:8ADB CB41            	   504: 	bit		0,C
01:8ADD 2816            	   505: 	jr		z,ValPrintRange2
01:8ADF 3E20            	   506: 	ld		A," "
01:8AE1 CD7480          	   507: 	call	PrintChar
01:8AE4 2AABB0          	   508: 	ld		HL,(StartAddress)
01:8AE7 CDBC80          	   509: 	call	PrintWord
01:8AEA 3E2D            	   510: 	ld		A,"-"
01:8AEC CD7480          	   511: 	call	PrintChar
01:8AEF 2AADB0          	   512: 	ld		HL,(EndAddress)
01:8AF2 CDBC80          	   513: 	call	PrintWord
                        	   514: 	
                        	   515: ValPrintRange2:
01:8AF5 CB49            	   516: 	bit		1,C
01:8AF7 2816            	   517: 	jr		z,ValPrintRangeEnd
01:8AF9 3E20            	   518: 	ld		A," "
01:8AFB CD7480          	   519: 	call	PrintChar
01:8AFE 2AAFB0          	   520: 	ld		HL,(StartAddressAlt)
01:8B01 CDBC80          	   521: 	call	PrintWord
01:8B04 3E2D            	   522: 	ld		A,"-"
01:8B06 CD7480          	   523: 	call	PrintChar
01:8B09 2AB1B0          	   524: 	ld		HL,(EndAddressAlt)
01:8B0C CDBC80          	   525: 	call	PrintWord	
                        	   526: 
                        	   527: ValPrintRangeEnd:
01:8B0F CD7F80          	   528: 	call	PrintCRLF
01:8B12 37              	   529: 	scf								; Set carry
01:8B13 1816            	   530: 	jr		RangeValidationEnd
                        	   531: 
                        	   532: ValBiosRangeError:
01:8B15 CD14B0          	   533: 	call	BiosRange
01:8B18 B7              	   534: 	or		A
01:8B19 1810            	   535: 	jr		RangeValidationEnd
                        	   536: 
                        	   537: ValRangeTooSmallError:
01:8B1B CD0BB0          	   538: 	call	RangeTooSmall
01:8B1E B7              	   539: 	or		A
01:8B1F 180A            	   540: 	jr		RangeValidationEnd
                        	   541: 
                        	   542: ValInvertedError:
01:8B21 CD1DB0          	   543: 	call	RangeInverted
01:8B24 B7              	   544: 	or		A
01:8B25 1804            	   545: 	jr		RangeValidationEnd
                        	   546: 	
                        	   547: RangeValidationError:
01:8B27 CD02B0          	   548: 	call	InvalidVectorRange
01:8B2A B7              	   549: 	or		A						; Clear Carry
                        	   550: 
                        	   551: RangeValidationEnd:
01:8B2B E1              	   552: 	pop		HL
01:8B2C D1              	   553: 	pop		DE
01:8B2D F1              	   554: 	pop		AF
                        	   555: 
01:8B2E C9              	   556: 	ret
                        	   557: 
                        	   558: 
                        	   559: ;  ____                        _     _____                                ____            _           _                
                        	   560: ; |  _ \    ___   ___    ___  | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __
                        	   561: ; | |_) |  / _ \ / __|  / _ \ | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__
                        	   562: ; |  _ <  |  __/ \__ \ |  __/ | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |  
                        	   563: ; |_| \_\  \___| |___/  \___|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|  
                        	   564: ;
                        	   565: ;
                        	   566: ; *********************************************************************************************************************
                        	   567: ; Increment error pointer by one
                        	   568: ; *********************************************************************************************************************
                        	   569: 
                        	   570: ResetErrorPointer:
01:8B2F F5              	   571: 	push	AF
01:8B30 3E08            	   572: 	ld		A,ErrorPtrOffset
01:8B32 328EB0          	   573: 	ld		(CmdErrorPointer),A
01:8B35 F1              	   574: 	pop		AF
01:8B36 C9              	   575: 	ret
                        	   576: 
                        	   577: 
                        	   578: ;  ____    _      _           ____                                      
                        	   579: ; / ___|  | | __ (_)  _ __   / ___|   _ __     __ _    ___    ___   ___ 
                        	   580: ; \___ \  | |/ / | | | '_ \  \___ \  | '_ \   / _` |  / __|  / _ \ / __|
                        	   581: ;  ___) | |   <  | | | |_) |  ___) | | |_) | | (_| | | (__  |  __/ \__ \
                        	   582: ; |____/  |_|\_\ |_| | .__/  |____/  | .__/   \__,_|  \___|  \___| |___/
                        	   583: ;                    |_|             |_|                                
                        	   584: ;
                        	   585: ; *********************************************************************************************************************
                        	   586: ; Removes leading spaces for parsing commands
                        	   587: ;	- Input:	HL pointing to command string
                        	   588: ;	- Output:	HL points to the next delimiterless position
                        	   589: ; *********************************************************************************************************************
                        	   590: 
                        	   591: SkipSpaces:
01:8B37 F5              	   592: 	push	AF
                        	   593: SkipSpacesLoop:
01:8B38 7E              	   594: 	ld		A,(HL)					; Read the contents of HL, where the 
01:8B39 FE20            	   595: 	cp		" "						; Is it a space?
01:8B3B 2006            	   596: 	jr		nz,SkipSpacesEnd		; It's not a space, so end routine
01:8B3D 23              	   597: 	inc		HL						; It's a space, so move to next character
01:8B3E CD4A89          	   598: 	call	IncErrorPointer			; Increment command line error pointer
01:8B41 18F5            	   599: 	jr		SkipSpacesLoop			; Check for other spaces, just in case
                        	   600: SkipSpacesEnd:
01:8B43 F1              	   601: 	pop		AF
01:8B44 C9              	   602: 	ret
                        	   603: 
                        	   604: 

Source: "main.asm"
                        	   273: 	.include	"basic.asm"			; Nascom Microsoft Basic (from Grant Searle)

Source: "basic.asm"
                        	     1: ;==================================================================================
                        	     2: ; The updates to the original BASIC within this file are copyright Grant Searle
                        	     3: ;
                        	     4: ; You have permission to use this for NON COMMERCIAL USE ONLY
                        	     5: ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        	     6: ;
                        	     7: ; http://searle.hostei.com/grant/index.html
                        	     8: ;
                        	     9: ; eMail: home.micros01@btinternet.com
                        	    10: ;
                        	    11: ; If the above don't work, please perform an Internet search to see if I have
                        	    12: ; updated the web page hosting service.
                        	    13: ;
                        	    14: ;==================================================================================
                        	    15: 
                        	    16: ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        	    17: ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        	    18: ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        	    19: ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        	    20: ; the original ROM code (checksum A934H). PA
                        	    21: ;
                        	    22: ;==================================================================================
                        	    23: 
                        	    24: ; BASIC ERROR CODE VALUES
                        	    25: 
                        	    26: NF		.EQU	00H				; NEXT without FOR
                        	    27: SN		.EQU	02H				; Syntax error
                        	    28: RG		.EQU	04H				; RETURN without GOSUB
                        	    29: OD		.EQU	06H				; Out of DATA
                        	    30: FC		.EQU	08H				; Function call error
                        	    31: OV		.EQU	0AH				; Overflow
                        	    32: OM		.EQU	0CH				; Out of memory
                        	    33: UL		.EQU	0EH				; Undefined line number
                        	    34: BS		.EQU	10H				; Bad subscript
                        	    35: DD		.EQU	12H				; Re-DIMensioned array
                        	    36: DZ		.EQU	14H				; Division by zero (/0)
                        	    37: ID		.EQU	16H				; Illegal direct
                        	    38: TM		.EQU	18H				; Type miss-match
                        	    39: OS		.EQU	1AH				; Out of string space
                        	    40: LS		.EQU	1CH				; String too long
                        	    41: ST		.EQU	1EH				; String formula too complex
                        	    42: CN		.EQU	20H				; Can't CONTinue
                        	    43: UF		.EQU	22H				; UnDEFined FN function
                        	    44: MO		.EQU	24H				; Missing operand
                        	    45: HX		.EQU	26H				; HEX error
                        	    46: BN		.EQU	28H				; BIN error
                        	    47: 
                        	    48: 
                        	    49: ; BASIC WORK SPACE LOCATIONS
                        	    50: 
                        	    51: ;WRKSPC	.EQU	2045H			  ; BASIC Work space
                        	    52: WRKSPC	.EQU	$1000			  ; BASIC Work space
                        	    53: USR		.EQU	WRKSPC+3H			; "USR (x)" jump
                        	    54: OUTSUB	.EQU	WRKSPC+6H			; "OUT p,n"
                        	    55: OTPORT	.EQU	WRKSPC+7H			; Port (p)
                        	    56: DIVSUP	.EQU	WRKSPC+9H			; Division support routine
                        	    57: DIV1	.EQU	WRKSPC+0AH			 ; <- Values
                        	    58: DIV2	.EQU	WRKSPC+0EH			 ; <-	to
                        	    59: DIV3	.EQU	WRKSPC+12H			 ; <-	be
                        	    60: DIV4	.EQU	WRKSPC+15H			 ; <-inserted
                        	    61: SEED	.EQU	WRKSPC+17H			 ; Random number seed
                        	    62: LSTRND	.EQU	WRKSPC+3AH			 ; Last random number
                        	    63: INPSUB	.EQU	WRKSPC+3EH			 ; #INP (x)" Routine
                        	    64: INPORT	.EQU	WRKSPC+3FH			 ; PORT (x)
                        	    65: NULLS	.EQU	WRKSPC+41H			 ; Number of nulls
                        	    66: LWIDTH	.EQU	WRKSPC+42H			 ; Terminal width
                        	    67: COMMAN	.EQU	WRKSPC+43H			 ; Width for commas
                        	    68: NULFLG	.EQU	WRKSPC+44H			 ; Null after input byte flag
                        	    69: CTLOFG	.EQU	WRKSPC+45H			 ; Control "O" flag
                        	    70: LINESC	.EQU	WRKSPC+46H			 ; Lines counter
                        	    71: LINESN	.EQU	WRKSPC+48H			 ; Lines number
                        	    72: CHKSUM	.EQU	WRKSPC+4AH			 ; Array load/save check sum
                        	    73: NMIFLG	.EQU	WRKSPC+4CH			 ; Flag for NMI break routine
                        	    74: BRKFLG	.EQU	WRKSPC+4DH			 ; Break flag
                        	    75: RINPUT	.EQU	WRKSPC+4EH			 ; Input reflection
                        	    76: POINT	.EQU	WRKSPC+51H			 ; "POINT" reflection (unused)
                        	    77: PSET	.EQU	WRKSPC+54H			 ; "SET"   reflection
                        	    78: RESET	.EQU	WRKSPC+57H			 ; "RESET" reflection
                        	    79: STRSPC	.EQU	WRKSPC+5AH			 ; Bottom of string space
                        	    80: LINEAT	.EQU	WRKSPC+5CH			 ; Current line number
                        	    81: BASTXT	.EQU	WRKSPC+5EH			 ; Pointer to start of program
                        	    82: BUFFER	.EQU	WRKSPC+61H			 ; Input buffer
                        	    83: STACK	.EQU	WRKSPC+66H			 ; Initial stack
                        	    84: CURPOS	.EQU	WRKSPC+0ABH			 ; Character position on line
                        	    85: LCRFLG	.EQU	WRKSPC+0ACH			 ; Locate/Create flag
                        	    86: TYPE	.EQU	WRKSPC+0ADH			 ; Data type flag
                        	    87: DATFLG	.EQU	WRKSPC+0AEH			 ; Literal statement flag
                        	    88: LSTRAM	.EQU	WRKSPC+0AFH			 ; Last available RAM
                        	    89: TMSTPT	.EQU	WRKSPC+0B1H			 ; Temporary string pointer
                        	    90: TMSTPL	.EQU	WRKSPC+0B3H			 ; Temporary string pool
                        	    91: TMPSTR	.EQU	WRKSPC+0BFH			 ; Temporary string
                        	    92: STRBOT	.EQU	WRKSPC+0C3H			 ; Bottom of string space
                        	    93: CUROPR	.EQU	WRKSPC+0C5H			 ; Current operator in EVAL
                        	    94: LOOPST	.EQU	WRKSPC+0C7H			 ; First statement of loop
                        	    95: DATLIN	.EQU	WRKSPC+0C9H			 ; Line of current DATA item
                        	    96: FORFLG	.EQU	WRKSPC+0CBH			 ; "FOR" loop flag
                        	    97: LSTBIN	.EQU	WRKSPC+0CCH			 ; Last byte entered
                        	    98: READFG	.EQU	WRKSPC+0CDH			 ; Read/Input flag
                        	    99: BRKLIN	.EQU	WRKSPC+0CEH			 ; Line of break
                        	   100: NXTOPR	.EQU	WRKSPC+0D0H			 ; Next operator in EVAL
                        	   101: ERRLIN	.EQU	WRKSPC+0D2H			 ; Line of error
                        	   102: CONTAD	.EQU	WRKSPC+0D4H			 ; Where to CONTinue
                        	   103: PROGND	.EQU	WRKSPC+0D6H			 ; End of program
                        	   104: VAREND	.EQU	WRKSPC+0D8H			 ; End of variables
                        	   105: ARREND	.EQU	WRKSPC+0DAH			 ; End of arrays
                        	   106: NXTDAT	.EQU	WRKSPC+0DCH			 ; Next data item
                        	   107: FNRGNM	.EQU	WRKSPC+0DEH			 ; Name of FN argument
                        	   108: FNARG	.EQU	WRKSPC+0E0H			 ; FN argument value
                        	   109: FPREG	.EQU	WRKSPC+0E4H			 ; Floating point register
                        	   110: FPEXP	.EQU	FPREG+3			; Floating point exponent
                        	   111: SGNRES	.EQU	WRKSPC+0E8H		; Sign of result
                        	   112: PBUFF	.EQU	WRKSPC+0E9H		; Number print buffer
                        	   113: MULVAL	.EQU	WRKSPC+0F6H		; Multiplier
                        	   114: PROGST	.EQU	WRKSPC+0F9H		; Start of program text area
                        	   115: STLOOK	.EQU	WRKSPC+15DH		; Start of memory test
                        	   116: 
                        	   117: 
                        	   118: ;TEMPSTACK	.EQU	$20ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   119: TEMPSTACK	.EQU	$7FFF ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   120: 
                        	   121: 
                        	   122: ;  ____       _      ____    ___    ____ 
                        	   123: ; | __ )     / \    / ___|  |_ _|  / ___|
                        	   124: ; |  _ \    / _ \   \___ \   | |  | |    
                        	   125: ; | |_) |  / ___ \   ___) |  | |  | |___ 
                        	   126: ; |____/  /_/   \_\ |____/  |___|  \____|
                        	   127: ;
                        	   128: ;
                        	   129: ; *********************************************************************************************************************
                        	   130: 
                        	   131: BASIC:
01:8B45 CDAA82          	   132: 	call	ClearScreen				; Clear screen
01:8B48 216E8B          	   133: 	ld		HL,SignOnMsg			; Sign-on message
01:8B4B CDAE80          	   134: 	call	PrintString				; Output string
                        	   135: 
                        	   136: ColdOrWarm:
01:8B4E CDC780          	   137: 	call	ReadChar				; Read a character
01:8B51 CD9F82          	   138: 	call	Uppercase				; Convert to uppercase
                        	   139: 
                        	   140: CheckIfCold:
01:8B54 FE43            	   141: 	cp		"C"						; Is it C for Coldstart?
01:8B56 2009            	   142: 	jr		nz,CheckIfWarm			; No, then check if it's Warmstart
01:8B58 CD7480          	   143: 	call	PrintChar				; Print the C
01:8B5B CD7F80          	   144: 	call	PrintCRLF				; Print carriage return and linefeed
01:8B5E C3CA8B          	   145: 	jp		COLD					; Start BASIC COLD
                        	   146: 
                        	   147: CheckIfWarm:
01:8B61 FE57            	   148: 	cp		"W"						
01:8B63 20E9            	   149: 	jr		nz,ColdOrWarm
01:8B65 CD7480          	   150: 	call	PrintChar
01:8B68 CD7F80          	   151: 	call	PrintCRLF
01:8B6B C3688C          	   152: 	jp		WARM					; Start BASIC WARM
                        	   153: 			  
                        	   154: SignOnMsg:
01:8B6E 5570646174657320	   155: 	db		"Updates to BASIC by Grant Searle",CR,LF
01:8B76 746F204241534943
01:8B7E 206279204772616E
01:8B86 7420536561726C65
01:8B8E 0D
01:8B8F 0A
01:8B90 4164617074656420	   156: 	db		"Adapted by Frederic Segard",CR,LF
01:8B98 6279204672656465
01:8BA0 7269632053656761
01:8BA8 7264
01:8BAA 0D
01:8BAB 0A
01:8BAC 436F6C64206F7220	   157: 	db		"Cold or warm start (C or W)? ",0
01:8BB4 7761726D20737461
01:8BBC 7274202843206F72
01:8BC4 2057293F20
01:8BC9 00
                        	   158: 
                        	   159: ; COLD START SEQUENCE
                        	   160: COLD:
01:8BCA DD210000        	   161: 	LD		IX,0					; Flag cold start
01:8BCE C3D58B          	   162: 	jp		CSTART					; Jump to initialise
                        	   163: 
01:8BD1 8394            	   164: 	dw		DEINT					; Get integer -32768 to 32767
01:8BD3 F29B            	   165: 	dw		ABPASS					; Return integer in AB
                        	   166: 
                        	   167: CSTART:
01:8BD5 210010          	   168: 	ld		HL,WRKSPC				; Start of workspace RAM
01:8BD8 F9              	   169: 	ld		SP,HL					; Set up a temporary stack
01:8BD9 C315A8          	   170: 	jp		INITST					; Go to initialise
                        	   171: 
                        	   172: INIT:
01:8BDC 11A78E          	   173: 	ld		DE,INITAB				; Initialise workspace
01:8BDF 0663            	   174: 	ld		B,INITBE-INITAB+3		; Bytes to copy
01:8BE1 210010          	   175: 	ld		HL,WRKSPC				; Into workspace RAM
                        	   176: COPYY:
01:8BE4 1A              	   177: 	ld		A,(DE)					; Get source
01:8BE5 77              	   178: 	ld		(HL),A					; To destination
01:8BE6 23              	   179: 	inc		HL						; Next destination
01:8BE7 13              	   180: 	inc		DE						; Next source
01:8BE8 05              	   181: 	dec		B						; Count bytes
01:8BE9 C2E48B          	   182: 	jp		NZ,COPYY				; More to move
01:8BEC F9              	   183: 	ld		SP,HL					; Temporary stack
01:8BED CDA890          	   184: 	call	CLREG					; Clear registers and stack
01:8BF0 CD7F80          	   185: 	call	PrintCRLF				; Output CRLF
01:8BF3 32AA10          	   186: 	ld		(BUFFER+72+1),A 		; Mark end of buffer
01:8BF6 32F910          	   187: 	ld		(PROGST),A				; Initialise program area
                        	   188: MSIZE:
01:8BF9 21B68C          	   189: 	ld		HL,MEMMSG				; Point to message
01:8BFC CD109D          	   190: 	call	PRS						; Output "Memory size"
01:8BFF CDC590          	   191: 	call	PROMPT					; Get input with '?'
01:8C02 CDCE93          	   192: 	call	GETCHR					; Get next character
01:8C05 B7              	   193: 	or		A						; Set flags
01:8C06 C21E8C          	   194: 	jp		NZ,TSTMEM				; If number - Test if RAM there
01:8C09 215D11          	   195: 	ld		HL,STLOOK				; Point to start of RAM
                        	   196: MLOOP:
01:8C0C 23              	   197: 	inc		HL						; Next byte
01:8C0D 7C              	   198: 	ld		A,H						; Above address FFFF ?
01:8C0E B5              	   199: 	or		L
01:8C0F CA308C          	   200: 	jp		Z,SETTOP				; Yes - 64K RAM
01:8C12 7E              	   201: 	ld		A,(HL)					; Get contents
01:8C13 47              	   202: 	ld		B,A						; Save it
01:8C14 2F              	   203: 	cpl								; Flip all bits
01:8C15 77              	   204: 	ld		(HL),A					; Put it back
01:8C16 BE              	   205: 	cp		(HL)					; RAM there if same
01:8C17 70              	   206: 	ld		(HL),B					; Restore old contents
01:8C18 CA0C8C          	   207: 	jp		Z,MLOOP					; If RAM - test next byte
01:8C1B C3308C          	   208: 	jp		SETTOP					; Top of RAM found
                        	   209: 
                        	   210: TSTMEM:
01:8C1E CD9D94          	   211: 	call	ATOH					; Get high memory into DE
01:8C21 B7              	   212: 	or		A						; Set flags on last byte
01:8C22 C2768F          	   213: 	jp		NZ,SNERR				; ?SN Error if bad character
01:8C25 EB              	   214: 	ex		DE,HL					; Address into HL
01:8C26 2B              	   215: 	dec		HL						; Back one byte
01:8C27 3ED9            	   216: 	ld		A,11011001B				; Test byte
01:8C29 46              	   217: 	ld		B,(HL)					; Get old contents
01:8C2A 77              	   218: 	ld		(HL),A					; Load test byte
01:8C2B BE              	   219: 	cp		(HL)					; RAM there if same
01:8C2C 70              	   220: 	ld		(HL),B					; Restore old contents
01:8C2D C2F98B          	   221: 	jp		NZ,MSIZE				; Ask again if no RAM
                        	   222: 
                        	   223: SETTOP:
01:8C30 2B              	   224: 	dec		HL						; Back one byte
01:8C31 115C11          	   225: 	ld		DE,STLOOK-1				; See if enough RAM
01:8C34 CD3E92          	   226: 	call	CPDEHL					; Compare DE with HL
01:8C37 DAF98B          	   227: 	jp		C,MSIZE					; Ask again if not enough RAM
01:8C3A 11CEFF          	   228: 	ld		DE,0-50					; 50 Bytes string space
01:8C3D 22AF10          	   229: 	ld		(LSTRAM),HL				; Save last available RAM
01:8C40 19              	   230: 	add		HL,DE					; Allocate string space
01:8C41 225A10          	   231: 	ld		(STRSPC),HL				; Save string space
01:8C44 CD8390          	   232: 	call	CLRPTR					; Clear program area
01:8C47 2A5A10          	   233: 	ld		HL,(STRSPC)				; Get end of memory
01:8C4A 11EFFF          	   234: 	ld		DE,0-17					; Offset for free bytes
01:8C4D 19              	   235: 	add		HL,DE					; Adjust HL
01:8C4E 11F910          	   236: 	ld		DE,PROGST				; Start of program text
01:8C51 7D              	   237: 	ld		A,L						; Get LSB
01:8C52 93              	   238: 	sub		E						; Adjust it
01:8C53 6F              	   239: 	ld		L,A						; Re-save
01:8C54 7C              	   240: 	ld		A,H						; Get MSB
01:8C55 9A              	   241: 	sbc		A,D						; Adjust it
01:8C56 67              	   242: 	ld		H,A						; Re-save
01:8C57 E5              	   243: 	push	HL						; Save bytes free
01:8C58 21808C          	   244: 	ld		HL,SIGNON				; Sign-on message
01:8C5B CD109D          	   245: 	call	PRS						; Output string
01:8C5E E1              	   246: 	pop		HL						; Get bytes free back
01:8C5F CDB3A3          	   247: 	call	PRNTHL					; Output amount of free memory
01:8C62 21718C          	   248: 	ld		HL,BFREE				; " Bytes free" message
01:8C65 CD109D          	   249: 	call	PRS						; Output string
                        	   250: 
                        	   251: WARM:								; WARM START
01:8C68 316610          	   252: 	ld		SP,STACK				; Temporary stack
                        	   253: BRKRET:
01:8C6B CDA890          	   254: 	call	CLREG					; Clear registers and stack
01:8C6E C3C18F          	   255: 	jp		PRNTOK					; Go to get command line
                        	   256: 
                        	   257: BFREE:	
01:8C71 2042797465732066	   258: 	db		" Bytes free",CR,LF,0,0
01:8C79 726565
01:8C7C 0D
01:8C7D 0A
01:8C7E 00
01:8C7F 00
                        	   259: 
                        	   260: SIGNON: 
01:8C80 5A38302042415349	   261: 	db		"Z80 BASIC Ver 4.7b",CR,LF
01:8C88 432056657220342E
01:8C90 3762
01:8C92 0D
01:8C93 0A
01:8C94 436F707972696768	   262: 	db		"Copyright (C) 1978 by Microsoft",CR,LF,0
01:8C9C 7420284329203139
01:8CA4 3738206279204D69
01:8CAC 63726F736F6674
01:8CB3 0D
01:8CB4 0A
01:8CB5 00
                        	   263: 
                        	   264: MEMMSG:
01:8CB6 4D656D6F72792074	   265: 	db		"Memory top",0
01:8CBE 6F70
01:8CC0 00
                        	   266: 
                        	   267: 
                        	   268: ; FUNCTION ADDRESS TABLE
                        	   269: 
                        	   270: FNCTAB:
01:8CC1 28A2            	   271: 	dw		SGN
01:8CC3 ECA2            	   272: 	dw		INT
01:8CC5 3EA2            	   273: 	dw		ABS
01:8CC7 0310            	   274: 	dw		USR
01:8CC9 D09B            	   275: 	dw		FRE
01:8CCB 559F            	   276: 	dw		INP
01:8CCD FE9B            	   277: 	dw		POS
01:8CCF B2A4            	   278: 	dw		SQR
01:8CD1 91A5            	   279: 	dw		RND
01:8CD3 CDA0            	   280: 	dw		LOG
01:8CD5 00A5            	   281: 	dw		EXPP
01:8CD7 06A6            	   282: 	dw		COS
01:8CD9 0CA6            	   283: 	dw		SIN
01:8CDB 6DA6            	   284: 	dw		TAN
01:8CDD 82A6            	   285: 	dw		ATN
01:8CDF A99F            	   286: 	dw		PEEK
01:8CE1 EDA6            	   287: 	dw		DEEK
01:8CE3 5110            	   288: 	dw		POINT
01:8CE5 829E            	   289: 	dw		LEN
01:8CE7 9A9C            	   290: 	dw		STRR
01:8CE9 1C9F            	   291: 	dw		VAL
01:8CEB 919E            	   292: 	dw		ASCC
01:8CED A29E            	   293: 	dw		CHR
01:8CEF 0FA7            	   294: 	dw		HEX
01:8CF1 A6A7            	   295: 	dw		BIN
01:8CF3 B29E            	   296: 	dw		LEFT
01:8CF5 E29E            	   297: 	dw		RIGHT
01:8CF7 EC9E            	   298: 	dw		MID
                        	   299: 
                        	   300: 
                        	   301: ; RESERVED WORD LIST
                        	   302: 
                        	   303: WORDS:
01:8CF9 C5              	   304: 	db		'E'+80H,"ND"
01:8CFA 4E44
01:8CFC C6              	   305: 	db		'F'+80H,"OR"
01:8CFD 4F52
01:8CFF CE              	   306: 	db		'N'+80H,"EXT"
01:8D00 455854
01:8D03 C4              	   307: 	db		'D'+80H,"ATA"
01:8D04 415441
01:8D07 C9              	   308: 	db		'I'+80H,"NPUT"
01:8D08 4E505554
01:8D0C C4              	   309: 	db		'D'+80H,"IM"
01:8D0D 494D
01:8D0F D2              	   310: 	db		'R'+80H,"EAD"
01:8D10 454144
01:8D13 CC              	   311: 	db		'L'+80H,"ET"
01:8D14 4554
01:8D16 C7              	   312: 	db		'G'+80H,"OTO"
01:8D17 4F544F
01:8D1A D2              	   313: 	db		'R'+80H,"UN"
01:8D1B 554E
01:8D1D C9              	   314: 	db		'I'+80H,"F"
01:8D1E 46
01:8D1F D2              	   315: 	db		'R'+80H,"ESTORE"
01:8D20 4553544F5245
01:8D26 C7              	   316: 	db		'G'+80H,"OSUB"
01:8D27 4F535542
01:8D2B D2              	   317: 	db		'R'+80H,"ETURN"
01:8D2C 455455524E
01:8D31 D2              	   318: 	db		'R'+80H,"EM"
01:8D32 454D
01:8D34 D3              	   319: 	db		'S'+80H,"TOP"
01:8D35 544F50
01:8D38 CF              	   320: 	db		'O'+80H,"UT"
01:8D39 5554
01:8D3B CF              	   321: 	db		'O'+80H,"N"
01:8D3C 4E
01:8D3D CE              	   322: 	db		'N'+80H,"ULL"
01:8D3E 554C4C
01:8D41 D7              	   323: 	db		'W'+80H,"AIT"
01:8D42 414954
01:8D45 C4              	   324: 	db		'D'+80H,"EF"
01:8D46 4546
01:8D48 D0              	   325: 	db		'P'+80H,"OKE"
01:8D49 4F4B45
01:8D4C C4              	   326: 	db		'D'+80H,"OKE"
01:8D4D 4F4B45
01:8D50 D3              	   327: 	db		'S'+80H,"CREEN"
01:8D51 435245454E
01:8D56 CC              	   328: 	db		'L'+80H,"INES"
01:8D57 494E4553
01:8D5B C3              	   329: 	db		'C'+80H,"LS"
01:8D5C 4C53
01:8D5E D7              	   330: 	db		'W'+80H,"IDTH"
01:8D5F 49445448
01:8D63 CD              	   331: 	db		'M'+80H,"ONITOR"
01:8D64 4F4E49544F52
01:8D6A D3              	   332: 	db		'S'+80H,"ET"
01:8D6B 4554
01:8D6D D2              	   333: 	db		'R'+80H,"ESET"
01:8D6E 45534554
01:8D72 D0              	   334: 	db		'P'+80H,"RINT"
01:8D73 52494E54
01:8D77 C3              	   335: 	db		'C'+80H,"ONT"
01:8D78 4F4E54
01:8D7B CC              	   336: 	db		'L'+80H,"IST"
01:8D7C 495354
01:8D7F C3              	   337: 	db		'C'+80H,"LEAR"
01:8D80 4C454152
01:8D84 C3              	   338: 	db		'C'+80H,"LOAD"
01:8D85 4C4F4144
01:8D89 C3              	   339: 	db		'C'+80H,"SAVE"
01:8D8A 53415645
01:8D8E CE              	   340: 	db		'N'+80H,"EW"
01:8D8F 4557
01:8D91 C5              	   341: 	db		'E'+80H,"XIT"			; Exit BASIC
01:8D92 584954
                        	   342: 	
01:8D95 D4              	   343: 	db		'T'+80H,"AB("
01:8D96 414228
01:8D99 D4              	   344: 	db		'T'+80H,"O"
01:8D9A 4F
01:8D9B C6              	   345: 	db		'F'+80H,"N"
01:8D9C 4E
01:8D9D D3              	   346: 	db		'S'+80H,"PC("
01:8D9E 504328
01:8DA1 D4              	   347: 	db		'T'+80H,"HEN"
01:8DA2 48454E
01:8DA5 CE              	   348: 	db		'N'+80H,"OT"
01:8DA6 4F54
01:8DA8 D3              	   349: 	db		'S'+80H,"TEP"
01:8DA9 544550
                        	   350: 
01:8DAC AB              	   351: 	db		'+'+80H
01:8DAD AD              	   352: 	db		'-'+80H
01:8DAE AA              	   353: 	db		'*'+80H
01:8DAF AF              	   354: 	db		'/'+80H
01:8DB0 DE              	   355: 	db		'^'+80H
01:8DB1 C1              	   356: 	db		'A'+80H,"ND"
01:8DB2 4E44
01:8DB4 CF              	   357: 	db		'O'+80H,"R"
01:8DB5 52
01:8DB6 BE              	   358: 	db		'>'+80H
01:8DB7 BD              	   359: 	db		'='+80H
01:8DB8 BC              	   360: 	db		'<'+80H
                        	   361: 
01:8DB9 D3              	   362: 	db		'S'+80H,"GN"
01:8DBA 474E
01:8DBC C9              	   363: 	db		'I'+80H,"NT"
01:8DBD 4E54
01:8DBF C1              	   364: 	db		'A'+80H,"BS"
01:8DC0 4253
01:8DC2 D5              	   365: 	db		'U'+80H,"SR"
01:8DC3 5352
01:8DC5 C6              	   366: 	db		'F'+80H,"RE"
01:8DC6 5245
01:8DC8 C9              	   367: 	db		'I'+80H,"NP"
01:8DC9 4E50
01:8DCB D0              	   368: 	db		'P'+80H,"OS"
01:8DCC 4F53
01:8DCE D3              	   369: 	db		'S'+80H,"QR"
01:8DCF 5152
01:8DD1 D2              	   370: 	db		'R'+80H,"ND"
01:8DD2 4E44
01:8DD4 CC              	   371: 	db		'L'+80H,"OG"
01:8DD5 4F47
01:8DD7 C5              	   372: 	db		'E'+80H,"XP"
01:8DD8 5850
01:8DDA C3              	   373: 	db		'C'+80H,"OS"
01:8DDB 4F53
01:8DDD D3              	   374: 	db		'S'+80H,"IN"
01:8DDE 494E
01:8DE0 D4              	   375: 	db		'T'+80H,"AN"
01:8DE1 414E
01:8DE3 C1              	   376: 	db		'A'+80H,"TN"
01:8DE4 544E
01:8DE6 D0              	   377: 	db		'P'+80H,"EEK"
01:8DE7 45454B
01:8DEA C4              	   378: 	db		'D'+80H,"EEK"
01:8DEB 45454B
01:8DEE D0              	   379: 	db		'P'+80H,"OINT"
01:8DEF 4F494E54
01:8DF3 CC              	   380: 	db		'L'+80H,"EN"
01:8DF4 454E
01:8DF6 D3              	   381: 	db		'S'+80H,"TR$"
01:8DF7 545224
01:8DFA D6              	   382: 	db		'V'+80H,"AL"
01:8DFB 414C
01:8DFD C1              	   383: 	db		'A'+80H,"SC"
01:8DFE 5343
01:8E00 C3              	   384: 	db		'C'+80H,"HR$"
01:8E01 485224
01:8E04 C8              	   385: 	db		'H'+80H,"EX$"
01:8E05 455824
01:8E08 C2              	   386: 	db		'B'+80H,"IN$"
01:8E09 494E24
01:8E0C CC              	   387: 	db		'L'+80H,"EFT$"
01:8E0D 45465424
01:8E11 D2              	   388: 	db		'R'+80H,"IGHT$"
01:8E12 4947485424
01:8E17 CD              	   389: 	db		'M'+80H,"ID$"
01:8E18 494424
                        	   390: 
01:8E1B 80              	   391: 	db		80H				; End of list marker
                        	   392: 
                        	   393: ; KEYWORD ADDRESS TABLE
                        	   394: 
                        	   395: WORDTB:
01:8E1C 1B94            	   396: 	dw		PEND
01:8E1E 1593            	   397: 	dw		FOR
01:8E20 EC97            	   398: 	dw		NEXT
01:8E22 6895            	   399: 	dw		DATAA
01:8E24 F396            	   400: 	dw		INPUT
01:8E26 289A            	   401: 	dw		DIM
01:8E28 2297            	   402: 	dw		READ
01:8E2A 7F95            	   403: 	dw		LET
01:8E2C 2595            	   404: 	dw		GOTO
01:8E2E 0895            	   405: 	dw		RUN
01:8E30 F795            	   406: 	dw		IFF
01:8E32 DE93            	   407: 	dw		RESTOR
01:8E34 1495            	   408: 	dw		GOSUB
01:8E36 4395            	   409: 	dw		RETURN
01:8E38 6A95            	   410: 	dw		REM
01:8E3A 1994            	   411: 	dw		STOPP
01:8E3C 619F            	   412: 	dw		POUT
01:8E3E D995            	   413: 	dw		ON
01:8E40 5A94            	   414: 	dw		NULLL
01:8E42 679F            	   415: 	dw		WAIT
01:8E44 069C            	   416: 	dw		DEF
01:8E46 B09F            	   417: 	dw		POKE
01:8E48 F8A6            	   418: 	dw		DOKE
01:8E4A 6A95            	   419: 	dw		REM
01:8E4C DEA6            	   420: 	dw		LINES
01:8E4E D3A6            	   421: 	dw		CLS
01:8E50 D6A6            	   422: 	dw		WIDTH
01:8E52 12A8            	   423: 	dw		MONITR
01:8E54 5410            	   424: 	dw		PSET
01:8E56 5710            	   425: 	dw		RESET
01:8E58 1B96            	   426: 	dw		PRINTT
01:8E5A 4794            	   427: 	dw		CONT
01:8E5C 8A92            	   428: 	dw		LISTT
01:8E5E C294            	   429: 	dw		CLEAR
01:8E60 6A95            	   430: 	dw		REM
01:8E62 6A95            	   431: 	dw		REM
01:8E64 8290            	   432: 	dw		NEW
01:8E66 2CA8            	   433: 	dw		EXIT					; Exit BASIC
                        	   434: 
                        	   435: ; RESERVED WORD TOKEN VALUES
                        	   436: 
                        	   437: ZEND	.EQU	080H			; END
                        	   438: ZFOR	.EQU	081H			; FOR
                        	   439: ZDATA	.EQU	083H			; DATA
                        	   440: ZGOTO	.EQU	088H			; GOTO
                        	   441: ZGOSUB	.EQU	08CH			; GOSUB
                        	   442: ZREM	.EQU	08EH			; REM
                        	   443: ZPRINT	.EQU	09EH			; PRINT
                        	   444: ZNEW	.EQU	0A4H			; NEW
                        	   445: 
                        	   446: ZTAB	.EQU	0A5H			; TAB
                        	   447: ZTO		.EQU	0A6H			; TO
                        	   448: ZFN		.EQU	0A7H			; FN
                        	   449: ZSPC	.EQU	0A8H			; SPC
                        	   450: ZTHEN	.EQU	0A9H			; THEN
                        	   451: ZNOT	.EQU	0AAH			; NOT
                        	   452: ZSTEP	.EQU	0ABH			; STEP
                        	   453: 
                        	   454: ZPLUS	.EQU	0ACH			; +
                        	   455: ZMINUS	.EQU	0ADH			; -
                        	   456: ZTIMES	.EQU	0AEH			; *
                        	   457: ZDIV	.EQU	0AFH			; /
                        	   458: ZOR		.EQU	0B2H			; OR
                        	   459: ZGTR	.EQU	0B3H			; >
                        	   460: ZEQUAL	.EQU	0B4H			; M
                        	   461: ZLTH	.EQU	0B5H			; <
                        	   462: ZSGN	.EQU	0B6H			; SGN
                        	   463: ZPOINT	.EQU	0C7H			; POINT
                        	   464: ZLEFT	.EQU	0CDH +2			; LEFT$
                        	   465: 
                        	   466: ; ARITHMETIC PRECEDENCE TABLE
                        	   467: 
01:8E68 79              	   468: PRITAB: db		79H				; Precedence value
01:8E69 9AA3            	   469: 		dw		PADD			; FPREG = <last> + FPREG
                        	   470: 
01:8E6B 79              	   471: 		db		79H				; Precedence value
01:8E6C CE9F            	   472: 		dw		PSUB			; FPREG = <last> - FPREG
                        	   473: 
01:8E6E 7C              	   474: 		db		7CH				; Precedence value
01:8E6F 0CA1            	   475: 		dw		MULTT			; PPREG = <last> * FPREG
                        	   476: 
01:8E71 7C              	   477: 		db		7CH				; Precedence value
01:8E72 6DA1            	   478: 		dw		DIV				; FPREG = <last> / FPREG
                        	   479: 
01:8E74 7F              	   480: 		db		7FH				; Precedence value
01:8E75 BBA4            	   481: 		dw		POWER			; FPREG = <last> ^ FPREG
                        	   482: 
01:8E77 50              	   483: 		db		50H				; Precedence value
01:8E78 8199            	   484: 		dw		PAND			; FPREG = <last> AND FPREG
                        	   485: 
01:8E7A 46              	   486: 		db		46H				; Precedence value
01:8E7B 8099            	   487: 		dw		POR				; FPREG = <last> OR FPREG
                        	   488: 
                        	   489: ; BASIC ERROR CODE LIST
                        	   490: 
01:8E7D 4E46            	   491: ERRORS: db		"NF"			; NEXT without FOR
01:8E7F 534E            	   492: 		db		"SN"			; Syntax error
01:8E81 5247            	   493: 		db		"RG"			; RETURN without GOSUB
01:8E83 4F44            	   494: 		db		"OD"			; Out of DATA
01:8E85 4643            	   495: 		db		"FC"			; Illegal function call
01:8E87 4F56            	   496: 		db		"OV"			; Overflow error
01:8E89 4F4D            	   497: 		db		"OM"			; Out of memory
01:8E8B 554C            	   498: 		db		"UL"			; Undefined line
01:8E8D 4253            	   499: 		db		"BS"			; Bad subscript
01:8E8F 4444            	   500: 		db		"DD"			; Re-DIMensioned array
01:8E91 2F30            	   501: 		db		"/0"			; Division by zero
01:8E93 4944            	   502: 		db		"ID"			; Illegal direct
01:8E95 544D            	   503: 		db		"TM"			; Type mis-match
01:8E97 4F53            	   504: 		db		"OS"			; Out of string space
01:8E99 4C53            	   505: 		db		"LS"			; String too long
01:8E9B 5354            	   506: 		db		"ST"			; String formula too complex
01:8E9D 434E            	   507: 		db		"CN"			; Can't CONTinue
01:8E9F 5546            	   508: 		db		"UF"			; Undefined FN function
01:8EA1 4D4F            	   509: 		db		"MO"			; Missing operand
01:8EA3 4858            	   510: 		db		"HX"			; HEX error
01:8EA5 424E            	   511: 		db		"BN"			; BIN error
                        	   512: 
                        	   513: ; INITIALISATION TABLE -------------------------------------------------------
                        	   514: 
01:8EA7 C3688C          	   515: INITAB: JP		WARM			; Warm start jump
01:8EAA C39894          	   516: 		JP		FCERR			; "USR (X)" jump (Set to Error)
01:8EAD D300            	   517: 		OUT		(0),A			; "OUT p,n" skeleton
01:8EAF C9              	   518: 		RET
01:8EB0 D600            	   519: 		SUB		0				; Division support routine
01:8EB2 6F              	   520: 		LD		L,A
01:8EB3 7C              	   521: 		LD		A,H
01:8EB4 DE00            	   522: 		SBC		A,0
01:8EB6 67              	   523: 		LD		H,A
01:8EB7 78              	   524: 		LD		A,B
01:8EB8 DE00            	   525: 		SBC		A,0
01:8EBA 47              	   526: 		LD		B,A
01:8EBB 3E00            	   527: 		LD		A,0
01:8EBD C9              	   528: 		RET
01:8EBE 00              	   529: 		db		0,0,0					; Random number seed table used by RND
01:8EBF 00
01:8EC0 00
01:8EC1 35              	   530: 		db		035H,04AH,0CAH,099H		;-2.65145E+07
01:8EC2 4A
01:8EC3 CA
01:8EC4 99
01:8EC5 39              	   531: 		db		039H,01CH,076H,098H		; 1.61291E+07
01:8EC6 1C
01:8EC7 76
01:8EC8 98
01:8EC9 22              	   532: 		db		022H,095H,0B3H,098H		;-1.17691E+07
01:8ECA 95
01:8ECB B3
01:8ECC 98
01:8ECD 0A              	   533: 		db		00AH,0DDH,047H,098H		; 1.30983E+07
01:8ECE DD
01:8ECF 47
01:8ED0 98
01:8ED1 53              	   534: 		db		053H,0D1H,099H,099H		;-2-01612E+07
01:8ED2 D1
01:8ED3 99
01:8ED4 99
01:8ED5 0A              	   535: 		db		00AH,01AH,09FH,098H		;-1.04269E+07
01:8ED6 1A
01:8ED7 9F
01:8ED8 98
01:8ED9 65              	   536: 		db		065H,0BCH,0CDH,098H		;-1.34831E+07
01:8EDA BC
01:8EDB CD
01:8EDC 98
01:8EDD D6              	   537: 		db		0D6H,077H,03EH,098H		; 1.24825E+07
01:8EDE 77
01:8EDF 3E
01:8EE0 98
01:8EE1 52              	   538: 		db		052H,0C7H,04FH,080H		; Last random number
01:8EE2 C7
01:8EE3 4F
01:8EE4 80
01:8EE5 DB00            	   539: 		IN		A,(0)			; INP (x) skeleton
01:8EE7 C9              	   540: 		RET
01:8EE8 01              	   541: 		db		1				; POS (x) number (1)
01:8EE9 FF              	   542: 		db		255				; Terminal width (255 = no auto CRLF)
01:8EEA 1C              	   543: 		db		28				; Width for commas (3 columns)
01:8EEB 00              	   544: 		db		0				; No nulls after input bytes
01:8EEC 00              	   545: 		db		0				; Output enabled (^O off)
01:8EED 1400            	   546: 		dw		20				; Initial lines counter
01:8EEF 1400            	   547: 		dw		20				; Initial lines number
01:8EF1 0000            	   548: 		dw		0				; Array load/save check sum
01:8EF3 00              	   549: 		db		0				; Break not by NMI
01:8EF4 00              	   550: 		db		0				; Break flag
01:8EF5 C3BB91          	   551: 		JP		TTYLIN			; Input reflection (set to TTY)
01:8EF8 C30000          	   552: 		JP		$0000			; POINT reflection unused
01:8EFB C30000          	   553: 		JP		$0000			; SET reflection
01:8EFE C30000          	   554: 		JP		$0000			; RESET reflection
01:8F01 5D11            	   555: 		dw		STLOOK			; Temp string space
01:8F03 FEFF            	   556: 		dw		-2				; Current line number (cold)
01:8F05 FA10            	   557: 		dw		PROGST+1		; Start of program text
                        	   558: INITBE:							
                        	   559: 
                        	   560: ; END OF INITIALISATION TABLE ---------------------------------------------------
                        	   561: 
01:8F07 204572726F72    	   562: ERRMSG: db	" Error",0
01:8F0D 00
01:8F0E 20696E20        	   563: INMSG:	db	" in ",0
01:8F12 00
                        	   564: ZERBYT	.EQU	$-1				; A zero byte
01:8F13 4F6B            	   565: OKMSG:	db	"Ok",CR,LF,0,0
01:8F15 0D
01:8F16 0A
01:8F17 00
01:8F18 00
01:8F19 427265616B      	   566: BRKMSG: db	"Break",0
01:8F1E 00
                        	   567: 
01:8F1F 210400          	   568: BAKSTK: LD		HL,4			; Look for "FOR" block with
01:8F22 39              	   569: 		ADD		HL,SP			; same index as specified
01:8F23 7E              	   570: LOKFOR: LD		A,(HL)			; Get block ID
01:8F24 23              	   571: 		INC		HL				; Point to index address
01:8F25 FE81            	   572: 		CP		ZFOR			; Is it a "FOR" token
01:8F27 C0              	   573: 		RET		NZ				; No - exit
01:8F28 4E              	   574: 		LD		C,(HL)			; BC = Address of "FOR" index
01:8F29 23              	   575: 		INC		HL
01:8F2A 46              	   576: 		LD		B,(HL)
01:8F2B 23              	   577: 		INC		HL				; Point to sign of STEP
01:8F2C E5              	   578: 		PUSH	HL				; Save pointer to sign
01:8F2D 69              	   579: 		LD		L,C				; HL = address of "FOR" index
01:8F2E 60              	   580: 		LD		H,B
01:8F2F 7A              	   581: 		LD		A,D				; See if an index was specified
01:8F30 B3              	   582: 		OR		E				; DE = 0 if no index specified
01:8F31 EB              	   583: 		EX		DE,HL			; Specified index into HL
01:8F32 CA398F          	   584: 		JP		Z,INDFND		; Skip if no index given
01:8F35 EB              	   585: 		EX		DE,HL			; Index back into DE
01:8F36 CD3E92          	   586: 		CALL	CPDEHL			; Compare index with one given
01:8F39 010D00          	   587: INDFND: LD		BC,16-3			; Offset to next block
01:8F3C E1              	   588: 		POP		HL				; Restore pointer to sign
01:8F3D C8              	   589: 		RET		Z				; Return if block found
01:8F3E 09              	   590: 		ADD		HL,BC			; Point to next block
01:8F3F C3238F          	   591: 		JP		LOKFOR			; Keep on looking
                        	   592: 
01:8F42 CD5C8F          	   593: MOVUP:	CALL	ENFMEM			; See if enough memory
01:8F45 C5              	   594: MOVSTR: PUSH	BC				; Save end of source
01:8F46 E3              	   595: 		EX		(SP),HL			; Swap source and dest" end
01:8F47 C1              	   596: 		POP		BC				; Get end of destination
01:8F48 CD3E92          	   597: MOVLP:	CALL	CPDEHL			; See if list moved
01:8F4B 7E              	   598: 		LD		A,(HL)			; Get byte
01:8F4C 02              	   599: 		LD		(BC),A			; Move it
01:8F4D C8              	   600: 		RET		Z				; Exit if all done
01:8F4E 0B              	   601: 		DEC		BC				; Next byte to move to
01:8F4F 2B              	   602: 		DEC		HL				; Next byte to move
01:8F50 C3488F          	   603: 		JP		MOVLP			; Loop until all bytes moved
                        	   604: 
01:8F53 E5              	   605: CHKSTK: PUSH	HL				; Save code string address
01:8F54 2ADA10          	   606: 		LD		HL,(ARREND)		; Lowest free memory
01:8F57 0600            	   607: 		LD		B,0				; BC = Number of levels to test
01:8F59 09              	   608: 		ADD		HL,BC			; 2 Bytes for each level
01:8F5A 09              	   609: 		ADD		HL,BC
01:8F5B 3E              	   610: 		db	3EH				; Skip "PUSH HL"
01:8F5C E5              	   611: ENFMEM: PUSH	HL				; Save code string address
01:8F5D 3ED0            	   612: 		LD		A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
01:8F5F 95              	   613: 		SUB		L
01:8F60 6F              	   614: 		LD		L,A
01:8F61 3EFF            	   615: 		LD		A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
01:8F63 9C              	   616: 		SBC		A,H
01:8F64 DA6B8F          	   617: 		JP		C,OMERR			; Not enough - ?OM Error
01:8F67 67              	   618: 		LD		H,A
01:8F68 39              	   619: 		ADD		HL,SP			; Test if stack is overflowed
01:8F69 E1              	   620: 		POP		HL				; Restore code string address
01:8F6A D8              	   621: 		RET		C				; Return if enough mmory
01:8F6B 1E0C            	   622: OMERR:	LD		E,OM			; ?OM Error
01:8F6D C38A8F          	   623: 		JP		ERROR
                        	   624: 
01:8F70 2AC910          	   625: DATSNR: LD		HL,(DATLIN)		; Get line of current DATA item
01:8F73 225C10          	   626: 		LD		(LINEAT),HL		; Save as current line
01:8F76 1E02            	   627: SNERR:	LD		E,SN			; ?SN Error
01:8F78 01              	   628: 		db		01H				; Skip "LD E,DZ"
01:8F79 1E14            	   629: DZERR:	LD		E,DZ			; ?/0 Error
01:8F7B 01              	   630: 		db		01H				; Skip "LD E,NF"
01:8F7C 1E00            	   631: NFERR:	LD		E,NF			; ?NF Error
01:8F7E 01              	   632: 		db		01H				; Skip "LD E,DD"
01:8F7F 1E12            	   633: DDERR:	LD		E,DD			; ?DD Error
01:8F81 01              	   634: 		db		01H				; Skip "LD E,UF"
01:8F82 1E22            	   635: UFERR:	LD		E,UF			; ?UF Error
01:8F84 01              	   636: 		db		01H				; Skip "LD E,OV
01:8F85 1E0A            	   637: OVERR:	LD		E,OV			; ?OV Error
01:8F87 01              	   638: 		db		01H				; Skip "LD E,TM"
01:8F88 1E18            	   639: TMERR:	LD		E,TM			; ?TM Error
                        	   640: 
01:8F8A CDA890          	   641: ERROR:	CALL	CLREG			; Clear registers and stack
01:8F8D 324510          	   642: 		LD		(CTLOFG),A		; Enable output (A is 0)
01:8F90 CD6C96          	   643: 		CALL	STTLIN			; Start new line
01:8F93 217D8E          	   644: 		LD		HL,ERRORS		; Point to error codes
01:8F96 57              	   645: 		LD		D,A				; D = 0 (A is 0)
01:8F97 3E3F            	   646: 		LD		A,'?'
01:8F99 CD4F92          	   647: 		CALL	OUTC			; Output '?'
01:8F9C 19              	   648: 		ADD		HL,DE			; Offset to correct error code
01:8F9D 7E              	   649: 		LD		A,(HL)			; First character
01:8F9E CD4F92          	   650: 		CALL	OUTC			; Output it
01:8FA1 CDCE93          	   651: 		CALL	GETCHR			; Get next character
01:8FA4 CD4F92          	   652: 		CALL	OUTC			; Output it
01:8FA7 21078F          	   653: 		LD		HL,ERRMSG		; "Error" message
01:8FAA CD109D          	   654: ERRIN:	CALL	PRS				; Output message
01:8FAD 2A5C10          	   655: 		LD		HL,(LINEAT)		; Get line of error
01:8FB0 11FEFF          	   656: 		LD		DE,-2			; Cold start error if -2
01:8FB3 CD3E92          	   657: 		CALL	CPDEHL			; See if cold start error
01:8FB6 CAD58B          	   658: 		JP		Z,CSTART		; Cold start error - Restart
01:8FB9 7C              	   659: 		LD		A,H				; Was it a direct error?
01:8FBA A5              	   660: 		AND		L				; Line = -1 if direct error
01:8FBB 3C              	   661: 		INC		A
01:8FBC C4ABA3          	   662: 		CALL	NZ,LINEIN		; No - output line of error
01:8FBF 3E              	   663: 		db		3EH				; Skip "POP BC"
01:8FC0 C1              	   664: POPNOK: POP		BC				; Drop address in input buffer
                        	   665: 
01:8FC1 AF              	   666: PRNTOK: XOR		A				; Output "Ok" and get command
01:8FC2 324510          	   667: 		LD		(CTLOFG),A		; Enable output
01:8FC5 CD6C96          	   668: 		CALL	STTLIN			; Start new line
01:8FC8 21138F          	   669: 		LD		HL,OKMSG		; "Ok" message
01:8FCB CD109D          	   670: 		CALL	PRS				; Output "Ok"
01:8FCE 21FFFF          	   671: GETCMD: LD		HL,-1			; Flag direct mode
01:8FD1 225C10          	   672: 		LD		(LINEAT),HL		; Save as current line
01:8FD4 CDBB91          	   673: 		CALL	GETLIN			; Get an input line
01:8FD7 DACE8F          	   674: 		JP		C,GETCMD		; Get line again if break
01:8FDA CDCE93          	   675: 		CALL	GETCHR			; Get first character
01:8FDD 3C              	   676: 		INC		A				; Test if end of line
01:8FDE 3D              	   677: 		DEC		A				; Without affecting Carry
01:8FDF CACE8F          	   678: 		JP		Z,GETCMD		; Nothing entered - Get another
01:8FE2 F5              	   679: 		PUSH	AF				; Save Carry status
01:8FE3 CD9D94          	   680: 		CALL	ATOH			; Get line number into DE
01:8FE6 D5              	   681: 		PUSH	DE				; Save line number
01:8FE7 CDD290          	   682: 		CALL	CRUNCH			; Tokenise rest of line
01:8FEA 47              	   683: 		LD		B,A				; Length of tokenised line
01:8FEB D1              	   684: 		POP		DE				; Restore line number
01:8FEC F1              	   685: 		POP		AF				; Restore Carry
01:8FED D2AE93          	   686: 		JP		NC,EXCUTE		; No line number - Direct mode
01:8FF0 D5              	   687: 		PUSH	DE				; Save line number
01:8FF1 C5              	   688: 		PUSH	BC				; Save length of tokenised line
01:8FF2 AF              	   689: 		XOR		A
01:8FF3 32CC10          	   690: 		LD		(LSTBIN),A		; Clear last byte input
01:8FF6 CDCE93          	   691: 		CALL	GETCHR			; Get next character
01:8FF9 B7              	   692: 		OR		A				; Set flags
01:8FFA F5              	   693: 		PUSH	AF				; And save them
01:8FFB CD6290          	   694: 		CALL	SRCHLN			; Search for line number in DE
01:8FFE DA0790          	   695: 		JP		C,LINFND		; Jump if line found
01:9001 F1              	   696: 		POP		AF				; Get status
01:9002 F5              	   697: 		PUSH	AF				; And re-save
01:9003 CA3E95          	   698: 		JP		Z,ULERR			; Nothing after number - Error
01:9006 B7              	   699: 		OR		A				; Clear Carry
01:9007 C5              	   700: LINFND: PUSH	BC				; Save address of line in prog
01:9008 D21E90          	   701: 		JP		NC,INEWLN		; Line not found - Insert new
01:900B EB              	   702: 		EX		DE,HL			; Next line address in DE
01:900C 2AD610          	   703: 		LD		HL,(PROGND)		; End of program
01:900F 1A              	   704: SFTPRG: LD		A,(DE)			; Shift rest of program down
01:9010 02              	   705: 		LD		(BC),A
01:9011 03              	   706: 		INC		BC				; Next destination
01:9012 13              	   707: 		INC		DE				; Next source
01:9013 CD3E92          	   708: 		CALL	CPDEHL			; All done?
01:9016 C20F90          	   709: 		JP		NZ,SFTPRG		; More to do
01:9019 60              	   710: 		LD		H,B				; HL - New end of program
01:901A 69              	   711: 		LD		L,C
01:901B 22D610          	   712: 		LD		(PROGND),HL		; Update end of program
                        	   713: 
01:901E D1              	   714: INEWLN: POP		DE				; Get address of line,
01:901F F1              	   715: 		POP		AF				; Get status
01:9020 CA4590          	   716: 		JP		Z,SETPTR		; No text - Set up pointers
01:9023 2AD610          	   717: 		LD		HL,(PROGND)		; Get end of program
01:9026 E3              	   718: 		EX		(SP),HL			; Get length of input line
01:9027 C1              	   719: 		POP		BC				; End of program to BC
01:9028 09              	   720: 		ADD		HL,BC			; Find new end
01:9029 E5              	   721: 		PUSH	HL				; Save new end
01:902A CD428F          	   722: 		CALL	MOVUP			; Make space for line
01:902D E1              	   723: 		POP		HL				; Restore new end
01:902E 22D610          	   724: 		LD		(PROGND),HL		; Update end of program pointer
01:9031 EB              	   725: 		EX		DE,HL			; Get line to move up in HL
01:9032 74              	   726: 		LD		(HL),H			; Save MSB
01:9033 D1              	   727: 		POP		DE				; Get new line number
01:9034 23              	   728: 		INC		HL				; Skip pointer
01:9035 23              	   729: 		INC		HL
01:9036 73              	   730: 		LD		(HL),E			; Save LSB of line number
01:9037 23              	   731: 		INC		HL
01:9038 72              	   732: 		LD		(HL),D			; Save MSB of line number
01:9039 23              	   733: 		INC		HL				; To first byte in line
01:903A 116110          	   734: 		LD		DE,BUFFER		; Copy buffer to program
01:903D 1A              	   735: MOVBUF: LD		A,(DE)			; Get source
01:903E 77              	   736: 		LD		(HL),A			; Save destinations
01:903F 23              	   737: 		INC		HL				; Next source
01:9040 13              	   738: 		INC		DE				; Next destination
01:9041 B7              	   739: 		OR		A				; Done?
01:9042 C23D90          	   740: 		JP		NZ,MOVBUF		; No - Repeat
01:9045 CD8E90          	   741: SETPTR: CALL	RUNFST			; Set line pointers
01:9048 23              	   742: 		INC		HL				; To LSB of pointer
01:9049 EB              	   743: 		EX		DE,HL			; Address to DE
01:904A 62              	   744: PTRLP:	LD		H,D				; Address to HL
01:904B 6B              	   745: 		LD		L,E
01:904C 7E              	   746: 		LD		A,(HL)			; Get LSB of pointer
01:904D 23              	   747: 		INC		HL				; To MSB of pointer
01:904E B6              	   748: 		OR		(HL)			; Compare with MSB pointer
01:904F CACE8F          	   749: 		JP		Z,GETCMD		; Get command line if end
01:9052 23              	   750: 		INC		HL				; To LSB of line number
01:9053 23              	   751: 		INC		HL				; Skip line number
01:9054 23              	   752: 		INC		HL				; Point to first byte in line
01:9055 AF              	   753: 		XOR		A				; Looking for 00 byte
01:9056 BE              	   754: FNDEND: CP		(HL)			; Found end of line?
01:9057 23              	   755: 		INC		HL				; Move to next byte
01:9058 C25690          	   756: 		JP		NZ,FNDEND		; No - Keep looking
01:905B EB              	   757: 		EX		DE,HL			; Next line address to HL
01:905C 73              	   758: 		LD		(HL),E			; Save LSB of pointer
01:905D 23              	   759: 		INC		HL
01:905E 72              	   760: 		LD		(HL),D			; Save MSB of pointer
01:905F C34A90          	   761: 		JP		PTRLP			; Do next line
                        	   762: 
01:9062 2A5E10          	   763: SRCHLN: LD		HL,(BASTXT)		; Start of program text
01:9065 44              	   764: SRCHLP: LD		B,H				; BC = Address to look at
01:9066 4D              	   765: 		LD		C,L
01:9067 7E              	   766: 		LD		A,(HL)			; Get address of next line
01:9068 23              	   767: 		INC		HL
01:9069 B6              	   768: 		OR		(HL)			; End of program found?
01:906A 2B              	   769: 		DEC		HL
01:906B C8              	   770: 		RET		Z				; Yes - Line not found
01:906C 23              	   771: 		INC		HL
01:906D 23              	   772: 		INC		HL
01:906E 7E              	   773: 		LD		A,(HL)			; Get LSB of line number
01:906F 23              	   774: 		INC		HL
01:9070 66              	   775: 		LD		H,(HL)			; Get MSB of line number
01:9071 6F              	   776: 		LD		L,A
01:9072 CD3E92          	   777: 		CALL	CPDEHL			; Compare with line in DE
01:9075 60              	   778: 		LD		H,B				; HL = Start of this line
01:9076 69              	   779: 		LD		L,C
01:9077 7E              	   780: 		LD		A,(HL)			; Get LSB of next line address
01:9078 23              	   781: 		INC		HL
01:9079 66              	   782: 		LD		H,(HL)			; Get MSB of next line address
01:907A 6F              	   783: 		LD		L,A				; Next line to HL
01:907B 3F              	   784: 		CCF
01:907C C8              	   785: 		RET		Z				; Lines found - Exit
01:907D 3F              	   786: 		CCF
01:907E D0              	   787: 		RET		NC				; Line not found,at line after
01:907F C36590          	   788: 		JP		SRCHLP			; Keep looking
                        	   789: 
01:9082 C0              	   790: NEW:	RET		NZ				; Return if any more on line
01:9083 2A5E10          	   791: CLRPTR: LD		HL,(BASTXT)		; Point to start of program
01:9086 AF              	   792: 		XOR		A				; Set program area to empty
01:9087 77              	   793: 		LD		(HL),A			; Save LSB = 00
01:9088 23              	   794: 		INC		HL
01:9089 77              	   795: 		LD		(HL),A			; Save MSB = 00
01:908A 23              	   796: 		INC		HL
01:908B 22D610          	   797: 		LD		(PROGND),HL		; Set program end
                        	   798: 
01:908E 2A5E10          	   799: RUNFST: LD		HL,(BASTXT)		; Clear all variables
01:9091 2B              	   800: 		DEC		HL
                        	   801: 
01:9092 22CE10          	   802: INTVAR: LD		(BRKLIN),HL		; Initialise RUN variables
01:9095 2AAF10          	   803: 		LD		HL,(LSTRAM)		; Get end of RAM
01:9098 22C310          	   804: 		LD		(STRBOT),HL		; Clear string space
01:909B AF              	   805: 		XOR		A
01:909C CDDE93          	   806: 		CALL	RESTOR			; Reset DATA pointers
01:909F 2AD610          	   807: 		LD		HL,(PROGND)		; Get end of program
01:90A2 22D810          	   808: 		LD		(VAREND),HL		; Clear variables
01:90A5 22DA10          	   809: 		LD		(ARREND),HL		; Clear arrays
                        	   810: 
01:90A8 C1              	   811: CLREG:	POP		BC				; Save return address
01:90A9 2A5A10          	   812: 		LD		HL,(STRSPC)		; Get end of working RAN
01:90AC F9              	   813: 		LD		SP,HL			; Set stack
01:90AD 21B310          	   814: 		LD		HL,TMSTPL		; Temporary string pool
01:90B0 22B110          	   815: 		LD		(TMSTPT),HL		; Reset temporary string ptr
01:90B3 AF              	   816: 		XOR		A				; A = 00
01:90B4 6F              	   817: 		LD		L,A				; HL = 0000
01:90B5 67              	   818: 		LD		H,A
01:90B6 22D410          	   819: 		LD		(CONTAD),HL		; No CONTinue
01:90B9 32CB10          	   820: 		LD		(FORFLG),A		; Clear FOR flag
01:90BC 22DE10          	   821: 		LD		(FNRGNM),HL		; Clear FN argument
01:90BF E5              	   822: 		PUSH	HL				; HL = 0000
01:90C0 C5              	   823: 		PUSH	BC				; Put back return
01:90C1 2ACE10          	   824: DOAGN:	LD		HL,(BRKLIN)		; Get address of code to RUN
01:90C4 C9              	   825: 		RET						; Return to execution driver
                        	   826: 
01:90C5 3E3F            	   827: PROMPT: LD		A,'?'			; '?'
01:90C7 CD4F92          	   828: 		CALL	OUTC			; Output character
01:90CA 3E20            	   829: 		LD		A,' '			; Space
01:90CC CD4F92          	   830: 		CALL	OUTC			; Output character
01:90CF C34E10          	   831: 		JP		RINPUT			; Get input line
                        	   832: 
01:90D2 AF              	   833: CRUNCH: XOR		A				; Tokenise line @ HL to BUFFER
01:90D3 32AE10          	   834: 		LD		(DATFLG),A		; Reset literal flag
01:90D6 0E05            	   835: 		LD		C,2+3			; 2 byte number and 3 nulls
01:90D8 116110          	   836: 		LD		DE,BUFFER		; Start of input buffer
01:90DB 7E              	   837: CRNCLP: LD		A,(HL)			; Get byte
01:90DC FE20            	   838: 		CP		' '				; Is it a space?
01:90DE CA5A91          	   839: 		JP		Z,MOVDIR		; Yes - Copy direct
01:90E1 47              	   840: 		LD		B,A				; Save character
01:90E2 FE22            	   841: 		CP		'"'				; Is it a quote?"
01:90E4 CA7A91          	   842: 		JP		Z,CPYLIT		; Yes - Copy literal string
01:90E7 B7              	   843: 		OR		A				; Is it end of buffer?
01:90E8 CA8191          	   844: 		JP		Z,ENDBUF		; Yes - End buffer
01:90EB 3AAE10          	   845: 		LD		A,(DATFLG)		; Get data type
01:90EE B7              	   846: 		OR		A				; Literal?
01:90EF 7E              	   847: 		LD		A,(HL)			; Get byte to copy
01:90F0 C25A91          	   848: 		JP		NZ,MOVDIR		; Literal - Copy direct
01:90F3 FE3F            	   849: 		CP		'?'				; Is it '?' short for PRINT
01:90F5 3E9E            	   850: 		LD		A,ZPRINT		; "PRINT" token
01:90F7 CA5A91          	   851: 		JP		Z,MOVDIR		; Yes - replace it
01:90FA 7E              	   852: 		LD		A,(HL)			; Get byte again
01:90FB FE30            	   853: 		CP		'0'				; Is it less than '0'
01:90FD DA0591          	   854: 		JP		C,FNDWRD		; Yes - Look for reserved words
01:9100 FE3C            	   855: 		CP		60; ";"+1			; Is it "0123456789:;" ?
01:9102 DA5A91          	   856: 		JP		C,MOVDIR		; Yes - copy it direct
01:9105 D5              	   857: FNDWRD: PUSH	DE				; Look for reserved words
01:9106 11F88C          	   858: 		LD		DE,WORDS-1		; Point to table
01:9109 C5              	   859: 		PUSH	BC				; Save count
01:910A 015691          	   860: 		LD		BC,RETNAD		; Where to return to
01:910D C5              	   861: 		PUSH	BC				; Save return address
01:910E 067F            	   862: 		LD		B,ZEND-1		; First token value -1
01:9110 7E              	   863: 		LD		A,(HL)			; Get byte
01:9111 FE61            	   864: 		CP		'a'				; Less than 'a' ?
01:9113 DA1E91          	   865: 		JP		C,SEARCH		; Yes - search for words
01:9116 FE7B            	   866: 		CP		'z'+1			; Greater than 'z' ?
01:9118 D21E91          	   867: 		JP		NC,SEARCH		; Yes - search for words
01:911B E65F            	   868: 		AND		01011111B		; Force upper case
01:911D 77              	   869: 		LD		(HL),A			; Replace byte
01:911E 4E              	   870: SEARCH: LD		C,(HL)			; Search for a word
01:911F EB              	   871: 		EX		DE,HL
01:9120 23              	   872: GETNXT: INC		HL				; Get next reserved word
01:9121 B6              	   873: 		OR		(HL)			; Start of word?
01:9122 F22091          	   874: 		JP		P,GETNXT		; No - move on
01:9125 04              	   875: 		INC		B				; Increment token value
01:9126 7E              	   876: 		LD		A, (HL)			; Get byte from table
01:9127 E67F            	   877: 		AND		01111111B		; Strip bit 7
01:9129 C8              	   878: 		RET		Z				; Return if end of list
01:912A B9              	   879: 		CP		C				; Same character as in buffer?
01:912B C22091          	   880: 		JP		NZ,GETNXT		; No - get next word
01:912E EB              	   881: 		EX		DE,HL
01:912F E5              	   882: 		PUSH	HL				; Save start of word
                        	   883: 
01:9130 13              	   884: NXTBYT: INC		DE				; Look through rest of word
01:9131 1A              	   885: 		LD		A,(DE)			; Get byte from table
01:9132 B7              	   886: 		OR		A				; End of word ?
01:9133 FA5291          	   887: 		JP		M,MATCH			; Yes - Match found
01:9136 4F              	   888: 		LD		C,A				; Save it
01:9137 78              	   889: 		LD		A,B				; Get token value
01:9138 FE88            	   890: 		CP		ZGOTO			; Is it "GOTO" token ?
01:913A C24191          	   891: 		JP		NZ,NOSPC		; No - Don't allow spaces
01:913D CDCE93          	   892: 		CALL	GETCHR			; Get next character
01:9140 2B              	   893: 		DEC		HL				; Cancel increment from GETCHR
01:9141 23              	   894: NOSPC:	INC		HL				; Next byte
01:9142 7E              	   895: 		LD		A,(HL)			; Get byte
01:9143 FE61            	   896: 		CP		'a'				; Less than 'a' ?
01:9145 DA4A91          	   897: 		JP		C,NOCHNG		; Yes - don't change
01:9148 E65F            	   898: 		AND		01011111B		; Make upper case
01:914A B9              	   899: NOCHNG: CP		C				; Same as in buffer ?
01:914B CA3091          	   900: 		JP		Z,NXTBYT		; Yes - keep testing
01:914E E1              	   901: 		POP		HL				; Get back start of word
01:914F C31E91          	   902: 		JP		SEARCH			; Look at next word
                        	   903: 
01:9152 48              	   904: MATCH:	LD		C,B				; Word found - Save token value
01:9153 F1              	   905: 		POP		AF				; Throw away return
01:9154 EB              	   906: 		EX		DE,HL
01:9155 C9              	   907: 		RET						; Return to "RETNAD"
01:9156 EB              	   908: RETNAD: EX		DE,HL			; Get address in string
01:9157 79              	   909: 		LD		A,C				; Get token value
01:9158 C1              	   910: 		POP		BC				; Restore buffer length
01:9159 D1              	   911: 		POP		DE				; Get destination address
01:915A 23              	   912: MOVDIR: INC		HL				; Next source in buffer
01:915B 12              	   913: 		LD		(DE),A			; Put byte in buffer
01:915C 13              	   914: 		INC		DE				; Move up buffer
01:915D 0C              	   915: 		INC		C				; Increment length of buffer
01:915E D63A            	   916: 		SUB		':'				; End of statement?
01:9160 CA6891          	   917: 		JP		Z,SETLIT		; Jump if multi-statement line
01:9163 FE49            	   918: 		CP		ZDATA-3AH		; Is it DATA statement ?
01:9165 C26B91          	   919: 		JP		NZ,TSTREM		; No - see if REM
01:9168 32AE10          	   920: SETLIT: LD		(DATFLG),A		; Set literal flag
01:916B D654            	   921: TSTREM: SUB		ZREM-3AH		; Is it REM?
01:916D C2DB90          	   922: 		JP		NZ,CRNCLP		; No - Leave flag
01:9170 47              	   923: 		LD		B,A				; Copy rest of buffer
01:9171 7E              	   924: NXTCHR: LD		A,(HL)			; Get byte
01:9172 B7              	   925: 		OR		A				; End of line ?
01:9173 CA8191          	   926: 		JP		Z,ENDBUF		; Yes - Terminate buffer
01:9176 B8              	   927: 		CP		B				; End of statement ?
01:9177 CA5A91          	   928: 		JP		Z,MOVDIR		; Yes - Get next one
01:917A 23              	   929: CPYLIT: INC		HL				; Move up source string
01:917B 12              	   930: 		LD		(DE),A			; Save in destination
01:917C 0C              	   931: 		INC		C				; Increment length
01:917D 13              	   932: 		INC		DE				; Move up destination
01:917E C37191          	   933: 		JP		NXTCHR			; Repeat
                        	   934: 
01:9181 216010          	   935: ENDBUF: LD		HL,BUFFER-1		; Point to start of buffer
01:9184 12              	   936: 		LD		(DE),A			; Mark end of buffer (A = 00)
01:9185 13              	   937: 		INC		DE
01:9186 12              	   938: 		LD		(DE),A			; A = 00
01:9187 13              	   939: 		INC		DE
01:9188 12              	   940: 		LD		(DE),A			; A = 00
01:9189 C9              	   941: 		RET
                        	   942: 
01:918A 3A4410          	   943: DODEL:	LD		A,(NULFLG)		; Get null flag status
01:918D B7              	   944: 		OR		A				; Is it zero?
01:918E 3E00            	   945: 		LD		A,0				; Zero A - Leave flags
01:9190 324410          	   946: 		LD		(NULFLG),A		; Zero null flag
01:9193 C29E91          	   947: 		JP		NZ,ECHDEL		; Set - Echo it
01:9196 05              	   948: 		DEC		B				; Decrement length
01:9197 CABB91          	   949: 		JP		Z,GETLIN		; Get line again if empty
01:919A CD4F92          	   950: 		CALL	OUTC			; Output null character
01:919D 3E              	   951: 		db	3EH				; Skip "DEC B"
01:919E 05              	   952: ECHDEL: DEC		B				; Count bytes in buffer
01:919F 2B              	   953: 		DEC		HL				; Back space buffer
01:91A0 CAB291          	   954: 		JP		Z,OTKLN			; No buffer - Try again
01:91A3 7E              	   955: 		LD		A,(HL)			; Get deleted byte
01:91A4 CD4F92          	   956: 		CALL	OUTC			; Echo it
01:91A7 C3C491          	   957: 		JP		MORINP			; Get more input
                        	   958: 
01:91AA 05              	   959: DELCHR: DEC		B				; Count bytes in buffer
01:91AB 2B              	   960: 		DEC		HL				; Back space buffer
01:91AC CD4F92          	   961: 		CALL	OUTC			; Output character in A
01:91AF C2C491          	   962: 		JP		NZ,MORINP		; Not end - Get more
01:91B2 CD4F92          	   963: OTKLN:	CALL	OUTC			; Output character in A
01:91B5 CD7F80          	   964: KILIN:	CALL	PrintCRLF		; Output CRLF
01:91B8 C3BB91          	   965: 		JP		TTYLIN			; Get line again
                        	   966: 
                        	   967: GETLIN:
01:91BB 216110          	   968: TTYLIN: LD		HL,BUFFER		; Get a line by character
01:91BE 0601            	   969: 		LD		B,1				; Set buffer as empty
01:91C0 AF              	   970: 		XOR		A
01:91C1 324410          	   971: 		LD		(NULFLG),A		; Clear null flag
01:91C4 CD7992          	   972: MORINP: CALL	CLOTST			; Get character and test ^O
01:91C7 4F              	   973: 		LD		C,A				; Save character in C
01:91C8 FE7F            	   974: 		CP		DEL				; Delete character?
01:91CA CA8A91          	   975: 		JP		Z,DODEL			; Yes - Process it
01:91CD 3A4410          	   976: 		LD		A,(NULFLG)		; Get null flag
01:91D0 B7              	   977: 		OR		A				; Test null flag status
01:91D1 CADD91          	   978: 		JP		Z,PROCES		; Reset - Process character
01:91D4 3E00            	   979: 		LD		A,0				; Set a null
01:91D6 CD4F92          	   980: 		CALL	OUTC			; Output null
01:91D9 AF              	   981: 		XOR		A				; Clear A
01:91DA 324410          	   982: 		LD		(NULFLG),A		; Reset null flag
01:91DD 79              	   983: PROCES: LD		A,C				; Get character
01:91DE FE07            	   984: 		CP		CTRLG			; Bell?
01:91E0 CA2192          	   985: 		JP		Z,PUTCTL		; Yes - Save it
01:91E3 FE03            	   986: 		CP		CTRLC			; Is it control "C"?
01:91E5 CC7F80          	   987: 		CALL	Z,PrintCRLF		; Yes - Output CRLF
01:91E8 37              	   988: 		SCF						; Flag break
01:91E9 C8              	   989: 		RET		Z				; Return if control "C"
01:91EA FE0D            	   990: 		CP		CR				; Is it enter?
01:91EC CA7496          	   991: 		JP		Z,ENDINP		; Yes - Terminate input
01:91EF FE15            	   992: 		CP		CTRLU			; Is it control "U"?
01:91F1 CAB591          	   993: 		JP		Z,KILIN			; Yes - Get another line
01:91F4 FE40            	   994: 		CP		'@'				; Is it "kill line"?
01:91F6 CAB291          	   995: 		JP		Z,OTKLN			; Yes - Kill line
01:91F9 FE5F            	   996: 		CP		'_'				; Is it delete?
01:91FB CAAA91          	   997: 		JP		Z,DELCHR		; Yes - Delete character
01:91FE FE08            	   998: 		CP		BKSP			; Is it backspace?
01:9200 CAAA91          	   999: 		JP		Z,DELCHR		; Yes - Delete character
01:9203 FE12            	  1000: 		CP		CTRLR			; Is it control "R"?
01:9205 C21C92          	  1001: 		JP		NZ,PUTBUF		; No - Put in buffer
01:9208 C5              	  1002: 		PUSH	BC				; Save buffer length
01:9209 D5              	  1003: 		PUSH	DE				; Save DE
01:920A E5              	  1004: 		PUSH	HL				; Save buffer address
01:920B 3600            	  1005: 		LD		(HL),0			; Mark end of buffer
01:920D CD26A8          	  1006: 		CALL	OUTNCR			; Output and do CRLF
01:9210 216110          	  1007: 		LD		HL,BUFFER		; Point to buffer start
01:9213 CD109D          	  1008: 		CALL	PRS				; Output buffer
01:9216 E1              	  1009: 		POP		HL				; Restore buffer address
01:9217 D1              	  1010: 		POP		DE				; Restore DE
01:9218 C1              	  1011: 		POP		BC				; Restore buffer length
01:9219 C3C491          	  1012: 		JP		MORINP			; Get another character
                        	  1013: 
01:921C FE20            	  1014: PUTBUF: CP		' '				; Is it a control code?
01:921E DAC491          	  1015: 		JP		C,MORINP		; Yes - Ignore
01:9221 78              	  1016: PUTCTL: LD		A,B				; Get number of bytes in buffer
01:9222 FE49            	  1017: 		CP		72+1			; Test for line overflow
01:9224 3E07            	  1018: 		LD		A,CTRLG			; Set a bell
01:9226 D23692          	  1019: 		JP		NC,OUTNBS		; Ring bell if buffer full
01:9229 79              	  1020: 		LD		A,C				; Get character
01:922A 71              	  1021: 		LD		(HL),C			; Save in buffer
01:922B 32CC10          	  1022: 		LD		(LSTBIN),A		; Save last input byte
01:922E 23              	  1023: 		INC		HL				; Move up buffer
01:922F 04              	  1024: 		INC		B				; Increment length
01:9230 CD4F92          	  1025: OUTIT:	CALL	OUTC			; Output the character entered
01:9233 C3C491          	  1026: 		JP		MORINP			; Get another character
                        	  1027: 
01:9236 CD4F92          	  1028: OUTNBS: CALL	OUTC			; Output bell and back over it
01:9239 3E08            	  1029: 		LD		A,BKSP			; Set back space
01:923B C33092          	  1030: 		JP		OUTIT			; Output it and get more
                        	  1031: 
01:923E 7C              	  1032: CPDEHL: LD		A,H				; Get H
01:923F 92              	  1033: 		SUB		D				; Compare with D
01:9240 C0              	  1034: 		RET		NZ				; Different - Exit
01:9241 7D              	  1035: 		LD		A,L				; Get L
01:9242 93              	  1036: 		SUB		E				; Compare with E
01:9243 C9              	  1037: 		RET						; Return status
                        	  1038: 
01:9244 7E              	  1039: CHKSYN: LD		A,(HL)			; Check syntax of character
01:9245 E3              	  1040: 		EX		(SP),HL			; Address of test byte
01:9246 BE              	  1041: 		CP		(HL)			; Same as in code string?
01:9247 23              	  1042: 		INC		HL				; Return address
01:9248 E3              	  1043: 		EX		(SP),HL			; Put it back
01:9249 CACE93          	  1044: 		JP		Z,GETCHR		; Yes - Get next character
01:924C C3768F          	  1045: 		JP		SNERR			; Different - ?SN Error
                        	  1046: 
01:924F F5              	  1047: OUTC:	PUSH	AF				; Save character
01:9250 3A4510          	  1048: 		LD		A,(CTLOFG)		; Get control "O" flag
01:9253 B7              	  1049: 		OR		A				; Is it set?
01:9254 C2459D          	  1050: 		JP		NZ,POPAF		; Yes - don't output
01:9257 F1              	  1051: 		POP		AF				; Restore character
01:9258 C5              	  1052: 		PUSH	BC				; Save buffer length
01:9259 F5              	  1053: 		PUSH	AF				; Save character
01:925A FE20            	  1054: 		CP		' '				; Is it a control code?
01:925C DA7392          	  1055: 		JP		C,DINPOS		; Yes - Don't INC POS(X)
01:925F 3A4210          	  1056: 		LD		A,(LWIDTH)		; Get line width
01:9262 47              	  1057: 		LD		B,A				; To B
01:9263 3AAB10          	  1058: 		LD		A,(CURPOS)		; Get cursor position
01:9266 04              	  1059: 		INC		B				; Width 255?
01:9267 CA6F92          	  1060: 		JP		Z,INCLEN		; Yes - No width limit
01:926A 05              	  1061: 		DEC		B				; Restore width
01:926B B8              	  1062: 		CP		B				; At end of line?
01:926C CC7F80          	  1063: 		CALL	Z,PrintCRLF		; Yes - output CRLF
01:926F 3C              	  1064: INCLEN: INC		A				; Move on one character
01:9270 32AB10          	  1065: 		LD		(CURPOS),A		; Save new position
01:9273 F1              	  1066: DINPOS: POP		AF				; Restore character
01:9274 C1              	  1067: 		POP		BC				; Restore buffer length
01:9275 CD0FA8          	  1068: 		CALL	MONOUT			; Send it
01:9278 C9              	  1069: 		RET
                        	  1070: 
01:9279 CDCFA6          	  1071: CLOTST: CALL	GETINP			; Get input character
01:927C E67F            	  1072: 		AND		01111111B		; Strip bit 7
01:927E FE0F            	  1073: 		CP		CTRLO			; Is it control "O"?
01:9280 C0              	  1074: 		RET		NZ				; No don't flip flag
01:9281 3A4510          	  1075: 		LD		A,(CTLOFG)		; Get flag
01:9284 2F              	  1076: 		CPL						; Flip it
01:9285 324510          	  1077: 		LD		(CTLOFG),A		; Put it back
01:9288 AF              	  1078: 		XOR		A				; Null character
01:9289 C9              	  1079: 		RET
                        	  1080: 
01:928A CD9D94          	  1081: LISTT:	CALL	ATOH			; ASCII number to DE
01:928D C0              	  1082: 		RET		NZ				; Return if anything extra
01:928E C1              	  1083: 		POP		BC				; Rubbish - Not needed
01:928F CD6290          	  1084: 		CALL	SRCHLN			; Search for line number in DE
01:9292 C5              	  1085: 		PUSH	BC				; Save address of line
01:9293 CDE092          	  1086: 		CALL	SETLIN			; Set up lines counter
01:9296 E1              	  1087: LISTLP: POP		HL				; Restore address of line
01:9297 4E              	  1088: 		LD		C,(HL)			; Get LSB of next line
01:9298 23              	  1089: 		INC		HL
01:9299 46              	  1090: 		LD		B,(HL)			; Get MSB of next line
01:929A 23              	  1091: 		INC		HL
01:929B 78              	  1092: 		LD		A,B				; BC = 0 (End of program)?
01:929C B1              	  1093: 		OR		C
01:929D CAC18F          	  1094: 		JP		Z,PRNTOK		; Yes - Go to command mode
01:92A0 CDE992          	  1095: 		CALL	COUNT			; Count lines
01:92A3 CDF993          	  1096: 		CALL	TSTBRK			; Test for break key
01:92A6 C5              	  1097: 		PUSH	BC				; Save address of next line
01:92A7 CD7F80          	  1098: 		CALL	PrintCRLF		; Output CRLF
01:92AA 5E              	  1099: 		LD		E,(HL)			; Get LSB of line number
01:92AB 23              	  1100: 		INC		HL
01:92AC 56              	  1101: 		LD		D,(HL)			; Get MSB of line number
01:92AD 23              	  1102: 		INC		HL
01:92AE E5              	  1103: 		PUSH	HL				; Save address of line start
01:92AF EB              	  1104: 		EX		DE,HL			; Line number to HL
01:92B0 CDB3A3          	  1105: 		CALL	PRNTHL			; Output line number in decimal
01:92B3 3E20            	  1106: 		LD		A,' '			; Space after line number
01:92B5 E1              	  1107: 		POP		HL				; Restore start of line address
01:92B6 CD4F92          	  1108: LSTLP2: CALL	OUTC			; Output character in A
01:92B9 7E              	  1109: LSTLP3: LD		A,(HL)			; Get next byte in line
01:92BA B7              	  1110: 		OR		A				; End of line?
01:92BB 23              	  1111: 		INC		HL				; To next byte in line
01:92BC CA9692          	  1112: 		JP		Z,LISTLP		; Yes - get next line
01:92BF F2B692          	  1113: 		JP		P,LSTLP2		; No token - output it
01:92C2 D67F            	  1114: 		SUB		ZEND-1			; Find and output word
01:92C4 4F              	  1115: 		LD		C,A				; Token offset+1 to C
01:92C5 11F98C          	  1116: 		LD		DE,WORDS		; Reserved word list
01:92C8 1A              	  1117: FNDTOK: LD		A,(DE)			; Get character in list
01:92C9 13              	  1118: 		INC		DE				; Move on to next
01:92CA B7              	  1119: 		OR		A				; Is it start of word?
01:92CB F2C892          	  1120: 		JP		P,FNDTOK		; No - Keep looking for word
01:92CE 0D              	  1121: 		DEC		C				; Count words
01:92CF C2C892          	  1122: 		JP		NZ,FNDTOK		; Not there - keep looking
01:92D2 E67F            	  1123: OUTWRD: AND		01111111B		; Strip bit 7
01:92D4 CD4F92          	  1124: 		CALL	OUTC			; Output first character
01:92D7 1A              	  1125: 		LD		A,(DE)			; Get next character
01:92D8 13              	  1126: 		INC		DE				; Move on to next
01:92D9 B7              	  1127: 		OR		A				; Is it end of word?
01:92DA F2D292          	  1128: 		JP		P,OUTWRD		; No - output the rest
01:92DD C3B992          	  1129: 		JP		LSTLP3			; Next byte in line
                        	  1130: 
01:92E0 E5              	  1131: SETLIN: PUSH	HL				; Set up LINES counter
01:92E1 2A4810          	  1132: 		LD		HL,(LINESN)		; Get LINES number
01:92E4 224610          	  1133: 		LD		(LINESC),HL		; Save in LINES counter
01:92E7 E1              	  1134: 		POP		HL
01:92E8 C9              	  1135: 		RET
                        	  1136: 
01:92E9 E5              	  1137: COUNT:	PUSH	HL				; Save code string address
01:92EA D5              	  1138: 		PUSH	DE
01:92EB 2A4610          	  1139: 		LD		HL,(LINESC)		; Get LINES counter
01:92EE 11FFFF          	  1140: 		LD		DE,-1
01:92F1 ED5A            	  1141: 		ADC		HL,DE			; Decrement
01:92F3 224610          	  1142: 		LD		(LINESC),HL		; Put it back
01:92F6 D1              	  1143: 		POP		DE
01:92F7 E1              	  1144: 		POP		HL				; Restore code string address
01:92F8 F0              	  1145: 		RET		P				; Return if more lines to go
01:92F9 E5              	  1146: 		PUSH	HL				; Save code string address
01:92FA 2A4810          	  1147: 		LD		HL,(LINESN)		; Get LINES number
01:92FD 224610          	  1148: 		LD		(LINESC),HL		; Reset LINES counter
01:9300 CDCFA6          	  1149: 		CALL	GETINP			; Get input character
01:9303 FE03            	  1150: 		CP		CTRLC			; Is it control "C"?
01:9305 CA0C93          	  1151: 		JP		Z,RSLNBK		; Yes - Reset LINES and break
01:9308 E1              	  1152: 		POP		HL				; Restore code string address
01:9309 C3E992          	  1153: 		JP		COUNT			; Keep on counting
                        	  1154: 
01:930C 2A4810          	  1155: RSLNBK: LD		HL,(LINESN)		; Get LINES number
01:930F 224610          	  1156: 		LD		(LINESC),HL		; Reset LINES counter
01:9312 C36B8C          	  1157: 		JP		BRKRET			; Go and output "Break"
                        	  1158: 
01:9315 3E64            	  1159: FOR:	LD		A,64H			; Flag "FOR" assignment
01:9317 32CB10          	  1160: 		LD		(FORFLG),A		; Save "FOR" flag
01:931A CD7F95          	  1161: 		CALL	LET				; Set up initial index
01:931D C1              	  1162: 		POP		BC				; Drop RETurn address
01:931E E5              	  1163: 		PUSH	HL				; Save code string address
01:931F CD6895          	  1164: 		CALL	DATAA			; Get next statement address
01:9322 22C710          	  1165: 		LD		(LOOPST),HL		; Save it for start of loop
01:9325 210200          	  1166: 		LD		HL,2			; Offset for "FOR" block
01:9328 39              	  1167: 		ADD		HL,SP			; Point to it
01:9329 CD238F          	  1168: FORSLP: CALL	LOKFOR			; Look for existing "FOR" block
01:932C D1              	  1169: 		POP		DE				; Get code string address
01:932D C24593          	  1170: 		JP		NZ,FORFND		; No nesting found
01:9330 09              	  1171: 		ADD		HL,BC			; Move into "FOR" block
01:9331 D5              	  1172: 		PUSH	DE				; Save code string address
01:9332 2B              	  1173: 		DEC		HL
01:9333 56              	  1174: 		LD		D,(HL)			; Get MSB of loop statement
01:9334 2B              	  1175: 		DEC		HL
01:9335 5E              	  1176: 		LD		E,(HL)			; Get LSB of loop statement
01:9336 23              	  1177: 		INC		HL
01:9337 23              	  1178: 		INC		HL
01:9338 E5              	  1179: 		PUSH	HL				; Save block address
01:9339 2AC710          	  1180: 		LD		HL,(LOOPST)		; Get address of loop statement
01:933C CD3E92          	  1181: 		CALL	CPDEHL			; Compare the FOR loops
01:933F E1              	  1182: 		POP		HL				; Restore block address
01:9340 C22993          	  1183: 		JP		NZ,FORSLP		; Different FORs - Find another
01:9343 D1              	  1184: 		POP		DE				; Restore code string address
01:9344 F9              	  1185: 		LD		SP,HL			; Remove all nested loops
                        	  1186: 
01:9345 EB              	  1187: FORFND: EX		DE,HL			; Code string address to HL
01:9346 0E08            	  1188: 		LD		C,8
01:9348 CD538F          	  1189: 		CALL	CHKSTK			; Check for 8 levels of stack
01:934B E5              	  1190: 		PUSH	HL				; Save code string address
01:934C 2AC710          	  1191: 		LD		HL,(LOOPST)		; Get first statement of loop
01:934F E3              	  1192: 		EX		(SP),HL			; Save and restore code string
01:9350 E5              	  1193: 		PUSH	HL				; Re-save code string address
01:9351 2A5C10          	  1194: 		LD		HL,(LINEAT)		; Get current line number
01:9354 E3              	  1195: 		EX		(SP),HL			; Save and restore code string
01:9355 CD3A98          	  1196: 		CALL	TSTNUM			; Make sure it's a number
01:9358 CD4492          	  1197: 		CALL	CHKSYN			; Make sure "TO" is next
01:935B A6              	  1198: 		db	ZTO			 ; "TO" token
01:935C CD3798          	  1199: 		CALL	GETNUM			; Get "TO" expression value
01:935F E5              	  1200: 		PUSH	HL				; Save code string address
01:9360 CD65A2          	  1201: 		CALL	BCDEFP			; Move "TO" value to BCDE
01:9363 E1              	  1202: 		POP		HL				; Restore code string address
01:9364 C5              	  1203: 		PUSH	BC				; Save "TO" value in block
01:9365 D5              	  1204: 		PUSH	DE
01:9366 010081          	  1205: 		LD		BC,8100H		; BCDE - 1 (default STEP)
01:9369 51              	  1206: 		LD		D,C				; C=0
01:936A 5A              	  1207: 		LD		E,D				; D=0
01:936B 7E              	  1208: 		LD		A,(HL)			; Get next byte in code string
01:936C FEAB            	  1209: 		CP		ZSTEP			; See if "STEP" is stated
01:936E 3E01            	  1210: 		LD		A,1				; Sign of step = 1
01:9370 C28193          	  1211: 		JP		NZ,SAVSTP		; No STEP given - Default to 1
01:9373 CDCE93          	  1212: 		CALL	GETCHR			; Jump over "STEP" token
01:9376 CD3798          	  1213: 		CALL	GETNUM			; Get step value
01:9379 E5              	  1214: 		PUSH	HL				; Save code string address
01:937A CD65A2          	  1215: 		CALL	BCDEFP			; Move STEP to BCDE
01:937D CD19A2          	  1216: 		CALL	TSTSGN			; Test sign of FPREG
01:9380 E1              	  1217: 		POP		HL				; Restore code string address
01:9381 C5              	  1218: SAVSTP: PUSH	BC				; Save the STEP value in block
01:9382 D5              	  1219: 		PUSH	DE
01:9383 F5              	  1220: 		PUSH	AF				; Save sign of STEP
01:9384 33              	  1221: 		INC		SP				; Don't save flags
01:9385 E5              	  1222: 		PUSH	HL				; Save code string address
01:9386 2ACE10          	  1223: 		LD		HL,(BRKLIN)		; Get address of index variable
01:9389 E3              	  1224: 		EX		(SP),HL			; Save and restore code string
01:938A 0681            	  1225: PUTFID: LD		B,ZFOR			; "FOR" block marker
01:938C C5              	  1226: 		PUSH	BC				; Save it
01:938D 33              	  1227: 		INC		SP				; Don't save C
                        	  1228: 
01:938E CDF993          	  1229: RUNCNT: CALL	TSTBRK			; Execution driver - Test break
01:9391 22CE10          	  1230: 		LD		(BRKLIN),HL		; Save code address for break
01:9394 7E              	  1231: 		LD		A,(HL)			; Get next byte in code string
01:9395 FE3A            	  1232: 		CP		':'				; Multi statement line?
01:9397 CAAE93          	  1233: 		JP		Z,EXCUTE		; Yes - Execute it
01:939A B7              	  1234: 		OR		A				; End of line?
01:939B C2768F          	  1235: 		JP		NZ,SNERR		; No - Syntax error
01:939E 23              	  1236: 		INC		HL				; Point to address of next line
01:939F 7E              	  1237: 		LD		A,(HL)			; Get LSB of line pointer
01:93A0 23              	  1238: 		INC		HL
01:93A1 B6              	  1239: 		OR		(HL)			; Is it zero (End of prog)?
01:93A2 CA2394          	  1240: 		JP		Z,ENDPRG		; Yes - Terminate execution
01:93A5 23              	  1241: 		INC		HL				; Point to line number
01:93A6 5E              	  1242: 		LD		E,(HL)			; Get LSB of line number
01:93A7 23              	  1243: 		INC		HL
01:93A8 56              	  1244: 		LD		D,(HL)			; Get MSB of line number
01:93A9 EB              	  1245: 		EX		DE,HL			; Line number to HL
01:93AA 225C10          	  1246: 		LD		(LINEAT),HL		; Save as current line number
01:93AD EB              	  1247: 		EX		DE,HL			; Line number back to DE
01:93AE CDCE93          	  1248: EXCUTE: CALL	GETCHR			; Get key word
01:93B1 118E93          	  1249: 		LD		DE,RUNCNT		; Where to RETurn to
01:93B4 D5              	  1250: 		PUSH	DE				; Save for RETurn
01:93B5 C8              	  1251: IFJMP:	RET		Z				; Go to RUNCNT if end of STMT
01:93B6 D680            	  1252: ONJMP:	SUB		ZEND			; Is it a token?
01:93B8 DA7F95          	  1253: 		JP		C,LET			; No - try to assign it
01:93BB FE25            	  1254: 		CP		ZNEW+1-ZEND		; END to NEW ?
01:93BD D2768F          	  1255: 		JP		NC,SNERR		; Not a key word - ?SN Error
01:93C0 07              	  1256: 		RLCA					; Double it
01:93C1 4F              	  1257: 		LD		C,A				; BC = Offset into table
01:93C2 0600            	  1258: 		LD		B,0
01:93C4 EB              	  1259: 		EX		DE,HL			; Save code string address
01:93C5 211C8E          	  1260: 		LD		HL,WORDTB		; Keyword address table
01:93C8 09              	  1261: 		ADD		HL,BC			; Point to routine address
01:93C9 4E              	  1262: 		LD		C,(HL)			; Get LSB of routine address
01:93CA 23              	  1263: 		INC		HL
01:93CB 46              	  1264: 		LD		B,(HL)			; Get MSB of routine address
01:93CC C5              	  1265: 		PUSH	BC				; Save routine address
01:93CD EB              	  1266: 		EX		DE,HL			; Restore code string address
                        	  1267: 
01:93CE 23              	  1268: GETCHR: INC		HL				; Point to next character
01:93CF 7E              	  1269: 		LD		A,(HL)			; Get next code string byte
01:93D0 FE3A            	  1270: 		CP		':'				; Z if ':'
01:93D2 D0              	  1271: 		RET		NC				; NC if > "9"
01:93D3 FE20            	  1272: 		CP		' '
01:93D5 CACE93          	  1273: 		JP		Z,GETCHR		; Skip over spaces
01:93D8 FE30            	  1274: 		CP		'0'
01:93DA 3F              	  1275: 		CCF						; NC if < '0'
01:93DB 3C              	  1276: 		INC		A				; Test for zero - Leave carry
01:93DC 3D              	  1277: 		DEC		A				; Z if Null
01:93DD C9              	  1278: 		RET
                        	  1279: 
01:93DE EB              	  1280: RESTOR: EX		DE,HL			; Save code string address
01:93DF 2A5E10          	  1281: 		LD		HL,(BASTXT)		; Point to start of program
01:93E2 CAF393          	  1282: 		JP		Z,RESTNL		; Just RESTORE - reset pointer
01:93E5 EB              	  1283: 		EX		DE,HL			; Restore code string address
01:93E6 CD9D94          	  1284: 		CALL	ATOH			; Get line number to DE
01:93E9 E5              	  1285: 		PUSH	HL				; Save code string address
01:93EA CD6290          	  1286: 		CALL	SRCHLN			; Search for line number in DE
01:93ED 60              	  1287: 		LD		H,B				; HL = Address of line
01:93EE 69              	  1288: 		LD		L,C
01:93EF D1              	  1289: 		POP		DE				; Restore code string address
01:93F0 D23E95          	  1290: 		JP		NC,ULERR		; ?UL Error if not found
01:93F3 2B              	  1291: RESTNL: DEC		HL				; Byte before DATA statement
01:93F4 22DC10          	  1292: UPDATA: LD		(NXTDAT),HL		; Update DATA pointer
01:93F7 EB              	  1293: 		EX		DE,HL			; Restore code string address
01:93F8 C9              	  1294: 		RET
                        	  1295: 
                        	  1296: 
                        	  1297: TSTBRK: 
01:93F9 CDD080          	  1298: 	call	ReadCharNoWait			; Check for presence of character
01:93FC C8              	  1299: 	ret		z						; Return if nothing is in SIO buffer
                        	  1300: 	
                        	  1301: ;		call	CKINCHAR				; Check input status
                        	  1302: ;		RET		Z				; No key, go back
                        	  1303: ;		call	RXA				; Get the key into A
01:93FD FE1B            	  1304: 		CP		ESC				; Escape key?
01:93FF 2813            	  1305: 		JR		Z,BRK			; Yes, break
01:9401 FE03            	  1306: 		CP		CTRLC			; <Ctrl-C>
01:9403 280F            	  1307: 		JR		Z,BRK			; Yes, break
01:9405 FE13            	  1308: 		CP		CTRLS			; Stop scrolling?
01:9407 C0              	  1309: 		RET		NZ				; Other key, ignore
                        	  1310: 
                        	  1311: 
01:9408 CDC780          	  1312: STALL:	call	ReadChar				; Wait for key
01:940B FE11            	  1313: 		CP		CTRLQ			; Resume scrolling?
01:940D C8              	  1314: 		RET		 Z				; Release the chokehold
01:940E FE03            	  1315: 		CP		CTRLC			; Second break?
01:9410 2807            	  1316: 		JR		Z,STOPP			; Break during hold exits prog
01:9412 18F4            	  1317: 		JR		STALL			; Loop until <Ctrl-Q> or <brk>
                        	  1318: 
01:9414 3EFF            	  1319: BRK		LD		A,$FF			; Set BRKFLG
01:9416 324D10          	  1320: 		LD		(BRKFLG),A		; Store it
                        	  1321: 
                        	  1322: 
01:9419 C0              	  1323: STOPP:	RET		NZ				; Exit if anything else
01:941A F6              	  1324: 		db	0F6H			; Flag "STOP"
01:941B C0              	  1325: PEND:	RET		NZ				; Exit if anything else
01:941C 22CE10          	  1326: 		LD		(BRKLIN),HL		; Save point of break
01:941F 21              	  1327: 		db	21H				; Skip "OR 11111111B"
01:9420 F6FF            	  1328: INPBRK: OR		11111111B		; Flag "Break" wanted
01:9422 C1              	  1329: 		POP		BC				; Return not needed and more
01:9423 2A5C10          	  1330: ENDPRG: LD		HL,(LINEAT)		; Get current line number
01:9426 F5              	  1331: 		PUSH	AF				; Save STOP / END status
01:9427 7D              	  1332: 		LD		A,L				; Is it direct break?
01:9428 A4              	  1333: 		AND		H
01:9429 3C              	  1334: 		INC		A				; Line is -1 if direct break
01:942A CA3694          	  1335: 		JP		Z,NOLIN			; Yes - No line number
01:942D 22D210          	  1336: 		LD		(ERRLIN),HL		; Save line of break
01:9430 2ACE10          	  1337: 		LD		HL,(BRKLIN)		; Get point of break
01:9433 22D410          	  1338: 		LD		(CONTAD),HL		; Save point to CONTinue
01:9436 AF              	  1339: NOLIN:	XOR		A
01:9437 324510          	  1340: 		LD		(CTLOFG),A		; Enable output
01:943A CD6C96          	  1341: 		CALL	STTLIN			; Start a new line
01:943D F1              	  1342: 		POP		AF				; Restore STOP / END status
01:943E 21198F          	  1343: 		LD		HL,BRKMSG		; "Break" message
01:9441 C2AA8F          	  1344: 		JP		NZ,ERRIN		; "in line" wanted?
01:9444 C3C18F          	  1345: 		JP		PRNTOK			; Go to command mode
                        	  1346: 
01:9447 2AD410          	  1347: CONT:	LD		HL,(CONTAD)		; Get CONTinue address
01:944A 7C              	  1348: 		LD		A,H				; Is it zero?
01:944B B5              	  1349: 		OR		L
01:944C 1E20            	  1350: 		LD		E,CN			; ?CN Error
01:944E CA8A8F          	  1351: 		JP		Z,ERROR			; Yes - output "?CN Error"
01:9451 EB              	  1352: 		EX		DE,HL			; Save code string address
01:9452 2AD210          	  1353: 		LD		HL,(ERRLIN)		; Get line of last break
01:9455 225C10          	  1354: 		LD		(LINEAT),HL		; Set up current line number
01:9458 EB              	  1355: 		EX		DE,HL			; Restore code string address
01:9459 C9              	  1356: 		RET						; CONTinue where left off
                        	  1357: 
01:945A CD989F          	  1358: NULLL:	CALL	GETINT			; Get integer 0-255
01:945D C0              	  1359: 		RET		NZ				; Return if bad value
01:945E 324110          	  1360: 		LD		(NULLS),A		; Set nulls number
01:9461 C9              	  1361: 		RET
                        	  1362: 
                        	  1363: 
01:9462 E5              	  1364: ACCSUM: PUSH	HL				; Save address in array
01:9463 2A4A10          	  1365: 		LD		HL,(CHKSUM)		; Get check sum
01:9466 0600            	  1366: 		LD		B,0				; BC - Value of byte
01:9468 4F              	  1367: 		LD		C,A
01:9469 09              	  1368: 		ADD		HL,BC			; Add byte to check sum
01:946A 224A10          	  1369: 		LD		(CHKSUM),HL		; Re-save check sum
01:946D E1              	  1370: 		POP		HL				; Restore address in array
01:946E C9              	  1371: 		RET
                        	  1372: 
01:946F 7E              	  1373: CHKLTR: LD		A,(HL)			; Get byte
01:9470 FE41            	  1374: 		CP		'A'				; < 'a' ?
01:9472 D8              	  1375: 		RET		C				; Carry set if not letter
01:9473 FE5B            	  1376: 		CP		'Z'+1			; > 'z' ?
01:9475 3F              	  1377: 		CCF
01:9476 C9              	  1378: 		RET						; Carry set if not letter
                        	  1379: 
01:9477 CDCE93          	  1380: FPSINT: CALL	GETCHR			; Get next character
01:947A CD3798          	  1381: POSINT: CALL	GETNUM			; Get integer 0 to 32767
01:947D CD19A2          	  1382: DEPINT: CALL	TSTSGN			; Test sign of FPREG
01:9480 FA9894          	  1383: 		JP		M,FCERR			; Negative - ?FC Error
01:9483 3AE710          	  1384: DEINT:	LD		A,(FPEXP)		; Get integer value to DE
01:9486 FE90            	  1385: 		CP		80H+16			; Exponent in range (16 bits)?
01:9488 DAC1A2          	  1386: 		JP		C,FPINT			; Yes - convert it
01:948B 018090          	  1387: 		LD		BC,9080H		; BCDE = -32768
01:948E 110000          	  1388: 		LD		DE,0000
01:9491 E5              	  1389: 		PUSH	HL				; Save code string address
01:9492 CD94A2          	  1390: 		CALL	CMPNUM			; Compare FPREG with BCDE
01:9495 E1              	  1391: 		POP		HL				; Restore code string address
01:9496 51              	  1392: 		LD		D,C				; MSB to D
01:9497 C8              	  1393: 		RET		Z				; Return if in range
01:9498 1E08            	  1394: FCERR:	LD		E,FC			; ?FC Error
01:949A C38A8F          	  1395: 		JP		ERROR			; Output error-
                        	  1396: 
01:949D 2B              	  1397: ATOH:	DEC		HL				; ASCII number to DE binary
01:949E 110000          	  1398: GETLN:	LD		DE,0			; Get number to DE
01:94A1 CDCE93          	  1399: GTLNLP: CALL	GETCHR			; Get next character
01:94A4 D0              	  1400: 		RET		NC				; Exit if not a digit
01:94A5 E5              	  1401: 		PUSH	HL				; Save code string address
01:94A6 F5              	  1402: 		PUSH	AF				; Save digit
01:94A7 219819          	  1403: 		LD		HL,65529/10		; Largest number 65529
01:94AA CD3E92          	  1404: 		CALL	CPDEHL			; Number in range?
01:94AD DA768F          	  1405: 		JP		C,SNERR			; No - ?SN Error
01:94B0 62              	  1406: 		LD		H,D				; HL = Number
01:94B1 6B              	  1407: 		LD		L,E
01:94B2 19              	  1408: 		ADD		HL,DE			; Times 2
01:94B3 29              	  1409: 		ADD		HL,HL			; Times 4
01:94B4 19              	  1410: 		ADD		HL,DE			; Times 5
01:94B5 29              	  1411: 		ADD		HL,HL			; Times 10
01:94B6 F1              	  1412: 		POP		AF				; Restore digit
01:94B7 D630            	  1413: 		SUB		'0'				; Make it 0 to 9
01:94B9 5F              	  1414: 		LD		E,A				; DE = Value of digit
01:94BA 1600            	  1415: 		LD		D,0
01:94BC 19              	  1416: 		ADD		HL,DE			; Add to number
01:94BD EB              	  1417: 		EX		DE,HL			; Number to DE
01:94BE E1              	  1418: 		POP		HL				; Restore code string address
01:94BF C3A194          	  1419: 		JP		GTLNLP			; Go to next character
                        	  1420: 
01:94C2 CA9290          	  1421: CLEAR:	JP		Z,INTVAR		; Just "CLEAR" Keep parameters
01:94C5 CD7A94          	  1422: 		CALL	POSINT			; Get integer 0 to 32767 to DE
01:94C8 2B              	  1423: 		DEC		HL				; Cancel increment
01:94C9 CDCE93          	  1424: 		CALL	GETCHR			; Get next character
01:94CC E5              	  1425: 		PUSH	HL				; Save code string address
01:94CD 2AAF10          	  1426: 		LD		HL,(LSTRAM)		; Get end of RAM
01:94D0 CAE594          	  1427: 		JP		Z,STORED		; No value given - Use stored
01:94D3 E1              	  1428: 		POP		HL				; Restore code string address
01:94D4 CD4492          	  1429: 		CALL	CHKSYN			; Check for comma
01:94D7 2C              	  1430: 		db	   ','
01:94D8 D5              	  1431: 		PUSH	DE				; Save number
01:94D9 CD7A94          	  1432: 		CALL	POSINT			; Get integer 0 to 32767
01:94DC 2B              	  1433: 		DEC		HL				; Cancel increment
01:94DD CDCE93          	  1434: 		CALL	GETCHR			; Get next character
01:94E0 C2768F          	  1435: 		JP		NZ,SNERR		; ?SN Error if more on line
01:94E3 E3              	  1436: 		EX		(SP),HL			; Save code string address
01:94E4 EB              	  1437: 		EX		DE,HL			; Number to DE
01:94E5 7D              	  1438: STORED: LD		A,L				; Get LSB of new RAM top
01:94E6 93              	  1439: 		SUB		E				; Subtract LSB of string space
01:94E7 5F              	  1440: 		LD		E,A				; Save LSB
01:94E8 7C              	  1441: 		LD		A,H				; Get MSB of new RAM top
01:94E9 9A              	  1442: 		SBC		A,D				; Subtract MSB of string space
01:94EA 57              	  1443: 		LD		D,A				; Save MSB
01:94EB DA6B8F          	  1444: 		JP		C,OMERR			; ?OM Error if not enough mem
01:94EE E5              	  1445: 		PUSH	HL				; Save RAM top
01:94EF 2AD610          	  1446: 		LD		HL,(PROGND)		; Get program end
01:94F2 012800          	  1447: 		LD		BC,40			; 40 Bytes minimum working RAM
01:94F5 09              	  1448: 		ADD		HL,BC			; Get lowest address
01:94F6 CD3E92          	  1449: 		CALL	CPDEHL			; Enough memory?
01:94F9 D26B8F          	  1450: 		JP		NC,OMERR		; No - ?OM Error
01:94FC EB              	  1451: 		EX		DE,HL			; RAM top to HL
01:94FD 225A10          	  1452: 		LD		(STRSPC),HL		; Set new string space
01:9500 E1              	  1453: 		POP		HL				; End of memory to use
01:9501 22AF10          	  1454: 		LD		(LSTRAM),HL		; Set new top of RAM
01:9504 E1              	  1455: 		POP		HL				; Restore code string address
01:9505 C39290          	  1456: 		JP		INTVAR			; Initialise variables
                        	  1457: 
01:9508 CA8E90          	  1458: RUN:	JP		Z,RUNFST		; RUN from start if just RUN
01:950B CD9290          	  1459: 		CALL	INTVAR			; Initialise variables
01:950E 018E93          	  1460: 		LD		BC,RUNCNT		; Execution driver loop
01:9511 C32495          	  1461: 		JP		RUNLIN			; RUN from line number
                        	  1462: 
01:9514 0E03            	  1463: GOSUB:	LD		C,3				; 3 Levels of stack needed
01:9516 CD538F          	  1464: 		CALL	CHKSTK			; Check for 3 levels of stack
01:9519 C1              	  1465: 		POP		BC				; Get return address
01:951A E5              	  1466: 		PUSH	HL				; Save code string for RETURN
01:951B E5              	  1467: 		PUSH	HL				; And for GOSUB routine
01:951C 2A5C10          	  1468: 		LD		HL,(LINEAT)		; Get current line
01:951F E3              	  1469: 		EX		(SP),HL			; Into stack - Code string out
01:9520 3E8C            	  1470: 		LD		A,ZGOSUB		; "GOSUB" token
01:9522 F5              	  1471: 		PUSH	AF				; Save token
01:9523 33              	  1472: 		INC		SP				; Don't save flags
                        	  1473: 
01:9524 C5              	  1474: RUNLIN: PUSH	BC				; Save return address
01:9525 CD9D94          	  1475: GOTO:	CALL	ATOH			; ASCII number to DE binary
01:9528 CD6A95          	  1476: 		CALL	REM				; Get end of line
01:952B E5              	  1477: 		PUSH	HL				; Save end of line
01:952C 2A5C10          	  1478: 		LD		HL,(LINEAT)		; Get current line
01:952F CD3E92          	  1479: 		CALL	CPDEHL			; Line after current?
01:9532 E1              	  1480: 		POP		HL				; Restore end of line
01:9533 23              	  1481: 		INC		HL				; Start of next line
01:9534 DC6590          	  1482: 		CALL	C,SRCHLP		; Line is after current line
01:9537 D46290          	  1483: 		CALL	NC,SRCHLN		; Line is before current line
01:953A 60              	  1484: 		LD		H,B				; Set up code string address
01:953B 69              	  1485: 		LD		L,C
01:953C 2B              	  1486: 		DEC		HL				; Incremented after
01:953D D8              	  1487: 		RET		C				; Line found
01:953E 1E0E            	  1488: ULERR:	LD		E,UL			; ?UL Error
01:9540 C38A8F          	  1489: 		JP		ERROR			; Output error message
                        	  1490: 
01:9543 C0              	  1491: RETURN: RET		NZ				; Return if not just RETURN
01:9544 16FF            	  1492: 		LD		D,-1			; Flag "GOSUB" search
01:9546 CD1F8F          	  1493: 		CALL	BAKSTK			; Look "GOSUB" block
01:9549 F9              	  1494: 		LD		SP,HL			; Kill all FORs in subroutine
01:954A FE8C            	  1495: 		CP		ZGOSUB			; Test for "GOSUB" token
01:954C 1E04            	  1496: 		LD		E,RG			; ?RG Error
01:954E C28A8F          	  1497: 		JP		NZ,ERROR		; Error if no "GOSUB" found
01:9551 E1              	  1498: 		POP		HL				; Get RETURN line number
01:9552 225C10          	  1499: 		LD		(LINEAT),HL		; Save as current
01:9555 23              	  1500: 		INC		HL				; Was it from direct statement?
01:9556 7C              	  1501: 		LD		A,H
01:9557 B5              	  1502: 		OR		L				; Return to line
01:9558 C26295          	  1503: 		JP		NZ,RETLIN		; No - Return to line
01:955B 3ACC10          	  1504: 		LD		A,(LSTBIN)		; Any INPUT in subroutine?
01:955E B7              	  1505: 		OR		A				; If so buffer is corrupted
01:955F C2C08F          	  1506: 		JP		NZ,POPNOK		; Yes - Go to command mode
01:9562 218E93          	  1507: RETLIN: LD		HL,RUNCNT		; Execution driver loop
01:9565 E3              	  1508: 		EX		(SP),HL			; Into stack - Code string out
01:9566 3E              	  1509: 		db	   3EH			   ; Skip "POP HL"
01:9567 E1              	  1510: NXTDTA: POP		HL				; Restore code string address
                        	  1511: 
01:9568 01              	  1512: DATAA:	db	   01H,3AH		   ; ':' End of statement
01:9569 3A
01:956A 0E00            	  1513: REM:	LD		C,0				; 00  End of statement
01:956C 0600            	  1514: 		LD		B,0
01:956E 79              	  1515: NXTSTL: LD		A,C				; Statement and byte
01:956F 48              	  1516: 		LD		C,B
01:9570 47              	  1517: 		LD		B,A				; Statement end byte
01:9571 7E              	  1518: NXTSTT: LD		A,(HL)			; Get byte
01:9572 B7              	  1519: 		OR		A				; End of line?
01:9573 C8              	  1520: 		RET		Z				; Yes - Exit
01:9574 B8              	  1521: 		CP		B				; End of statement?
01:9575 C8              	  1522: 		RET		Z				; Yes - Exit
01:9576 23              	  1523: 		INC		HL				; Next byte
01:9577 FE22            	  1524: 		CP		'"'				; Literal string?
01:9579 CA6E95          	  1525: 		JP		Z,NXTSTL		; Yes - Look for another '"'
01:957C C37195          	  1526: 		JP		NXTSTT			; Keep looking
                        	  1527: 
01:957F CD2D9A          	  1528: LET:	CALL	GETVAR			; Get variable name
01:9582 CD4492          	  1529: 		CALL	CHKSYN			; Make sure "=" follows
01:9585 B4              	  1530: 		db	   ZEQUAL		   ; "=" token
01:9586 D5              	  1531: 		PUSH	DE				; Save address of variable
01:9587 3AAD10          	  1532: 		LD		A,(TYPE)		; Get data type
01:958A F5              	  1533: 		PUSH	AF				; Save type
01:958B CD4998          	  1534: 		CALL	EVAL			; Evaluate expression
01:958E F1              	  1535: 		POP		AF				; Restore type
01:958F E3              	  1536: 		EX		(SP),HL			; Save code - Get var addr
01:9590 22CE10          	  1537: 		LD		(BRKLIN),HL		; Save address of variable
01:9593 1F              	  1538: 		RRA						; Adjust type
01:9594 CD3C98          	  1539: 		CALL	CHKTYP			; Check types are the same
01:9597 CAD295          	  1540: 		JP		Z,LETNUM		; Numeric - Move value
01:959A E5              	  1541: LETSTR: PUSH	HL				; Save address of string var
01:959B 2AE410          	  1542: 		LD		HL,(FPREG)		; Pointer to string entry
01:959E E5              	  1543: 		PUSH	HL				; Save it on stack
01:959F 23              	  1544: 		INC		HL				; Skip over length
01:95A0 23              	  1545: 		INC		HL
01:95A1 5E              	  1546: 		LD		E,(HL)			; LSB of string address
01:95A2 23              	  1547: 		INC		HL
01:95A3 56              	  1548: 		LD		D,(HL)			; MSB of string address
01:95A4 2A5E10          	  1549: 		LD		HL,(BASTXT)		; Point to start of program
01:95A7 CD3E92          	  1550: 		CALL	CPDEHL			; Is string before program?
01:95AA D2C195          	  1551: 		JP		NC,CRESTR		; Yes - Create string entry
01:95AD 2A5A10          	  1552: 		LD		HL,(STRSPC)		; Point to string space
01:95B0 CD3E92          	  1553: 		CALL	CPDEHL			; Is string literal in program?
01:95B3 D1              	  1554: 		POP		DE				; Restore address of string
01:95B4 D2C995          	  1555: 		JP		NC,MVSTPT		; Yes - Set up pointer
01:95B7 21BF10          	  1556: 		LD		HL,TMPSTR		; Temporary string pool
01:95BA CD3E92          	  1557: 		CALL	CPDEHL			; Is string in temporary pool?
01:95BD D2C995          	  1558: 		JP		NC,MVSTPT		; No - Set up pointer
01:95C0 3E              	  1559: 		db	3EH				; Skip "POP DE"
01:95C1 D1              	  1560: CRESTR: POP		DE				; Restore address of string
01:95C2 CD719E          	  1561: 		CALL	BAKTMP			; Back to last tmp-str entry
01:95C5 EB              	  1562: 		EX		DE,HL			; Address of string entry
01:95C6 CDAA9C          	  1563: 		CALL	SAVSTR			; Save string in string area
01:95C9 CD719E          	  1564: MVSTPT: CALL	BAKTMP			; Back to last tmp-str entry
01:95CC E1              	  1565: 		POP		HL				; Get string pointer
01:95CD CD74A2          	  1566: 		CALL	DETHL4			; Move string pointer to var
01:95D0 E1              	  1567: 		POP		HL				; Restore code string address
01:95D1 C9              	  1568: 		RET
                        	  1569: 
01:95D2 E5              	  1570: LETNUM: PUSH	HL				; Save address of variable
01:95D3 CD71A2          	  1571: 		CALL	FPTHL			; Move value to variable
01:95D6 D1              	  1572: 		POP		DE				; Restore address of variable
01:95D7 E1              	  1573: 		POP		HL				; Restore code string address
01:95D8 C9              	  1574: 		RET
                        	  1575: 
01:95D9 CD989F          	  1576: ON:		CALL	GETINT			; Get integer 0-255
01:95DC 7E              	  1577: 		LD		A,(HL)			; Get "GOTO" or "GOSUB" token
01:95DD 47              	  1578: 		LD		B,A				; Save in B
01:95DE FE8C            	  1579: 		CP		ZGOSUB			; "GOSUB" token?
01:95E0 CAE895          	  1580: 		JP		Z,ONGO			; Yes - Find line number
01:95E3 CD4492          	  1581: 		CALL	CHKSYN			; Make sure it's "GOTO"
01:95E6 88              	  1582: 		db	ZGOTO			; "GOTO" token
01:95E7 2B              	  1583: 		DEC		HL				; Cancel increment
01:95E8 4B              	  1584: ONGO:	LD		C,E				; Integer of branch value
01:95E9 0D              	  1585: ONGOLP: DEC		C				; Count branches
01:95EA 78              	  1586: 		LD		A,B				; Get "GOTO" or "GOSUB" token
01:95EB CAB693          	  1587: 		JP		Z,ONJMP			; Go to that line if right one
01:95EE CD9E94          	  1588: 		CALL	GETLN			; Get line number to DE
01:95F1 FE2C            	  1589: 		CP		','				; Another line number?
01:95F3 C0              	  1590: 		RET		NZ				; No - Drop through
01:95F4 C3E995          	  1591: 		JP		ONGOLP			; Yes - loop
                        	  1592: 
01:95F7 CD4998          	  1593: IFF:		CALL	EVAL			; Evaluate expression
01:95FA 7E              	  1594: 		LD		A,(HL)			; Get token
01:95FB FE88            	  1595: 		CP		ZGOTO			; "GOTO" token?
01:95FD CA0596          	  1596: 		JP		Z,IFGO			; Yes - Get line
01:9600 CD4492          	  1597: 		CALL	CHKSYN			; Make sure it's "THEN"
01:9603 A9              	  1598: 		db	   ZTHEN		   ; "THEN" token
01:9604 2B              	  1599: 		DEC		HL				; Cancel increment
01:9605 CD3A98          	  1600: IFGO:	CALL	TSTNUM			; Make sure it's numeric
01:9608 CD19A2          	  1601: 		CALL	TSTSGN			; Test state of expression
01:960B CA6A95          	  1602: 		JP		Z,REM			; False - Drop through
01:960E CDCE93          	  1603: 		CALL	GETCHR			; Get next character
01:9611 DA2595          	  1604: 		JP		C,GOTO			; Number - GOTO that line
01:9614 C3B593          	  1605: 		JP		IFJMP			; Otherwise do statement
                        	  1606: 
01:9617 2B              	  1607: MRPRNT: DEC		HL				; DEC 'cos GETCHR INCs
01:9618 CDCE93          	  1608: 		CALL	GETCHR			; Get next character
01:961B CA7F80          	  1609: PRINTT:	JP		Z,PrintCRLF		; CRLF if just PRINT
01:961E C8              	  1610: PRNTLP: RET		Z				; End of list - Exit
01:961F FEA5            	  1611: 		CP		ZTAB			; "TAB(" token?
01:9621 CAA596          	  1612: 		JP		Z,DOTAB			; Yes - Do TAB routine
01:9624 FEA8            	  1613: 		CP		ZSPC			; "SPC(" token?
01:9626 CAA596          	  1614: 		JP		Z,DOTAB			; Yes - Do SPC routine
01:9629 E5              	  1615: 		PUSH	HL				; Save code string address
01:962A FE2C            	  1616: 		CP		','				; Comma?
01:962C CA8E96          	  1617: 		JP		Z,DOCOM			; Yes - Move to next zone
01:962F FE3B            	  1618: 		CP		59 ;";"			; Semi-colon?
01:9631 CAC896          	  1619: 		JP		Z,NEXITM		; Do semi-colon routine
01:9634 C1              	  1620: 		POP		BC				; Code string address to BC
01:9635 CD4998          	  1621: 		CALL	EVAL			; Evaluate expression
01:9638 E5              	  1622: 		PUSH	HL				; Save code string address
01:9639 3AAD10          	  1623: 		LD		A,(TYPE)		; Get variable type
01:963C B7              	  1624: 		OR		A				; Is it a string variable?
01:963D C26596          	  1625: 		JP		NZ,PRNTST		; Yes - Output string contents
01:9640 CDBEA3          	  1626: 		CALL	NUMASC			; Convert number to text
01:9643 CDCE9C          	  1627: 		CALL	CRTST			; Create temporary string
01:9646 3620            	  1628: 		LD		(HL),' '		; Followed by a space
01:9648 2AE410          	  1629: 		LD		HL,(FPREG)		; Get length of output
01:964B 34              	  1630: 		INC		(HL)			; Plus 1 for the space
01:964C 2AE410          	  1631: 		LD		HL,(FPREG)		; < Not needed >
01:964F 3A4210          	  1632: 		LD		A,(LWIDTH)		; Get width of line
01:9652 47              	  1633: 		LD		B,A				; To B
01:9653 04              	  1634: 		INC		B				; Width 255 (No limit)?
01:9654 CA6196          	  1635: 		JP		Z,PRNTNB		; Yes - Output number string
01:9657 04              	  1636: 		INC		B				; Adjust it
01:9658 3AAB10          	  1637: 		LD		A,(CURPOS)		; Get cursor position
01:965B 86              	  1638: 		ADD		A,(HL)			; Add length of string
01:965C 3D              	  1639: 		DEC		A				; Adjust it
01:965D B8              	  1640: 		CP		B				; Will output fit on this line?
01:965E D47F80          	  1641: 		CALL	NC,PrintCRLF		; No - CRLF first
01:9661 CD139D          	  1642: PRNTNB: CALL	PRS1			; Output string at (HL)
01:9664 AF              	  1643: 		XOR		A				; Skip CALL by setting 'z' flag
01:9665 C4139D          	  1644: PRNTST: CALL	NZ,PRS1			; Output string at (HL)
01:9668 E1              	  1645: 		POP		HL				; Restore code string address
01:9669 C31796          	  1646: 		JP		MRPRNT			; See if more to PRINT
                        	  1647: 
01:966C 3AAB10          	  1648: STTLIN: LD		A,(CURPOS)		; Make sure on new line
01:966F B7              	  1649: 		OR		A				; Already at start?
01:9670 C8              	  1650: 		RET		Z				; Yes - Do nothing
01:9671 C37F80          	  1651: 		JP		PrintCRLF		; Start a new line
                        	  1652: 
01:9674 3600            	  1653: ENDINP: LD		(HL),0			; Mark end of buffer
01:9676 216010          	  1654: 		LD		HL,BUFFER-1		; Point to buffer
01:9679 CD7F80          	  1655: 		call	PrintCRLF
01:967C AF              	  1656: DONULL: XOR		A				; Set to position 0
01:967D 32AB10          	  1657: 		LD		(CURPOS),A		; Store it
01:9680 3A4110          	  1658: 		LD		A,(NULLS)		; Get number of nulls
01:9683 3D              	  1659: NULLP:	DEC		A				; Count them
01:9684 C8              	  1660: 		RET		Z				; Return if done
01:9685 F5              	  1661: 		PUSH	AF				; Save count
01:9686 AF              	  1662: 		XOR		A				; Load a null
01:9687 CD4F92          	  1663: 		CALL	OUTC			; Output it
01:968A F1              	  1664: 		POP		AF				; Restore count
01:968B C38396          	  1665: 		JP		NULLP			; Keep counting
                        	  1666: 
01:968E 3A4310          	  1667: DOCOM:	LD		A,(COMMAN)		; Get comma width
01:9691 47              	  1668: 		LD		B,A				; Save in B
01:9692 3AAB10          	  1669: 		LD		A,(CURPOS)		; Get current position
01:9695 B8              	  1670: 		CP		B				; Within the limit?
01:9696 D47F80          	  1671: 		CALL	NC,PrintCRLF		; No - output CRLF
01:9699 D2C896          	  1672: 		JP		NC,NEXITM		; Get next item
01:969C D60E            	  1673: ZONELP: SUB		14				; Next zone of 14 characters
01:969E D29C96          	  1674: 		JP		NC,ZONELP		; Repeat if more zones
01:96A1 2F              	  1675: 		CPL						; Number of spaces to output
01:96A2 C3BD96          	  1676: 		JP		ASPCS			; Output them
                        	  1677: 
01:96A5 F5              	  1678: DOTAB:	PUSH	AF				; Save token
01:96A6 CD959F          	  1679: 		CALL	FNDNUM			; Evaluate expression
01:96A9 CD4492          	  1680: 		CALL	CHKSYN			; Make sure ")" follows
01:96AC 29              	  1681: 		db	")"
01:96AD 2B              	  1682: 		DEC		HL				; Back space on to ")"
01:96AE F1              	  1683: 		POP		AF				; Restore token
01:96AF D6A8            	  1684: 		SUB		ZSPC			; Was it "SPC(" ?
01:96B1 E5              	  1685: 		PUSH	HL				; Save code string address
01:96B2 CAB896          	  1686: 		JP		Z,DOSPC			; Yes - Do 'E' spaces
01:96B5 3AAB10          	  1687: 		LD		A,(CURPOS)		; Get current position
01:96B8 2F              	  1688: DOSPC:	CPL						; Number of spaces to print to
01:96B9 83              	  1689: 		ADD		A,E				; Total number to print
01:96BA D2C896          	  1690: 		JP		NC,NEXITM		; TAB < Current POS(X)
01:96BD 3C              	  1691: ASPCS:	INC		A				; Output A spaces
01:96BE 47              	  1692: 		LD		B,A				; Save number to print
01:96BF 3E20            	  1693: 		LD		A,' '			; Space
01:96C1 CD4F92          	  1694: SPCLP:	CALL	OUTC			; Output character in A
01:96C4 05              	  1695: 		DEC		B				; Count them
01:96C5 C2C196          	  1696: 		JP		NZ,SPCLP		; Repeat if more
01:96C8 E1              	  1697: NEXITM: POP		HL				; Restore code string address
01:96C9 CDCE93          	  1698: 		CALL	GETCHR			; Get next character
01:96CC C31E96          	  1699: 		JP		PRNTLP			; More to print
                        	  1700: 
01:96CF 3F5265646F206672	  1701: REDO:	db	"?Redo from start",CR,LF,0
01:96D7 6F6D207374617274
01:96DF 0D
01:96E0 0A
01:96E1 00
                        	  1702: 
01:96E2 3ACD10          	  1703: BADINP: LD		A,(READFG)		; READ or INPUT?
01:96E5 B7              	  1704: 		OR		A
01:96E6 C2708F          	  1705: 		JP		NZ,DATSNR		; READ - ?SN Error
01:96E9 C1              	  1706: 		POP		BC				; Throw away code string addr
01:96EA 21CF96          	  1707: 		LD		HL,REDO			; "Redo from start" message
01:96ED CD109D          	  1708: 		CALL	PRS				; Output string
01:96F0 C3C190          	  1709: 		JP		DOAGN			; Do last INPUT again
                        	  1710: 
01:96F3 CD7B9C          	  1711: INPUT:	CALL	IDTEST			; Test for illegal direct
01:96F6 7E              	  1712: 		LD		A,(HL)			; Get character after "INPUT"
01:96F7 FE22            	  1713: 		CP		'"'				; Is there a prompt string?
01:96F9 3E00            	  1714: 		LD		A,0				; Clear A and leave flags
01:96FB 324510          	  1715: 		LD		(CTLOFG),A		; Enable output
01:96FE C20D97          	  1716: 		JP		NZ,NOPMPT		; No prompt - get input
01:9701 CDCF9C          	  1717: 		CALL	QTSTR			; Get string terminated by '"'
01:9704 CD4492          	  1718: 		CALL	CHKSYN			; Check for ';' after prompt
01:9707 3B              	  1719: 		db	';'
01:9708 E5              	  1720: 		PUSH	HL				; Save code string address
01:9709 CD139D          	  1721: 		CALL	PRS1			; Output prompt string
01:970C 3E              	  1722: 		db	3EH				; Skip "PUSH HL"
01:970D E5              	  1723: NOPMPT: PUSH	HL				; Save code string address
01:970E CDC590          	  1724: 		CALL	PROMPT			; Get input with "? " prompt
01:9711 C1              	  1725: 		POP		BC				; Restore code string address
01:9712 DA2094          	  1726: 		JP		C,INPBRK		; Break pressed - Exit
01:9715 23              	  1727: 		INC		HL				; Next byte
01:9716 7E              	  1728: 		LD		A,(HL)			; Get it
01:9717 B7              	  1729: 		OR		A				; End of line?
01:9718 2B              	  1730: 		DEC		HL				; Back again
01:9719 C5              	  1731: 		PUSH	BC				; Re-save code string address
01:971A CA6795          	  1732: 		JP		Z,NXTDTA		; Yes - Find next DATA stmt
01:971D 362C            	  1733: 		LD		(HL),','		; Store comma as separator
01:971F C32797          	  1734: 		JP		NXTITM			; Get next item
                        	  1735: 
01:9722 E5              	  1736: READ:	PUSH	HL				; Save code string address
01:9723 2ADC10          	  1737: 		LD		HL,(NXTDAT)		; Next DATA statement
01:9726 F6              	  1738: 		db	0F6H			; Flag "READ"
01:9727 AF              	  1739: NXTITM: XOR		A				; Flag "INPUT"
01:9728 32CD10          	  1740: 		LD		(READFG),A		; Save "READ"/"INPUT" flag
01:972B E3              	  1741: 		EX		(SP),HL			; Get code str' , Save pointer
01:972C C33397          	  1742: 		JP		GTVLUS			; Get values
                        	  1743: 
01:972F CD4492          	  1744: NEDMOR: CALL	CHKSYN			; Check for comma between items
01:9732 2C              	  1745: 		db	   ','
01:9733 CD2D9A          	  1746: GTVLUS: CALL	GETVAR			; Get variable name
01:9736 E3              	  1747: 		EX		(SP),HL			; Save code str" , Get pointer
01:9737 D5              	  1748: 		PUSH	DE				; Save variable address
01:9738 7E              	  1749: 		LD		A,(HL)			; Get next "INPUT"/"DATA" byte
01:9739 FE2C            	  1750: 		CP		','				; Comma?
01:973B CA5B97          	  1751: 		JP		Z,ANTVLU		; Yes - Get another value
01:973E 3ACD10          	  1752: 		LD		A,(READFG)		; Is it READ?
01:9741 B7              	  1753: 		OR		A
01:9742 C2C897          	  1754: 		JP		NZ,FDTLP		; Yes - Find next DATA stmt
01:9745 3E3F            	  1755: 		LD		A,'?'			; More INPUT needed
01:9747 CD4F92          	  1756: 		CALL	OUTC			; Output character
01:974A CDC590          	  1757: 		CALL	PROMPT			; Get INPUT with prompt
01:974D D1              	  1758: 		POP		DE				; Variable address
01:974E C1              	  1759: 		POP		BC				; Code string address
01:974F DA2094          	  1760: 		JP		C,INPBRK		; Break pressed
01:9752 23              	  1761: 		INC		HL				; Point to next DATA byte
01:9753 7E              	  1762: 		LD		A,(HL)			; Get byte
01:9754 B7              	  1763: 		OR		A				; Is it zero (No input) ?
01:9755 2B              	  1764: 		DEC		HL				; Back space INPUT pointer
01:9756 C5              	  1765: 		PUSH	BC				; Save code string address
01:9757 CA6795          	  1766: 		JP		Z,NXTDTA		; Find end of buffer
01:975A D5              	  1767: 		PUSH	DE				; Save variable address
01:975B 3AAD10          	  1768: ANTVLU: LD		A,(TYPE)		; Check data type
01:975E B7              	  1769: 		OR		A				; Is it numeric?
01:975F CA8597          	  1770: 		JP		Z,INPBIN		; Yes - Convert to binary
01:9762 CDCE93          	  1771: 		CALL	GETCHR			; Get next character
01:9765 57              	  1772: 		LD		D,A				; Save input character
01:9766 47              	  1773: 		LD		B,A				; Again
01:9767 FE22            	  1774: 		CP		'"'				; Start of literal sting?"
01:9769 CA7997          	  1775: 		JP		Z,STRENT		; Yes - Create string entry
01:976C 3ACD10          	  1776: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:976F B7              	  1777: 		OR		A
01:9770 57              	  1778: 		LD		D,A				; Save 00 if "INPUT"
01:9771 CA7697          	  1779: 		JP		Z,ITMSEP		; "INPUT" - End with 00
01:9774 163A            	  1780: 		LD		D,':'			; "DATA" - End with 00 or ':'
01:9776 062C            	  1781: ITMSEP: LD		B,','			; Item separator
01:9778 2B              	  1782: 		DEC		HL				; Back space for DTSTR
01:9779 CDD29C          	  1783: STRENT: CALL	DTSTR			; Get string terminated by D
01:977C EB              	  1784: 		EX		DE,HL			; String address to DE
01:977D 219097          	  1785: 		LD		HL,LTSTND		; Where to go after LETSTR
01:9780 E3              	  1786: 		EX		(SP),HL			; Save HL , get input pointer
01:9781 D5              	  1787: 		PUSH	DE				; Save address of string
01:9782 C39A95          	  1788: 		JP		LETSTR			; Assign string to variable
                        	  1789: 
01:9785 CDCE93          	  1790: INPBIN: CALL	GETCHR			; Get next character
01:9788 CD20A3          	  1791: 		CALL	ASCTFP			; Convert ASCII to FP number
01:978B E3              	  1792: 		EX		(SP),HL			; Save input ptr, Get var addr
01:978C CD71A2          	  1793: 		CALL	FPTHL			; Move FPREG to variable
01:978F E1              	  1794: 		POP		HL				; Restore input pointer
01:9790 2B              	  1795: LTSTND: DEC		HL				; DEC 'cos GETCHR INCs
01:9791 CDCE93          	  1796: 		CALL	GETCHR			; Get next character
01:9794 CA9C97          	  1797: 		JP		Z,MORDT			; End of line - More needed?
01:9797 FE2C            	  1798: 		CP		','				; Another value?
01:9799 C2E296          	  1799: 		JP		NZ,BADINP		; No - Bad input
01:979C E3              	  1800: MORDT:	EX		(SP),HL			; Get code string address
01:979D 2B              	  1801: 		DEC		HL				; DEC 'cos GETCHR INCs
01:979E CDCE93          	  1802: 		CALL	GETCHR			; Get next character
01:97A1 C22F97          	  1803: 		JP		NZ,NEDMOR		; More needed - Get it
01:97A4 D1              	  1804: 		POP		DE				; Restore DATA pointer
01:97A5 3ACD10          	  1805: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:97A8 B7              	  1806: 		OR		A
01:97A9 EB              	  1807: 		EX		DE,HL			; DATA pointer to HL
01:97AA C2F493          	  1808: 		JP		NZ,UPDATA		; Update DATA pointer if "READ"
01:97AD D5              	  1809: 		PUSH	DE				; Save code string address
01:97AE B6              	  1810: 		OR		(HL)			; More input given?
01:97AF 21B797          	  1811: 		LD		HL,EXTIG		; "?Extra ignored" message
01:97B2 C4109D          	  1812: 		CALL	NZ,PRS			; Output string if extra given
01:97B5 E1              	  1813: 		POP		HL				; Restore code string address
01:97B6 C9              	  1814: 		RET
                        	  1815: 
01:97B7 3F45787472612069	  1816: EXTIG:	db	"?Extra ignored",CR,LF,0
01:97BF 676E6F726564
01:97C5 0D
01:97C6 0A
01:97C7 00
                        	  1817: 
01:97C8 CD6895          	  1818: FDTLP:	CALL	DATAA			; Get next statement
01:97CB B7              	  1819: 		OR		A				; End of line?
01:97CC C2E197          	  1820: 		JP		NZ,FANDT		; No - See if DATA statement
01:97CF 23              	  1821: 		INC		HL
01:97D0 7E              	  1822: 		LD		A,(HL)			; End of program?
01:97D1 23              	  1823: 		INC		HL
01:97D2 B6              	  1824: 		OR		(HL)			; 00 00 Ends program
01:97D3 1E06            	  1825: 		LD		E,OD			; ?OD Error
01:97D5 CA8A8F          	  1826: 		JP		Z,ERROR			; Yes - Out of DATA
01:97D8 23              	  1827: 		INC		HL
01:97D9 5E              	  1828: 		LD		E,(HL)			; LSB of line number
01:97DA 23              	  1829: 		INC		HL
01:97DB 56              	  1830: 		LD		D,(HL)			; MSB of line number
01:97DC EB              	  1831: 		EX		DE,HL
01:97DD 22C910          	  1832: 		LD		(DATLIN),HL		; Set line of current DATA item
01:97E0 EB              	  1833: 		EX		DE,HL
01:97E1 CDCE93          	  1834: FANDT:	CALL	GETCHR			; Get next character
01:97E4 FE83            	  1835: 		CP		ZDATA			; "DATA" token
01:97E6 C2C897          	  1836: 		JP		NZ,FDTLP		; No "DATA" - Keep looking
01:97E9 C35B97          	  1837: 		JP		ANTVLU			; Found - Convert input
                        	  1838: 
01:97EC 110000          	  1839: NEXT:	LD		DE,0			; In case no index given
01:97EF C42D9A          	  1840: NEXT1:	CALL	NZ,GETVAR		; Get index address
01:97F2 22CE10          	  1841: 		LD		(BRKLIN),HL		; Save code string address
01:97F5 CD1F8F          	  1842: 		CALL	BAKSTK			; Look for "FOR" block
01:97F8 C27C8F          	  1843: 		JP		NZ,NFERR		; No "FOR" - ?NF Error
01:97FB F9              	  1844: 		LD		SP,HL			; Clear nested loops
01:97FC D5              	  1845: 		PUSH	DE				; Save index address
01:97FD 7E              	  1846: 		LD		A,(HL)			; Get sign of STEP
01:97FE 23              	  1847: 		INC		HL
01:97FF F5              	  1848: 		PUSH	AF				; Save sign of STEP
01:9800 D5              	  1849: 		PUSH	DE				; Save index address
01:9801 CD57A2          	  1850: 		CALL	PHLTFP			; Move index value to FPREG
01:9804 E3              	  1851: 		EX		(SP),HL			; Save address of TO value
01:9805 E5              	  1852: 		PUSH	HL				; Save address of index
01:9806 CDC49F          	  1853: 		CALL	ADDPHL			; Add STEP to index value
01:9809 E1              	  1854: 		POP		HL				; Restore address of index
01:980A CD71A2          	  1855: 		CALL	FPTHL			; Move value to index variable
01:980D E1              	  1856: 		POP		HL				; Restore address of TO value
01:980E CD68A2          	  1857: 		CALL	LOADFP			; Move TO value to BCDE
01:9811 E5              	  1858: 		PUSH	HL				; Save address of line of FOR
01:9812 CD94A2          	  1859: 		CALL	CMPNUM			; Compare index with TO value
01:9815 E1              	  1860: 		POP		HL				; Restore address of line num
01:9816 C1              	  1861: 		POP		BC				; Address of sign of STEP
01:9817 90              	  1862: 		SUB		B				; Compare with expected sign
01:9818 CD68A2          	  1863: 		CALL	LOADFP			; BC = Loop stmt,DE = Line num
01:981B CA2798          	  1864: 		JP		Z,KILFOR		; Loop finished - Terminate it
01:981E EB              	  1865: 		EX		DE,HL			; Loop statement line number
01:981F 225C10          	  1866: 		LD		(LINEAT),HL		; Set loop line number
01:9822 69              	  1867: 		LD		L,C				; Set code string to loop
01:9823 60              	  1868: 		LD		H,B
01:9824 C38A93          	  1869: 		JP		PUTFID			; Put back "FOR" and continue
                        	  1870: 
01:9827 F9              	  1871: KILFOR: LD		SP,HL			; Remove "FOR" block
01:9828 2ACE10          	  1872: 		LD		HL,(BRKLIN)		; Code string after "NEXT"
01:982B 7E              	  1873: 		LD		A,(HL)			; Get next byte in code string
01:982C FE2C            	  1874: 		CP		','				; More NEXTs ?
01:982E C28E93          	  1875: 		JP		NZ,RUNCNT		; No - Do next statement
01:9831 CDCE93          	  1876: 		CALL	GETCHR			; Position to index name
01:9834 CDEF97          	  1877: 		CALL	NEXT1			; Re-enter NEXT routine
                        	  1878: ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        	  1879: 
01:9837 CD4998          	  1880: GETNUM: CALL	EVAL			; Get a numeric expression
01:983A F6              	  1881: TSTNUM: db	   0F6H			   ; Clear carry (numeric)
01:983B 37              	  1882: TSTSTR: SCF						; Set carry (string)
01:983C 3AAD10          	  1883: CHKTYP: LD		A,(TYPE)		; Check types match
01:983F 8F              	  1884: 		ADC		A,A				; Expected + actual
01:9840 B7              	  1885: 		OR		A				; Clear carry , set parity
01:9841 E8              	  1886: 		RET		PE				; Even parity - Types match
01:9842 C3888F          	  1887: 		JP		TMERR			; Different types - Error
                        	  1888: 
01:9845 CD4492          	  1889: OPNPAR: CALL	CHKSYN			; Make sure "(" follows
01:9848 28              	  1890: 		db	"("
01:9849 2B              	  1891: EVAL:	DEC		HL				; Evaluate expression & save
01:984A 1600            	  1892: 		LD		D,0				; Precedence value
01:984C D5              	  1893: EVAL1:	PUSH	DE				; Save precedence
01:984D 0E01            	  1894: 		LD		C,1
01:984F CD538F          	  1895: 		CALL	CHKSTK			; Check for 1 level of stack
01:9852 CDC098          	  1896: 		CALL	OPRND			; Get next expression value
01:9855 22D010          	  1897: EVAL2:	LD		(NXTOPR),HL		; Save address of next operator
01:9858 2AD010          	  1898: EVAL3:	LD		HL,(NXTOPR)		; Restore address of next opr
01:985B C1              	  1899: 		POP		BC				; Precedence value and operator
01:985C 78              	  1900: 		LD		A,B				; Get precedence value
01:985D FE78            	  1901: 		CP		78H				; "AND" or "OR" ?
01:985F D43A98          	  1902: 		CALL	NC,TSTNUM		; No - Make sure it's a number
01:9862 7E              	  1903: 		LD		A,(HL)			; Get next operator / function
01:9863 1600            	  1904: 		LD		D,0				; Clear Last relation
01:9865 D6B3            	  1905: RLTLP:	SUB		ZGTR			; ">" Token
01:9867 DA8198          	  1906: 		JP		C,FOPRND		; + - * / ^ AND OR - Test it
01:986A FE03            	  1907: 		CP		ZLTH+1-ZGTR		; < = >
01:986C D28198          	  1908: 		JP		NC,FOPRND		; Function - Call it
01:986F FE01            	  1909: 		CP		ZEQUAL-ZGTR		; "="
01:9871 17              	  1910: 		RLA						; <- Test for legal
01:9872 AA              	  1911: 		XOR		D				; <- combinations of < = >
01:9873 BA              	  1912: 		CP		D				; <- by combining last token
01:9874 57              	  1913: 		LD		D,A				; <- with current one
01:9875 DA768F          	  1914: 		JP		C,SNERR			; Error if "<<' '==" or ">>"
01:9878 22C510          	  1915: 		LD		(CUROPR),HL		; Save address of current token
01:987B CDCE93          	  1916: 		CALL	GETCHR			; Get next character
01:987E C36598          	  1917: 		JP		RLTLP			; Treat the two as one
                        	  1918: 
01:9881 7A              	  1919: FOPRND: LD		A,D				; < = > found ?
01:9882 B7              	  1920: 		OR		A
01:9883 C2A899          	  1921: 		JP		NZ,TSTRED		; Yes - Test for reduction
01:9886 7E              	  1922: 		LD		A,(HL)			; Get operator token
01:9887 22C510          	  1923: 		LD		(CUROPR),HL		; Save operator address
01:988A D6AC            	  1924: 		SUB		ZPLUS			; Operator or function?
01:988C D8              	  1925: 		RET		C				; Neither - Exit
01:988D FE07            	  1926: 		CP		ZOR+1-ZPLUS		; Is it + - * / ^ AND OR ?
01:988F D0              	  1927: 		RET		NC				; No - Exit
01:9890 5F              	  1928: 		LD		E,A				; Coded operator
01:9891 3AAD10          	  1929: 		LD		A,(TYPE)		; Get data type
01:9894 3D              	  1930: 		DEC		A				; FF = numeric , 00 = string
01:9895 B3              	  1931: 		OR		E				; Combine with coded operator
01:9896 7B              	  1932: 		LD		A,E				; Get coded operator
01:9897 CA069E          	  1933: 		JP		Z,CONCAT		; String concatenation
01:989A 07              	  1934: 		RLCA					; Times 2
01:989B 83              	  1935: 		ADD		A,E				; Times 3
01:989C 5F              	  1936: 		LD		E,A				; To DE (D is 0)
01:989D 21688E          	  1937: 		LD		HL,PRITAB		; Precedence table
01:98A0 19              	  1938: 		ADD		HL,DE			; To the operator concerned
01:98A1 78              	  1939: 		LD		A,B				; Last operator precedence
01:98A2 56              	  1940: 		LD		D,(HL)			; Get evaluation precedence
01:98A3 BA              	  1941: 		CP		D				; Compare with eval precedence
01:98A4 D0              	  1942: 		RET		NC				; Exit if higher precedence
01:98A5 23              	  1943: 		INC		HL				; Point to routine address
01:98A6 CD3A98          	  1944: 		CALL	TSTNUM			; Make sure it's a number
                        	  1945: 
01:98A9 C5              	  1946: STKTHS: PUSH	BC				; Save last precedence & token
01:98AA 015898          	  1947: 		LD		BC,EVAL3		; Where to go on prec' break
01:98AD C5              	  1948: 		PUSH	BC				; Save on stack for return
01:98AE 43              	  1949: 		LD		B,E				; Save operator
01:98AF 4A              	  1950: 		LD		C,D				; Save precedence
01:98B0 CD4AA2          	  1951: 		CALL	STAKFP			; Move value to stack
01:98B3 58              	  1952: 		LD		E,B				; Restore operator
01:98B4 51              	  1953: 		LD		D,C				; Restore precedence
01:98B5 4E              	  1954: 		LD		C,(HL)			; Get LSB of routine address
01:98B6 23              	  1955: 		INC		HL
01:98B7 46              	  1956: 		LD		B,(HL)			; Get MSB of routine address
01:98B8 23              	  1957: 		INC		HL
01:98B9 C5              	  1958: 		PUSH	BC				; Save routine address
01:98BA 2AC510          	  1959: 		LD		HL,(CUROPR)		; Address of current operator
01:98BD C34C98          	  1960: 		JP		EVAL1			; Loop until prec' break
                        	  1961: 
01:98C0 AF              	  1962: OPRND:	XOR		A				; Get operand routine
01:98C1 32AD10          	  1963: 		LD		(TYPE),A		; Set numeric expected
01:98C4 CDCE93          	  1964: 		CALL	GETCHR			; Get next character
01:98C7 1E24            	  1965: 		LD		E,MO			; ?MO Error
01:98C9 CA8A8F          	  1966: 		JP		Z,ERROR			; No operand - Error
01:98CC DA20A3          	  1967: 		JP		C,ASCTFP		; Number - Get value
01:98CF CD6F94          	  1968: 		CALL	CHKLTR			; See if a letter
01:98D2 D22799          	  1969: 		JP		NC,CONVAR		; Letter - Find variable
01:98D5 FE26            	  1970: 		CP		'&'				; &H = HEX, &B = BINARY
01:98D7 2012            	  1971: 		JR		NZ, NOTAMP
01:98D9 CDCE93          	  1972: 		CALL	GETCHR			; Get next character
01:98DC FE48            	  1973: 		CP		'H'				; Hex number indicated? [function added]
01:98DE CA68A7          	  1974: 		JP		Z,HEXTFP		; Convert Hex to FPREG
01:98E1 FE42            	  1975: 		CP		'B'				; Binary number indicated? [function added]
01:98E3 CAD8A7          	  1976: 		JP		Z,BINTFP		; Convert Bin to FPREG
01:98E6 1E02            	  1977: 		LD		E,SN			; If neither then a ?SN Error
01:98E8 CA8A8F          	  1978: 		JP		Z,ERROR			; 
01:98EB FEAC            	  1979: NOTAMP: CP		ZPLUS			; '+' Token ?
01:98ED CAC098          	  1980: 		JP		Z,OPRND			; Yes - Look for operand
01:98F0 FE2E            	  1981: 		CP		'.'				; '.' ?
01:98F2 CA20A3          	  1982: 		JP		Z,ASCTFP		; Yes - Create FP number
01:98F5 FEAD            	  1983: 		CP		ZMINUS			; '-' Token ?
01:98F7 CA1699          	  1984: 		JP		Z,MINUS			; Yes - Do minus
01:98FA FE22            	  1985: 		CP		'"'				; Literal string ?
01:98FC CACF9C          	  1986: 		JP		Z,QTSTR			; Get string terminated by '"'
01:98FF FEAA            	  1987: 		CP		ZNOT			; "NOT" Token ?
01:9901 CA089A          	  1988: 		JP		Z,EVNOT			; Yes - Eval NOT expression
01:9904 FEA7            	  1989: 		CP		ZFN				; "FN" Token ?
01:9906 CA339C          	  1990: 		JP		Z,DOFN			; Yes - Do FN routine
01:9909 D6B6            	  1991: 		SUB		ZSGN			; Is it a function?
01:990B D23899          	  1992: 		JP		NC,FNOFST		; Yes - Evaluate function
01:990E CD4598          	  1993: EVLPAR: CALL	OPNPAR			; Evaluate expression in "()"
01:9911 CD4492          	  1994: 		CALL	CHKSYN			; Make sure ")" follows
01:9914 29              	  1995: 		db	")"
01:9915 C9              	  1996: 		RET
                        	  1997: 
01:9916 167D            	  1998: MINUS:	LD		D,7DH			; '-' precedence
01:9918 CD4C98          	  1999: 		CALL	EVAL1			; Evaluate until prec' break
01:991B 2AD010          	  2000: 		LD		HL,(NXTOPR)		; Get next operator address
01:991E E5              	  2001: 		PUSH	HL				; Save next operator address
01:991F CD42A2          	  2002: 		CALL	INVSGN			; Negate value
01:9922 CD3A98          	  2003: RETNUM: CALL	TSTNUM			; Make sure it's a number
01:9925 E1              	  2004: 		POP		HL				; Restore next operator address
01:9926 C9              	  2005: 		RET
                        	  2006: 
01:9927 CD2D9A          	  2007: CONVAR: CALL	GETVAR			; Get variable address to DE
01:992A E5              	  2008: FRMEVL: PUSH	HL				; Save code string address
01:992B EB              	  2009: 		EX		DE,HL			; Variable address to HL
01:992C 22E410          	  2010: 		LD		(FPREG),HL		; Save address of variable
01:992F 3AAD10          	  2011: 		LD		A,(TYPE)		; Get type
01:9932 B7              	  2012: 		OR		A				; Numeric?
01:9933 CC57A2          	  2013: 		CALL	Z,PHLTFP		; Yes - Move contents to FPREG
01:9936 E1              	  2014: 		POP		HL				; Restore code string address
01:9937 C9              	  2015: 		RET
                        	  2016: 
01:9938 0600            	  2017: FNOFST: LD		B,0				; Get address of function
01:993A 07              	  2018: 		RLCA					; Double function offset
01:993B 4F              	  2019: 		LD		C,A				; BC = Offset in function table
01:993C C5              	  2020: 		PUSH	BC				; Save adjusted token value
01:993D CDCE93          	  2021: 		CALL	GETCHR			; Get next character
01:9940 79              	  2022: 		LD		A,C				; Get adjusted token value
01:9941 FE31            	  2023: 		CP		2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
01:9943 DA5F99          	  2024: 		JP		C,FNVAL			; No - Do function
01:9946 CD4598          	  2025: 		CALL	OPNPAR			; Evaluate expression  (X,...
01:9949 CD4492          	  2026: 		CALL	CHKSYN			; Make sure ',' follows
01:994C 2C              	  2027: 		db	   ','
01:994D CD3B98          	  2028: 		CALL	TSTSTR			; Make sure it's a string
01:9950 EB              	  2029: 		EX		DE,HL			; Save code string address
01:9951 2AE410          	  2030: 		LD		HL,(FPREG)		; Get address of string
01:9954 E3              	  2031: 		EX		(SP),HL			; Save address of string
01:9955 E5              	  2032: 		PUSH	HL				; Save adjusted token value
01:9956 EB              	  2033: 		EX		DE,HL			; Restore code string address
01:9957 CD989F          	  2034: 		CALL	GETINT			; Get integer 0-255
01:995A EB              	  2035: 		EX		DE,HL			; Save code string address
01:995B E3              	  2036: 		EX		(SP),HL			; Save integer,HL = adj' token
01:995C C36799          	  2037: 		JP		GOFUNC			; Jump to string function
                        	  2038: 
01:995F CD0E99          	  2039: FNVAL:	CALL	EVLPAR			; Evaluate expression
01:9962 E3              	  2040: 		EX		(SP),HL			; HL = Adjusted token value
01:9963 112299          	  2041: 		LD		DE,RETNUM		; Return number from function
01:9966 D5              	  2042: 		PUSH	DE				; Save on stack
01:9967 01C18C          	  2043: GOFUNC: LD		BC,FNCTAB		; Function routine addresses
01:996A 09              	  2044: 		ADD		HL,BC			; Point to right address
01:996B 4E              	  2045: 		LD		C,(HL)			; Get LSB of address
01:996C 23              	  2046: 		INC		HL				;
01:996D 66              	  2047: 		LD		H,(HL)			; Get MSB of address
01:996E 69              	  2048: 		LD		L,C				; Address to HL
01:996F E9              	  2049: 		JP		(HL)			; Jump to function
                        	  2050: 
01:9970 15              	  2051: SGNEXP: DEC		D				; Dee to flag negative exponent
01:9971 FEAD            	  2052: 		CP		ZMINUS			; '-' token ?
01:9973 C8              	  2053: 		RET		Z				; Yes - Return
01:9974 FE2D            	  2054: 		CP		'-'				; '-' ASCII ?
01:9976 C8              	  2055: 		RET		Z				; Yes - Return
01:9977 14              	  2056: 		INC		D				; Inc to flag positive exponent
01:9978 FE2B            	  2057: 		CP		'+'				; '+' ASCII ?
01:997A C8              	  2058: 		RET		Z				; Yes - Return
01:997B FEAC            	  2059: 		CP		ZPLUS			; '+' token ?
01:997D C8              	  2060: 		RET		Z				; Yes - Return
01:997E 2B              	  2061: 		DEC		HL				; DEC 'cos GETCHR INCs
01:997F C9              	  2062: 		RET						; Return "NZ"
                        	  2063: 
01:9980 F6              	  2064: POR:	db	   0F6H			   ; Flag "OR"
01:9981 AF              	  2065: PAND:	XOR		A				; Flag "AND"
01:9982 F5              	  2066: 		PUSH	AF				; Save "AND" / "OR" flag
01:9983 CD3A98          	  2067: 		CALL	TSTNUM			; Make sure it's a number
01:9986 CD8394          	  2068: 		CALL	DEINT			; Get integer -32768 to 32767
01:9989 F1              	  2069: 		POP		AF				; Restore "AND" / "OR" flag
01:998A EB              	  2070: 		EX		DE,HL			; <- Get last
01:998B C1              	  2071: 		POP		BC				; <-  value
01:998C E3              	  2072: 		EX		(SP),HL			; <-  from
01:998D EB              	  2073: 		EX		DE,HL			; <-  stack
01:998E CD5AA2          	  2074: 		CALL	FPBCDE			; Move last value to FPREG
01:9991 F5              	  2075: 		PUSH	AF				; Save "AND" / "OR" flag
01:9992 CD8394          	  2076: 		CALL	DEINT			; Get integer -32768 to 32767
01:9995 F1              	  2077: 		POP		AF				; Restore "AND" / "OR" flag
01:9996 C1              	  2078: 		POP		BC				; Get value
01:9997 79              	  2079: 		LD		A,C				; Get LSB
01:9998 21F19B          	  2080: 		LD		HL,ACPASS		; Address of save AC as current
01:999B C2A399          	  2081: 		JP		NZ,POR1			; Jump if OR
01:999E A3              	  2082: 		AND		E				; "AND" LSBs
01:999F 4F              	  2083: 		LD		C,A				; Save LSB
01:99A0 78              	  2084: 		LD		A,B				; Get MBS
01:99A1 A2              	  2085: 		AND		D				; "AND" MSBs
01:99A2 E9              	  2086: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2087: 
01:99A3 B3              	  2088: POR1:	OR		E				; "OR" LSBs
01:99A4 4F              	  2089: 		LD		C,A				; Save LSB
01:99A5 78              	  2090: 		LD		A,B				; Get MSB
01:99A6 B2              	  2091: 		OR		D				; "OR" MSBs
01:99A7 E9              	  2092: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2093: 
01:99A8 21BA99          	  2094: TSTRED: LD		HL,CMPLOG		; Logical compare routine
01:99AB 3AAD10          	  2095: 		LD		A,(TYPE)		; Get data type
01:99AE 1F              	  2096: 		RRA						; Carry set = string
01:99AF 7A              	  2097: 		LD		A,D				; Get last precedence value
01:99B0 17              	  2098: 		RLA						; Times 2 plus carry
01:99B1 5F              	  2099: 		LD		E,A				; To E
01:99B2 1664            	  2100: 		LD		D,64H			; Relational precedence
01:99B4 78              	  2101: 		LD		A,B				; Get current precedence
01:99B5 BA              	  2102: 		CP		D				; Compare with last
01:99B6 D0              	  2103: 		RET		NC				; Eval if last was rel' or log'
01:99B7 C3A998          	  2104: 		JP		STKTHS			; Stack this one and get next
                        	  2105: 
01:99BA BC99            	  2106: CMPLOG: dw	CMPLG1			; Compare two values / strings
01:99BC 79              	  2107: CMPLG1: LD		A,C				; Get data type
01:99BD B7              	  2108: 		OR		A
01:99BE 1F              	  2109: 		RRA
01:99BF C1              	  2110: 		POP		BC				; Get last expression to BCDE
01:99C0 D1              	  2111: 		POP		DE
01:99C1 F5              	  2112: 		PUSH	AF				; Save status
01:99C2 CD3C98          	  2113: 		CALL	CHKTYP			; Check that types match
01:99C5 21FE99          	  2114: 		LD		HL,CMPRES		; Result to comparison
01:99C8 E5              	  2115: 		PUSH	HL				; Save for RETurn
01:99C9 CA94A2          	  2116: 		JP		Z,CMPNUM		; Compare values if numeric
01:99CC AF              	  2117: 		XOR		A				; Compare two strings
01:99CD 32AD10          	  2118: 		LD		(TYPE),A		; Set type to numeric
01:99D0 D5              	  2119: 		PUSH	DE				; Save string name
01:99D1 CD539E          	  2120: 		CALL	GSTRCU			; Get current string
01:99D4 7E              	  2121: 		LD		A,(HL)			; Get length of string
01:99D5 23              	  2122: 		INC		HL
01:99D6 23              	  2123: 		INC		HL
01:99D7 4E              	  2124: 		LD		C,(HL)			; Get LSB of address
01:99D8 23              	  2125: 		INC		HL
01:99D9 46              	  2126: 		LD		B,(HL)			; Get MSB of address
01:99DA D1              	  2127: 		POP		DE				; Restore string name
01:99DB C5              	  2128: 		PUSH	BC				; Save address of string
01:99DC F5              	  2129: 		PUSH	AF				; Save length of string
01:99DD CD579E          	  2130: 		CALL	GSTRDE			; Get second string
01:99E0 CD68A2          	  2131: 		CALL	LOADFP			; Get address of second string
01:99E3 F1              	  2132: 		POP		AF				; Restore length of string 1
01:99E4 57              	  2133: 		LD		D,A				; Length to D
01:99E5 E1              	  2134: 		POP		HL				; Restore address of string 1
01:99E6 7B              	  2135: CMPSTR: LD		A,E				; Bytes of string 2 to do
01:99E7 B2              	  2136: 		OR		D				; Bytes of string 1 to do
01:99E8 C8              	  2137: 		RET		Z				; Exit if all bytes compared
01:99E9 7A              	  2138: 		LD		A,D				; Get bytes of string 1 to do
01:99EA D601            	  2139: 		SUB		1
01:99EC D8              	  2140: 		RET		C				; Exit if end of string 1
01:99ED AF              	  2141: 		XOR		A
01:99EE BB              	  2142: 		CP		E				; Bytes of string 2 to do
01:99EF 3C              	  2143: 		INC		A
01:99F0 D0              	  2144: 		RET		NC				; Exit if end of string 2
01:99F1 15              	  2145: 		DEC		D				; Count bytes in string 1
01:99F2 1D              	  2146: 		DEC		E				; Count bytes in string 2
01:99F3 0A              	  2147: 		LD		A,(BC)			; Byte in string 2
01:99F4 BE              	  2148: 		CP		(HL)			; Compare to byte in string 1
01:99F5 23              	  2149: 		INC		HL				; Move up string 1
01:99F6 03              	  2150: 		INC		BC				; Move up string 2
01:99F7 CAE699          	  2151: 		JP		Z,CMPSTR		; Same - Try next bytes
01:99FA 3F              	  2152: 		CCF						; Flag difference (">" or "<")
01:99FB C324A2          	  2153: 		JP		FLGDIF			; "<" gives -1 , ">" gives +1
                        	  2154: 
01:99FE 3C              	  2155: CMPRES: INC		A				; Increment current value
01:99FF 8F              	  2156: 		ADC		A,A				; Double plus carry
01:9A00 C1              	  2157: 		POP		BC				; Get other value
01:9A01 A0              	  2158: 		AND		B				; Combine them
01:9A02 C6FF            	  2159: 		ADD		A,-1			; Carry set if different
01:9A04 9F              	  2160: 		SBC		A,A				; 00 - Equal , FF - Different
01:9A05 C32BA2          	  2161: 		JP		FLGREL			; Set current value & continue
                        	  2162: 
01:9A08 165A            	  2163: EVNOT:	LD		D,5AH			; Precedence value for "NOT"
01:9A0A CD4C98          	  2164: 		CALL	EVAL1			; Eval until precedence break
01:9A0D CD3A98          	  2165: 		CALL	TSTNUM			; Make sure it's a number
01:9A10 CD8394          	  2166: 		CALL	DEINT			; Get integer -32768 - 32767
01:9A13 7B              	  2167: 		LD		A,E				; Get LSB
01:9A14 2F              	  2168: 		CPL						; Invert LSB
01:9A15 4F              	  2169: 		LD		C,A				; Save "NOT" of LSB
01:9A16 7A              	  2170: 		LD		A,D				; Get MSB
01:9A17 2F              	  2171: 		CPL						; Invert MSB
01:9A18 CDF19B          	  2172: 		CALL	ACPASS			; Save AC as current
01:9A1B C1              	  2173: 		POP		BC				; Clean up stack
01:9A1C C35898          	  2174: 		JP		EVAL3			; Continue evaluation
                        	  2175: 
01:9A1F 2B              	  2176: DIMRET: DEC		HL				; DEC 'cos GETCHR INCs
01:9A20 CDCE93          	  2177: 		CALL	GETCHR			; Get next character
01:9A23 C8              	  2178: 		RET		Z				; End of DIM statement
01:9A24 CD4492          	  2179: 		CALL	CHKSYN			; Make sure ',' follows
01:9A27 2C              	  2180: 		db	   ','
01:9A28 011F9A          	  2181: DIM:	LD		BC,DIMRET		; Return to "DIMRET"
01:9A2B C5              	  2182: 		PUSH	BC				; Save on stack
01:9A2C F6              	  2183: 		db	   0F6H			   ; Flag "Create" variable
01:9A2D AF              	  2184: GETVAR: XOR		A				; Find variable address,to DE
01:9A2E 32AC10          	  2185: 		LD		(LCRFLG),A		; Set locate / create flag
01:9A31 46              	  2186: 		LD		B,(HL)			; Get First byte of name
01:9A32 CD6F94          	  2187: GTFNAM: CALL	CHKLTR			; See if a letter
01:9A35 DA768F          	  2188: 		JP		C,SNERR			; ?SN Error if not a letter
01:9A38 AF              	  2189: 		XOR		A
01:9A39 4F              	  2190: 		LD		C,A				; Clear second byte of name
01:9A3A 32AD10          	  2191: 		LD		(TYPE),A		; Set type to numeric
01:9A3D CDCE93          	  2192: 		CALL	GETCHR			; Get next character
01:9A40 DA499A          	  2193: 		JP		C,SVNAM2		; Numeric - Save in name
01:9A43 CD6F94          	  2194: 		CALL	CHKLTR			; See if a letter
01:9A46 DA569A          	  2195: 		JP		C,CHARTY		; Not a letter - Check type
01:9A49 4F              	  2196: SVNAM2: LD		C,A				; Save second byte of name
01:9A4A CDCE93          	  2197: ENDNAM: CALL	GETCHR			; Get next character
01:9A4D DA4A9A          	  2198: 		JP		C,ENDNAM		; Numeric - Get another
01:9A50 CD6F94          	  2199: 		CALL	CHKLTR			; See if a letter
01:9A53 D24A9A          	  2200: 		JP		NC,ENDNAM		; Letter - Get another
01:9A56 D624            	  2201: CHARTY: SUB		'$'				; String variable?
01:9A58 C2659A          	  2202: 		JP		NZ,NOTSTR		; No - Numeric variable
01:9A5B 3C              	  2203: 		INC		A				; A = 1 (string type)
01:9A5C 32AD10          	  2204: 		LD		(TYPE),A		; Set type to string
01:9A5F 0F              	  2205: 		RRCA					; A = 80H , Flag for string
01:9A60 81              	  2206: 		ADD		A,C				; 2nd byte of name has bit 7 on
01:9A61 4F              	  2207: 		LD		C,A				; Resave second byte on name
01:9A62 CDCE93          	  2208: 		CALL	GETCHR			; Get next character
01:9A65 3ACB10          	  2209: NOTSTR: LD		A,(FORFLG)		; Array name needed ?
01:9A68 3D              	  2210: 		DEC		A
01:9A69 CA129B          	  2211: 		JP		Z,ARLDSV		; Yes - Get array name
01:9A6C F2759A          	  2212: 		JP		P,NSCFOR		; No array with "FOR" or "FN"
01:9A6F 7E              	  2213: 		LD		A,(HL)			; Get byte again
01:9A70 D628            	  2214: 		SUB		'('				; Subscripted variable?
01:9A72 CAEA9A          	  2215: 		JP		Z,SBSCPT		; Yes - Sort out subscript
                        	  2216: 
01:9A75 AF              	  2217: NSCFOR: XOR		A				; Simple variable
01:9A76 32CB10          	  2218: 		LD		(FORFLG),A		; Clear "FOR" flag
01:9A79 E5              	  2219: 		PUSH	HL				; Save code string address
01:9A7A 50              	  2220: 		LD		D,B				; DE = Variable name to find
01:9A7B 59              	  2221: 		LD		E,C
01:9A7C 2ADE10          	  2222: 		LD		HL,(FNRGNM)		; FN argument name
01:9A7F CD3E92          	  2223: 		CALL	CPDEHL			; Is it the FN argument?
01:9A82 11E010          	  2224: 		LD		DE,FNARG		; Point to argument value
01:9A85 CA5AA1          	  2225: 		JP		Z,POPHRT		; Yes - Return FN argument value
01:9A88 2AD810          	  2226: 		LD		HL,(VAREND)		; End of variables
01:9A8B EB              	  2227: 		EX		DE,HL			; Address of end of search
01:9A8C 2AD610          	  2228: 		LD		HL,(PROGND)		; Start of variables address
01:9A8F CD3E92          	  2229: FNDVAR: CALL	CPDEHL			; End of variable list table?
01:9A92 CAA89A          	  2230: 		JP		Z,CFEVAL		; Yes - Called from EVAL?
01:9A95 79              	  2231: 		LD		A,C				; Get second byte of name
01:9A96 96              	  2232: 		SUB		(HL)			; Compare with name in list
01:9A97 23              	  2233: 		INC		HL				; Move on to first byte
01:9A98 C29D9A          	  2234: 		JP		NZ,FNTHR		; Different - Find another
01:9A9B 78              	  2235: 		LD		A,B				; Get first byte of name
01:9A9C 96              	  2236: 		SUB		(HL)			; Compare with name in list
01:9A9D 23              	  2237: FNTHR:	INC		HL				; Move on to LSB of value
01:9A9E CADC9A          	  2238: 		JP		Z,RETADR		; Found - Return address
01:9AA1 23              	  2239: 		INC		HL				; <- Skip
01:9AA2 23              	  2240: 		INC		HL				; <- over
01:9AA3 23              	  2241: 		INC		HL				; <- F.P.
01:9AA4 23              	  2242: 		INC		HL				; <- value
01:9AA5 C38F9A          	  2243: 		JP		FNDVAR			; Keep looking
                        	  2244: 
01:9AA8 E1              	  2245: CFEVAL: POP		HL				; Restore code string address
01:9AA9 E3              	  2246: 		EX		(SP),HL			; Get return address
01:9AAA D5              	  2247: 		PUSH	DE				; Save address of variable
01:9AAB 112A99          	  2248: 		LD		DE,FRMEVL		; Return address in EVAL
01:9AAE CD3E92          	  2249: 		CALL	CPDEHL			; Called from EVAL ?
01:9AB1 D1              	  2250: 		POP		DE				; Restore address of variable
01:9AB2 CADF9A          	  2251: 		JP		Z,RETNUL		; Yes - Return null variable
01:9AB5 E3              	  2252: 		EX		(SP),HL			; Put back return
01:9AB6 E5              	  2253: 		PUSH	HL				; Save code string address
01:9AB7 C5              	  2254: 		PUSH	BC				; Save variable name
01:9AB8 010600          	  2255: 		LD		BC,6			; 2 byte name plus 4 byte data
01:9ABB 2ADA10          	  2256: 		LD		HL,(ARREND)		; End of arrays
01:9ABE E5              	  2257: 		PUSH	HL				; Save end of arrays
01:9ABF 09              	  2258: 		ADD		HL,BC			; Move up 6 bytes
01:9AC0 C1              	  2259: 		POP		BC				; Source address in BC
01:9AC1 E5              	  2260: 		PUSH	HL				; Save new end address
01:9AC2 CD428F          	  2261: 		CALL	MOVUP			; Move arrays up
01:9AC5 E1              	  2262: 		POP		HL				; Restore new end address
01:9AC6 22DA10          	  2263: 		LD		(ARREND),HL		; Set new end address
01:9AC9 60              	  2264: 		LD		H,B				; End of variables to HL
01:9ACA 69              	  2265: 		LD		L,C
01:9ACB 22D810          	  2266: 		LD		(VAREND),HL		; Set new end address
                        	  2267: 
01:9ACE 2B              	  2268: ZEROLP: DEC		HL				; Back through to zero variable
01:9ACF 3600            	  2269: 		LD		(HL),0			; Zero byte in variable
01:9AD1 CD3E92          	  2270: 		CALL	CPDEHL			; Done them all?
01:9AD4 C2CE9A          	  2271: 		JP		NZ,ZEROLP		; No - Keep on going
01:9AD7 D1              	  2272: 		POP		DE				; Get variable name
01:9AD8 73              	  2273: 		LD		(HL),E			; Store second character
01:9AD9 23              	  2274: 		INC		HL
01:9ADA 72              	  2275: 		LD		(HL),D			; Store first character
01:9ADB 23              	  2276: 		INC		HL
01:9ADC EB              	  2277: RETADR: EX		DE,HL			; Address of variable in DE
01:9ADD E1              	  2278: 		POP		HL				; Restore code string address
01:9ADE C9              	  2279: 		RET
                        	  2280: 
01:9ADF 32E710          	  2281: RETNUL: LD		(FPEXP),A		; Set result to zero
01:9AE2 21128F          	  2282: 		LD		HL,ZERBYT		; Also set a null string
01:9AE5 22E410          	  2283: 		LD		(FPREG),HL		; Save for EVAL
01:9AE8 E1              	  2284: 		POP		HL				; Restore code string address
01:9AE9 C9              	  2285: 		RET
                        	  2286: 
01:9AEA E5              	  2287: SBSCPT: PUSH	HL				; Save code string address
01:9AEB 2AAC10          	  2288: 		LD		HL,(LCRFLG)		; Locate/Create and Type
01:9AEE E3              	  2289: 		EX		(SP),HL			; Save and get code string
01:9AEF 57              	  2290: 		LD		D,A				; Zero number of dimensions
01:9AF0 D5              	  2291: SCPTLP: PUSH	DE				; Save number of dimensions
01:9AF1 C5              	  2292: 		PUSH	BC				; Save array name
01:9AF2 CD7794          	  2293: 		CALL	FPSINT			; Get subscript (0-32767)
01:9AF5 C1              	  2294: 		POP		BC				; Restore array name
01:9AF6 F1              	  2295: 		POP		AF				; Get number of dimensions
01:9AF7 EB              	  2296: 		EX		DE,HL
01:9AF8 E3              	  2297: 		EX		(SP),HL			; Save subscript value
01:9AF9 E5              	  2298: 		PUSH	HL				; Save LCRFLG and TYPE
01:9AFA EB              	  2299: 		EX		DE,HL
01:9AFB 3C              	  2300: 		INC		A				; Count dimensions
01:9AFC 57              	  2301: 		LD		D,A				; Save in D
01:9AFD 7E              	  2302: 		LD		A,(HL)			; Get next byte in code string
01:9AFE FE2C            	  2303: 		CP		','				; Comma (more to come)?
01:9B00 CAF09A          	  2304: 		JP		Z,SCPTLP		; Yes - More subscripts
01:9B03 CD4492          	  2305: 		CALL	CHKSYN			; Make sure ")" follows
01:9B06 29              	  2306: 		db	   ")"
01:9B07 22D010          	  2307: 		LD		(NXTOPR),HL		; Save code string address
01:9B0A E1              	  2308: 		POP		HL				; Get LCRFLG and TYPE
01:9B0B 22AC10          	  2309: 		LD		(LCRFLG),HL		; Restore Locate/create & type
01:9B0E 1E00            	  2310: 		LD		E,0				; Flag not CSAVE* or CLOAD*
01:9B10 D5              	  2311: 		PUSH	DE				; Save number of dimensions (D)
01:9B11 11              	  2312: 		db	   11H			   ; Skip "PUSH HL" and "PUSH AF'
                        	  2313: 
01:9B12 E5              	  2314: ARLDSV: PUSH	HL				; Save code string address
01:9B13 F5              	  2315: 		PUSH	AF				; A = 00 , Flags set = Z,N
01:9B14 2AD810          	  2316: 		LD		HL,(VAREND)		; Start of arrays
01:9B17 3E              	  2317: 		db	   3EH			   ; Skip "ADD HL,DE"
01:9B18 19              	  2318: FNDARY: ADD		HL,DE			; Move to next array start
01:9B19 EB              	  2319: 		EX		DE,HL
01:9B1A 2ADA10          	  2320: 		LD		HL,(ARREND)		; End of arrays
01:9B1D EB              	  2321: 		EX		DE,HL			; Current array pointer
01:9B1E CD3E92          	  2322: 		CALL	CPDEHL			; End of arrays found?
01:9B21 CA4A9B          	  2323: 		JP		Z,CREARY		; Yes - Create array
01:9B24 7E              	  2324: 		LD		A,(HL)			; Get second byte of name
01:9B25 B9              	  2325: 		CP		C				; Compare with name given
01:9B26 23              	  2326: 		INC		HL				; Move on
01:9B27 C22C9B          	  2327: 		JP		NZ,NXTARY		; Different - Find next array
01:9B2A 7E              	  2328: 		LD		A,(HL)			; Get first byte of name
01:9B2B B8              	  2329: 		CP		B				; Compare with name given
01:9B2C 23              	  2330: NXTARY: INC		HL				; Move on
01:9B2D 5E              	  2331: 		LD		E,(HL)			; Get LSB of next array address
01:9B2E 23              	  2332: 		INC		HL
01:9B2F 56              	  2333: 		LD		D,(HL)			; Get MSB of next array address
01:9B30 23              	  2334: 		INC		HL
01:9B31 C2189B          	  2335: 		JP		NZ,FNDARY		; Not found - Keep looking
01:9B34 3AAC10          	  2336: 		LD		A,(LCRFLG)		; Found Locate or Create it?
01:9B37 B7              	  2337: 		OR		A
01:9B38 C27F8F          	  2338: 		JP		NZ,DDERR		; Create - ?DD Error
01:9B3B F1              	  2339: 		POP		AF				; Locate - Get number of dim'ns
01:9B3C 44              	  2340: 		LD		B,H				; BC Points to array dim'ns
01:9B3D 4D              	  2341: 		LD		C,L
01:9B3E CA5AA1          	  2342: 		JP		Z,POPHRT		; Jump if array load/save
01:9B41 96              	  2343: 		SUB		(HL)			; Same number of dimensions?
01:9B42 CAA89B          	  2344: 		JP		Z,FINDEL		; Yes - Find element
01:9B45 1E10            	  2345: BSERR:	LD		E,BS			; ?BS Error
01:9B47 C38A8F          	  2346: 		JP		ERROR			; Output error
                        	  2347: 
01:9B4A 110400          	  2348: CREARY: LD		DE,4			; 4 Bytes per entry
01:9B4D F1              	  2349: 		POP		AF				; Array to save or 0 dim'ns?
01:9B4E CA9894          	  2350: 		JP		Z,FCERR			; Yes - ?FC Error
01:9B51 71              	  2351: 		LD		(HL),C			; Save second byte of name
01:9B52 23              	  2352: 		INC		HL
01:9B53 70              	  2353: 		LD		(HL),B			; Save first byte of name
01:9B54 23              	  2354: 		INC		HL
01:9B55 4F              	  2355: 		LD		C,A				; Number of dimensions to C
01:9B56 CD538F          	  2356: 		CALL	CHKSTK			; Check if enough memory
01:9B59 23              	  2357: 		INC		HL				; Point to number of dimensions
01:9B5A 23              	  2358: 		INC		HL
01:9B5B 22C510          	  2359: 		LD		(CUROPR),HL		; Save address of pointer
01:9B5E 71              	  2360: 		LD		(HL),C			; Set number of dimensions
01:9B5F 23              	  2361: 		INC		HL
01:9B60 3AAC10          	  2362: 		LD		A,(LCRFLG)		; Locate of Create?
01:9B63 17              	  2363: 		RLA						; Carry set = Create
01:9B64 79              	  2364: 		LD		A,C				; Get number of dimensions
01:9B65 010B00          	  2365: CRARLP: LD		BC,10+1			; Default dimension size 10
01:9B68 D26D9B          	  2366: 		JP		NC,DEFSIZ		; Locate - Set default size
01:9B6B C1              	  2367: 		POP		BC				; Get specified dimension size
01:9B6C 03              	  2368: 		INC		BC				; Include zero element
01:9B6D 71              	  2369: DEFSIZ: LD		(HL),C			; Save LSB of dimension size
01:9B6E 23              	  2370: 		INC		HL
01:9B6F 70              	  2371: 		LD		(HL),B			; Save MSB of dimension size
01:9B70 23              	  2372: 		INC		HL
01:9B71 F5              	  2373: 		PUSH	AF				; Save num' of dim'ns an status
01:9B72 E5              	  2374: 		PUSH	HL				; Save address of dim'n size
01:9B73 CD05A3          	  2375: 		CALL	MLDEBC			; Multiply DE by BC to find
01:9B76 EB              	  2376: 		EX		DE,HL			; amount of mem needed (to DE)
01:9B77 E1              	  2377: 		POP		HL				; Restore address of dimension
01:9B78 F1              	  2378: 		POP		AF				; Restore number of dimensions
01:9B79 3D              	  2379: 		DEC		A				; Count them
01:9B7A C2659B          	  2380: 		JP		NZ,CRARLP		; Do next dimension if more
01:9B7D F5              	  2381: 		PUSH	AF				; Save locate/create flag
01:9B7E 42              	  2382: 		LD		B,D				; MSB of memory needed
01:9B7F 4B              	  2383: 		LD		C,E				; LSB of memory needed
01:9B80 EB              	  2384: 		EX		DE,HL
01:9B81 19              	  2385: 		ADD		HL,DE			; Add bytes to array start
01:9B82 DA6B8F          	  2386: 		JP		C,OMERR			; Too big - Error
01:9B85 CD5C8F          	  2387: 		CALL	ENFMEM			; See if enough memory
01:9B88 22DA10          	  2388: 		LD		(ARREND),HL		; Save new end of array
                        	  2389: 
01:9B8B 2B              	  2390: ZERARY: DEC		HL				; Back through array data
01:9B8C 3600            	  2391: 		LD		(HL),0			; Set array element to zero
01:9B8E CD3E92          	  2392: 		CALL	CPDEHL			; All elements zeroed?
01:9B91 C28B9B          	  2393: 		JP		NZ,ZERARY		; No - Keep on going
01:9B94 03              	  2394: 		INC		BC				; Number of bytes + 1
01:9B95 57              	  2395: 		LD		D,A				; A=0
01:9B96 2AC510          	  2396: 		LD		HL,(CUROPR)		; Get address of array
01:9B99 5E              	  2397: 		LD		E,(HL)			; Number of dimensions
01:9B9A EB              	  2398: 		EX		DE,HL			; To HL
01:9B9B 29              	  2399: 		ADD		HL,HL			; Two bytes per dimension size
01:9B9C 09              	  2400: 		ADD		HL,BC			; Add number of bytes
01:9B9D EB              	  2401: 		EX		DE,HL			; Bytes needed to DE
01:9B9E 2B              	  2402: 		DEC		HL
01:9B9F 2B              	  2403: 		DEC		HL
01:9BA0 73              	  2404: 		LD		(HL),E			; Save LSB of bytes needed
01:9BA1 23              	  2405: 		INC		HL
01:9BA2 72              	  2406: 		LD		(HL),D			; Save MSB of bytes needed
01:9BA3 23              	  2407: 		INC		HL
01:9BA4 F1              	  2408: 		POP		AF				; Locate / Create?
01:9BA5 DACC9B          	  2409: 		JP		C,ENDDIM		; A is 0 , End if create
01:9BA8 47              	  2410: FINDEL: LD		B,A				; Find array element
01:9BA9 4F              	  2411: 		LD		C,A
01:9BAA 7E              	  2412: 		LD		A,(HL)			; Number of dimensions
01:9BAB 23              	  2413: 		INC		HL
01:9BAC 16              	  2414: 		db	   16H			   ; Skip "POP HL"
01:9BAD E1              	  2415: FNDELP: POP		HL				; Address of next dim' size
01:9BAE 5E              	  2416: 		LD		E,(HL)			; Get LSB of dim'n size
01:9BAF 23              	  2417: 		INC		HL
01:9BB0 56              	  2418: 		LD		D,(HL)			; Get MSB of dim'n size
01:9BB1 23              	  2419: 		INC		HL
01:9BB2 E3              	  2420: 		EX		(SP),HL			; Save address - Get index
01:9BB3 F5              	  2421: 		PUSH	AF				; Save number of dim'ns
01:9BB4 CD3E92          	  2422: 		CALL	CPDEHL			; Dimension too large?
01:9BB7 D2459B          	  2423: 		JP		NC,BSERR		; Yes - ?BS Error
01:9BBA E5              	  2424: 		PUSH	HL				; Save index
01:9BBB CD05A3          	  2425: 		CALL	MLDEBC			; Multiply previous by size
01:9BBE D1              	  2426: 		POP		DE				; Index supplied to DE
01:9BBF 19              	  2427: 		ADD		HL,DE			; Add index to pointer
01:9BC0 F1              	  2428: 		POP		AF				; Number of dimensions
01:9BC1 3D              	  2429: 		DEC		A				; Count them
01:9BC2 44              	  2430: 		LD		B,H				; MSB of pointer
01:9BC3 4D              	  2431: 		LD		C,L				; LSB of pointer
01:9BC4 C2AD9B          	  2432: 		JP		NZ,FNDELP		; More - Keep going
01:9BC7 29              	  2433: 		ADD		HL,HL			; 4 Bytes per element
01:9BC8 29              	  2434: 		ADD		HL,HL
01:9BC9 C1              	  2435: 		POP		BC				; Start of array
01:9BCA 09              	  2436: 		ADD		HL,BC			; Point to element
01:9BCB EB              	  2437: 		EX		DE,HL			; Address of element to DE
01:9BCC 2AD010          	  2438: ENDDIM: LD		HL,(NXTOPR)		; Got code string address
01:9BCF C9              	  2439: 		RET
                        	  2440: 
01:9BD0 2ADA10          	  2441: FRE:	LD		HL,(ARREND)		; Start of free memory
01:9BD3 EB              	  2442: 		EX		DE,HL			; To DE
01:9BD4 210000          	  2443: 		LD		HL,0			; End of free memory
01:9BD7 39              	  2444: 		ADD		HL,SP			; Current stack value
01:9BD8 3AAD10          	  2445: 		LD		A,(TYPE)		; Dummy argument type
01:9BDB B7              	  2446: 		OR		A
01:9BDC CAEC9B          	  2447: 		JP		Z,FRENUM		; Numeric - Free variable space
01:9BDF CD539E          	  2448: 		CALL	GSTRCU			; Current string to pool
01:9BE2 CD539D          	  2449: 		CALL	GARBGE			; Garbage collection
01:9BE5 2A5A10          	  2450: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9BE8 EB              	  2451: 		EX		DE,HL			; To DE
01:9BE9 2AC310          	  2452: 		LD		HL,(STRBOT)		; Bottom of string space
01:9BEC 7D              	  2453: FRENUM: LD		A,L				; Get LSB of end
01:9BED 93              	  2454: 		SUB		E				; Subtract LSB of beginning
01:9BEE 4F              	  2455: 		LD		C,A				; Save difference if C
01:9BEF 7C              	  2456: 		LD		A,H				; Get MSB of end
01:9BF0 9A              	  2457: 		SBC		A,D				; Subtract MSB of beginning
01:9BF1 41              	  2458: ACPASS: LD		B,C				; Return integer AC
01:9BF2 50              	  2459: ABPASS: LD		D,B				; Return integer AB
01:9BF3 1E00            	  2460: 		LD		E,0
01:9BF5 21AD10          	  2461: 		LD		HL,TYPE			; Point to type
01:9BF8 73              	  2462: 		LD		(HL),E			; Set type to numeric
01:9BF9 0690            	  2463: 		LD		B,80H+16		; 16 bit integer
01:9BFB C330A2          	  2464: 		JP		RETINT			; Return the integr
                        	  2465: 
01:9BFE 3AAB10          	  2466: POS:	LD		A,(CURPOS)		; Get cursor position
01:9C01 47              	  2467: PASSA:	LD		B,A				; Put A into AB
01:9C02 AF              	  2468: 		XOR		A				; Zero A
01:9C03 C3F29B          	  2469: 		JP		ABPASS			; Return integer AB
                        	  2470: 
01:9C06 CD899C          	  2471: DEF:	CALL	CHEKFN			; Get "FN" and name
01:9C09 CD7B9C          	  2472: 		CALL	IDTEST			; Test for illegal direct
01:9C0C 016895          	  2473: 		LD		BC,DATAA			; To get next statement
01:9C0F C5              	  2474: 		PUSH	BC				; Save address for RETurn
01:9C10 D5              	  2475: 		PUSH	DE				; Save address of function ptr
01:9C11 CD4492          	  2476: 		CALL	CHKSYN			; Make sure "(" follows
01:9C14 28              	  2477: 		db	   "("
01:9C15 CD2D9A          	  2478: 		CALL	GETVAR			; Get argument variable name
01:9C18 E5              	  2479: 		PUSH	HL				; Save code string address
01:9C19 EB              	  2480: 		EX		DE,HL			; Argument address to HL
01:9C1A 2B              	  2481: 		DEC		HL
01:9C1B 56              	  2482: 		LD		D,(HL)			; Get first byte of arg name
01:9C1C 2B              	  2483: 		DEC		HL
01:9C1D 5E              	  2484: 		LD		E,(HL)			; Get second byte of arg name
01:9C1E E1              	  2485: 		POP		HL				; Restore code string address
01:9C1F CD3A98          	  2486: 		CALL	TSTNUM			; Make sure numeric argument
01:9C22 CD4492          	  2487: 		CALL	CHKSYN			; Make sure ")" follows
01:9C25 29              	  2488: 		db	   ")"
01:9C26 CD4492          	  2489: 		CALL	CHKSYN			; Make sure "=" follows
01:9C29 B4              	  2490: 		db	   ZEQUAL		   ; "=" token
01:9C2A 44              	  2491: 		LD		B,H				; Code string address to BC
01:9C2B 4D              	  2492: 		LD		C,L
01:9C2C E3              	  2493: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C2D 71              	  2494: 		LD		(HL),C			; Save LSB of FN code string
01:9C2E 23              	  2495: 		INC		HL
01:9C2F 70              	  2496: 		LD		(HL),B			; Save MSB of FN code string
01:9C30 C3C89C          	  2497: 		JP		SVSTAD			; Save address and do function
                        	  2498: 
01:9C33 CD899C          	  2499: DOFN:	CALL	CHEKFN			; Make sure FN follows
01:9C36 D5              	  2500: 		PUSH	DE				; Save function pointer address
01:9C37 CD0E99          	  2501: 		CALL	EVLPAR			; Evaluate expression in "()"
01:9C3A CD3A98          	  2502: 		CALL	TSTNUM			; Make sure numeric result
01:9C3D E3              	  2503: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C3E 5E              	  2504: 		LD		E,(HL)			; Get LSB of FN code string
01:9C3F 23              	  2505: 		INC		HL
01:9C40 56              	  2506: 		LD		D,(HL)			; Get MSB of FN code string
01:9C41 23              	  2507: 		INC		HL
01:9C42 7A              	  2508: 		LD		A,D				; And function DEFined?
01:9C43 B3              	  2509: 		OR		E
01:9C44 CA828F          	  2510: 		JP		Z,UFERR			; No - ?UF Error
01:9C47 7E              	  2511: 		LD		A,(HL)			; Get LSB of argument address
01:9C48 23              	  2512: 		INC		HL
01:9C49 66              	  2513: 		LD		H,(HL)			; Get MSB of argument address
01:9C4A 6F              	  2514: 		LD		L,A				; HL = Arg variable address
01:9C4B E5              	  2515: 		PUSH	HL				; Save it
01:9C4C 2ADE10          	  2516: 		LD		HL,(FNRGNM)		; Get old argument name
01:9C4F E3              	  2517: 		EX		(SP),HL ;		; Save old , Get new
01:9C50 22DE10          	  2518: 		LD		(FNRGNM),HL		; Set new argument name
01:9C53 2AE210          	  2519: 		LD		HL,(FNARG+2)	; Get LSB,NLSB of old arg value
01:9C56 E5              	  2520: 		PUSH	HL				; Save it
01:9C57 2AE010          	  2521: 		LD		HL,(FNARG)		; Get MSB,EXP of old arg value
01:9C5A E5              	  2522: 		PUSH	HL				; Save it
01:9C5B 21E010          	  2523: 		LD		HL,FNARG		; HL = Value of argument
01:9C5E D5              	  2524: 		PUSH	DE				; Save FN code string address
01:9C5F CD71A2          	  2525: 		CALL	FPTHL			; Move FPREG to argument
01:9C62 E1              	  2526: 		POP		HL				; Get FN code string address
01:9C63 CD3798          	  2527: 		CALL	GETNUM			; Get value from function
01:9C66 2B              	  2528: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9C67 CDCE93          	  2529: 		CALL	GETCHR			; Get next character
01:9C6A C2768F          	  2530: 		JP		NZ,SNERR		; Bad character in FN - Error
01:9C6D E1              	  2531: 		POP		HL				; Get MSB,EXP of old arg
01:9C6E 22E010          	  2532: 		LD		(FNARG),HL		; Restore it
01:9C71 E1              	  2533: 		POP		HL				; Get LSB,NLSB of old arg
01:9C72 22E210          	  2534: 		LD		(FNARG+2),HL	; Restore it
01:9C75 E1              	  2535: 		POP		HL				; Get name of old arg
01:9C76 22DE10          	  2536: 		LD		(FNRGNM),HL		; Restore it
01:9C79 E1              	  2537: 		POP		HL				; Restore code string address
01:9C7A C9              	  2538: 		RET
                        	  2539: 
01:9C7B E5              	  2540: IDTEST: PUSH	HL				; Save code string address
01:9C7C 2A5C10          	  2541: 		LD		HL,(LINEAT)		; Get current line number
01:9C7F 23              	  2542: 		INC		HL				; -1 means direct statement
01:9C80 7C              	  2543: 		LD		A,H
01:9C81 B5              	  2544: 		OR		L
01:9C82 E1              	  2545: 		POP		HL				; Restore code string address
01:9C83 C0              	  2546: 		RET		NZ				; Return if in program
01:9C84 1E16            	  2547: 		LD		E,ID			; ?ID Error
01:9C86 C38A8F          	  2548: 		JP		ERROR
                        	  2549: 
01:9C89 CD4492          	  2550: CHEKFN: CALL	CHKSYN			; Make sure FN follows
01:9C8C A7              	  2551: 		db	   ZFN			   ; "FN" token
01:9C8D 3E80            	  2552: 		LD		A,80H
01:9C8F 32CB10          	  2553: 		LD		(FORFLG),A		; Flag FN name to find
01:9C92 B6              	  2554: 		OR		(HL)			; FN name has bit 7 set
01:9C93 47              	  2555: 		LD		B,A				; in first byte of name
01:9C94 CD329A          	  2556: 		CALL	GTFNAM			; Get FN name
01:9C97 C33A98          	  2557: 		JP		TSTNUM			; Make sure numeric function
                        	  2558: 
01:9C9A CD3A98          	  2559: STRR:	CALL	TSTNUM			; Make sure it's a number
01:9C9D CDBEA3          	  2560: 		CALL	NUMASC			; Turn number into text
01:9CA0 CDCE9C          	  2561: STR1:	CALL	CRTST			; Create string entry for it
01:9CA3 CD539E          	  2562: 		CALL	GSTRCU			; Current string to pool
01:9CA6 01AE9E          	  2563: 		LD		BC,TOPOOL		; Save in string pool
01:9CA9 C5              	  2564: 		PUSH	BC				; Save address on stack
                        	  2565: 
01:9CAA 7E              	  2566: SAVSTR: LD		A,(HL)			; Get string length
01:9CAB 23              	  2567: 		INC		HL
01:9CAC 23              	  2568: 		INC		HL
01:9CAD E5              	  2569: 		PUSH	HL				; Save pointer to string
01:9CAE CD299D          	  2570: 		CALL	TESTR			; See if enough string space
01:9CB1 E1              	  2571: 		POP		HL				; Restore pointer to string
01:9CB2 4E              	  2572: 		LD		C,(HL)			; Get LSB of address
01:9CB3 23              	  2573: 		INC		HL
01:9CB4 46              	  2574: 		LD		B,(HL)			; Get MSB of address
01:9CB5 CDC29C          	  2575: 		CALL	CRTMST			; Create string entry
01:9CB8 E5              	  2576: 		PUSH	HL				; Save pointer to MSB of addr
01:9CB9 6F              	  2577: 		LD		L,A				; Length of string
01:9CBA CD469E          	  2578: 		CALL	TOSTRA			; Move to string area
01:9CBD D1              	  2579: 		POP		DE				; Restore pointer to MSB
01:9CBE C9              	  2580: 		RET
                        	  2581: 
01:9CBF CD299D          	  2582: MKTMST: CALL	TESTR			; See if enough string space
01:9CC2 21BF10          	  2583: CRTMST: LD		HL,TMPSTR		; Temporary string
01:9CC5 E5              	  2584: 		PUSH	HL				; Save it
01:9CC6 77              	  2585: 		LD		(HL),A			; Save length of string
01:9CC7 23              	  2586: 		INC		HL
01:9CC8 23              	  2587: SVSTAD: INC		HL
01:9CC9 73              	  2588: 		LD		(HL),E			; Save LSB of address
01:9CCA 23              	  2589: 		INC		HL
01:9CCB 72              	  2590: 		LD		(HL),D			; Save MSB of address
01:9CCC E1              	  2591: 		POP		HL				; Restore pointer
01:9CCD C9              	  2592: 		RET
                        	  2593: 
01:9CCE 2B              	  2594: CRTST:	DEC		HL				; DEC - INCed after
01:9CCF 0622            	  2595: QTSTR:	LD		B,'"'			; Terminating quote "
01:9CD1 50              	  2596: 		LD		D,B				; Quote to D
01:9CD2 E5              	  2597: DTSTR:	PUSH	HL				; Save start
01:9CD3 0EFF            	  2598: 		LD		C,-1			; Set counter to -1
01:9CD5 23              	  2599: QTSTLP: INC		HL				; Move on
01:9CD6 7E              	  2600: 		LD		A,(HL)			; Get byte
01:9CD7 0C              	  2601: 		INC		C				; Count bytes
01:9CD8 B7              	  2602: 		OR		A				; End of line?
01:9CD9 CAE49C          	  2603: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CDC BA              	  2604: 		CP		D				; Terminator D found?
01:9CDD CAE49C          	  2605: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE0 B8              	  2606: 		CP		B				; Terminator B found?
01:9CE1 C2D59C          	  2607: 		JP		NZ,QTSTLP		; No - Keep looking
01:9CE4 FE22            	  2608: CRTSTE: CP		'"'				; End with '"'?
01:9CE6 CCCE93          	  2609: 		CALL	Z,GETCHR		; Yes - Get next character
01:9CE9 E3              	  2610: 		EX		(SP),HL			; Starting quote
01:9CEA 23              	  2611: 		INC		HL				; First byte of string
01:9CEB EB              	  2612: 		EX		DE,HL			; To DE
01:9CEC 79              	  2613: 		LD		A,C				; Get length
01:9CED CDC29C          	  2614: 		CALL	CRTMST			; Create string entry
01:9CF0 11BF10          	  2615: TSTOPL: LD		DE,TMPSTR		; Temporary string
01:9CF3 2AB110          	  2616: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9CF6 22E410          	  2617: 		LD		(FPREG),HL		; Save address of string ptr
01:9CF9 3E01            	  2618: 		LD		A,1
01:9CFB 32AD10          	  2619: 		LD		(TYPE),A		; Set type to string
01:9CFE CD74A2          	  2620: 		CALL	DETHL4			; Move string to pool
01:9D01 CD3E92          	  2621: 		CALL	CPDEHL			; Out of string pool?
01:9D04 22B110          	  2622: 		LD		(TMSTPT),HL		; Save new pointer
01:9D07 E1              	  2623: 		POP		HL				; Restore code string address
01:9D08 7E              	  2624: 		LD		A,(HL)			; Get next code byte
01:9D09 C0              	  2625: 		RET		NZ				; Return if pool OK
01:9D0A 1E1E            	  2626: 		LD		E,ST			; ?ST Error
01:9D0C C38A8F          	  2627: 		JP		ERROR			; String pool overflow
                        	  2628: 
01:9D0F 23              	  2629: PRNUMS: INC		HL				; Skip leading space
01:9D10 CDCE9C          	  2630: PRS:	CALL	CRTST			; Create string entry for it
01:9D13 CD539E          	  2631: PRS1:	CALL	GSTRCU			; Current string to pool
01:9D16 CD68A2          	  2632: 		CALL	LOADFP			; Move string block to BCDE
01:9D19 1C              	  2633: 		INC		E				; Length + 1
01:9D1A 1D              	  2634: PRSLP:	DEC		E				; Count characters
01:9D1B C8              	  2635: 		RET		Z				; End of string
01:9D1C 0A              	  2636: 		LD		A,(BC)			; Get byte to output
01:9D1D CD4F92          	  2637: 		CALL	OUTC			; Output character in A
01:9D20 FE0D            	  2638: 		CP		CR				; Return?
01:9D22 CC7C96          	  2639: 		CALL	Z,DONULL		; Yes - Do nulls
01:9D25 03              	  2640: 		INC		BC				; Next byte in string
01:9D26 C31A9D          	  2641: 		JP		PRSLP			; More characters to output
                        	  2642: 
01:9D29 B7              	  2643: TESTR:	OR		A				; Test if enough room
01:9D2A 0E              	  2644: 		db	   0EH			   ; No garbage collection done
01:9D2B F1              	  2645: GRBDON: POP		AF				; Garbage collection done
01:9D2C F5              	  2646: 		PUSH	AF				; Save status
01:9D2D 2A5A10          	  2647: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9D30 EB              	  2648: 		EX		DE,HL			; To DE
01:9D31 2AC310          	  2649: 		LD		HL,(STRBOT)		; Bottom of string area
01:9D34 2F              	  2650: 		CPL						; Negate length (Top down)
01:9D35 4F              	  2651: 		LD		C,A				; -Length to BC
01:9D36 06FF            	  2652: 		LD		B,-1			; BC = -ve length of string
01:9D38 09              	  2653: 		ADD		HL,BC			; Add to bottom of space in use
01:9D39 23              	  2654: 		INC		HL				; Plus one for 2's complement
01:9D3A CD3E92          	  2655: 		CALL	CPDEHL			; Below string RAM area?
01:9D3D DA479D          	  2656: 		JP		C,TESTOS		; Tidy up if not done else err
01:9D40 22C310          	  2657: 		LD		(STRBOT),HL		; Save new bottom of area
01:9D43 23              	  2658: 		INC		HL				; Point to first byte of string
01:9D44 EB              	  2659: 		EX		DE,HL			; Address to DE
01:9D45 F1              	  2660: POPAF:	POP		AF				; Throw away status push
01:9D46 C9              	  2661: 		RET
                        	  2662: 
01:9D47 F1              	  2663: TESTOS: POP		AF				; Garbage collect been done?
01:9D48 1E1A            	  2664: 		LD		E,OS			; ?OS Error
01:9D4A CA8A8F          	  2665: 		JP		Z,ERROR			; Yes - Not enough string apace
01:9D4D BF              	  2666: 		CP		A				; Flag garbage collect done
01:9D4E F5              	  2667: 		PUSH	AF				; Save status
01:9D4F 012B9D          	  2668: 		LD		BC,GRBDON		; Garbage collection done
01:9D52 C5              	  2669: 		PUSH	BC				; Save for RETurn
01:9D53 2AAF10          	  2670: GARBGE: LD		HL,(LSTRAM)		; Get end of RAM pointer
01:9D56 22C310          	  2671: GARBLP: LD		(STRBOT),HL		; Reset string pointer
01:9D59 210000          	  2672: 		LD		HL,0
01:9D5C E5              	  2673: 		PUSH	HL				; Flag no string found
01:9D5D 2A5A10          	  2674: 		LD		HL,(STRSPC)		; Get bottom of string space
01:9D60 E5              	  2675: 		PUSH	HL				; Save bottom of string space
01:9D61 21B310          	  2676: 		LD		HL,TMSTPL		; Temporary string pool
01:9D64 EB              	  2677: GRBLP:	EX		DE,HL
01:9D65 2AB110          	  2678: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9D68 EB              	  2679: 		EX		DE,HL
01:9D69 CD3E92          	  2680: 		CALL	CPDEHL			; Temporary string pool done?
01:9D6C 01649D          	  2681: 		LD		BC,GRBLP		; Loop until string pool done
01:9D6F C2B89D          	  2682: 		JP		NZ,STPOOL		; No - See if in string area
01:9D72 2AD610          	  2683: 		LD		HL,(PROGND)		; Start of simple variables
01:9D75 EB              	  2684: SMPVAR: EX		DE,HL
01:9D76 2AD810          	  2685: 		LD		HL,(VAREND)		; End of simple variables
01:9D79 EB              	  2686: 		EX		DE,HL
01:9D7A CD3E92          	  2687: 		CALL	CPDEHL			; All simple strings done?
01:9D7D CA8B9D          	  2688: 		JP		Z,ARRLP			; Yes - Do string arrays
01:9D80 7E              	  2689: 		LD		A,(HL)			; Get type of variable
01:9D81 23              	  2690: 		INC		HL
01:9D82 23              	  2691: 		INC		HL
01:9D83 B7              	  2692: 		OR		A				; "S" flag set if string
01:9D84 CDBB9D          	  2693: 		CALL	STRADD			; See if string in string area
01:9D87 C3759D          	  2694: 		JP		SMPVAR			; Loop until simple ones done
                        	  2695: 
01:9D8A C1              	  2696: GNXARY: POP		BC				; Scrap address of this array
01:9D8B EB              	  2697: ARRLP:	EX		DE,HL
01:9D8C 2ADA10          	  2698: 		LD		HL,(ARREND)		; End of string arrays
01:9D8F EB              	  2699: 		EX		DE,HL
01:9D90 CD3E92          	  2700: 		CALL	CPDEHL			; All string arrays done?
01:9D93 CAE19D          	  2701: 		JP		Z,SCNEND		; Yes - Move string if found
01:9D96 CD68A2          	  2702: 		CALL	LOADFP			; Get array name to BCDE
01:9D99 7B              	  2703: 		LD		A,E				; Get type of array		
01:9D9A E5              	  2704: 		PUSH	HL				; Save address of num of dim'ns
01:9D9B 09              	  2705: 		ADD		HL,BC			; Start of next array
01:9D9C B7              	  2706: 		OR		A				; Test type of array
01:9D9D F28A9D          	  2707: 		JP		P,GNXARY		; Numeric array - Ignore it
01:9DA0 22C510          	  2708: 		LD		(CUROPR),HL		; Save address of next array
01:9DA3 E1              	  2709: 		POP		HL				; Get address of num of dim'ns
01:9DA4 4E              	  2710: 		LD		C,(HL)			; BC = Number of dimensions
01:9DA5 0600            	  2711: 		LD		B,0
01:9DA7 09              	  2712: 		ADD		HL,BC			; Two bytes per dimension size
01:9DA8 09              	  2713: 		ADD		HL,BC
01:9DA9 23              	  2714: 		INC		HL				; Plus one for number of dim'ns
01:9DAA EB              	  2715: GRBARY: EX		DE,HL
01:9DAB 2AC510          	  2716: 		LD		HL,(CUROPR)		; Get address of next array
01:9DAE EB              	  2717: 		EX		DE,HL
01:9DAF CD3E92          	  2718: 		CALL	CPDEHL			; Is this array finished?
01:9DB2 CA8B9D          	  2719: 		JP		Z,ARRLP			; Yes - Get next one
01:9DB5 01AA9D          	  2720: 		LD		BC,GRBARY		; Loop until array all done
01:9DB8 C5              	  2721: STPOOL: PUSH	BC				; Save return address
01:9DB9 F680            	  2722: 		OR		80H				; Flag string type
01:9DBB 7E              	  2723: STRADD: LD		A,(HL)			; Get string length
01:9DBC 23              	  2724: 		INC		HL
01:9DBD 23              	  2725: 		INC		HL
01:9DBE 5E              	  2726: 		LD		E,(HL)			; Get LSB of string address
01:9DBF 23              	  2727: 		INC		HL
01:9DC0 56              	  2728: 		LD		D,(HL)			; Get MSB of string address
01:9DC1 23              	  2729: 		INC		HL
01:9DC2 F0              	  2730: 		RET		P				; Not a string - Return
01:9DC3 B7              	  2731: 		OR		A				; Set flags on string length
01:9DC4 C8              	  2732: 		RET		Z				; Null string - Return
01:9DC5 44              	  2733: 		LD		B,H				; Save variable pointer
01:9DC6 4D              	  2734: 		LD		C,L
01:9DC7 2AC310          	  2735: 		LD		HL,(STRBOT)		; Bottom of new area
01:9DCA CD3E92          	  2736: 		CALL	CPDEHL			; String been done?
01:9DCD 60              	  2737: 		LD		H,B				; Restore variable pointer
01:9DCE 69              	  2738: 		LD		L,C
01:9DCF D8              	  2739: 		RET		C				; String done - Ignore
01:9DD0 E1              	  2740: 		POP		HL				; Return address
01:9DD1 E3              	  2741: 		EX		(SP),HL			; Lowest available string area
01:9DD2 CD3E92          	  2742: 		CALL	CPDEHL			; String within string area?
01:9DD5 E3              	  2743: 		EX		(SP),HL			; Lowest available string area
01:9DD6 E5              	  2744: 		PUSH	HL				; Re-save return address
01:9DD7 60              	  2745: 		LD		H,B				; Restore variable pointer
01:9DD8 69              	  2746: 		LD		L,C
01:9DD9 D0              	  2747: 		RET		NC				; Outside string area - Ignore
01:9DDA C1              	  2748: 		POP		BC				; Get return , Throw 2 away
01:9DDB F1              	  2749: 		POP		AF				; 
01:9DDC F1              	  2750: 		POP		AF				; 
01:9DDD E5              	  2751: 		PUSH	HL				; Save variable pointer
01:9DDE D5              	  2752: 		PUSH	DE				; Save address of current
01:9DDF C5              	  2753: 		PUSH	BC				; Put back return address
01:9DE0 C9              	  2754: 		RET						; Go to it
                        	  2755: 
01:9DE1 D1              	  2756: SCNEND: POP		DE				; Addresses of strings
01:9DE2 E1              	  2757: 		POP		HL				; 
01:9DE3 7D              	  2758: 		LD		A,L				; HL = 0 if no more to do
01:9DE4 B4              	  2759: 		OR		H
01:9DE5 C8              	  2760: 		RET		Z				; No more to do - Return
01:9DE6 2B              	  2761: 		DEC		HL
01:9DE7 46              	  2762: 		LD		B,(HL)			; MSB of address of string
01:9DE8 2B              	  2763: 		DEC		HL
01:9DE9 4E              	  2764: 		LD		C,(HL)			; LSB of address of string
01:9DEA E5              	  2765: 		PUSH	HL				; Save variable address
01:9DEB 2B              	  2766: 		DEC		HL
01:9DEC 2B              	  2767: 		DEC		HL
01:9DED 6E              	  2768: 		LD		L,(HL)			; HL = Length of string
01:9DEE 2600            	  2769: 		LD		H,0
01:9DF0 09              	  2770: 		ADD		HL,BC			; Address of end of string+1
01:9DF1 50              	  2771: 		LD		D,B				; String address to DE
01:9DF2 59              	  2772: 		LD		E,C
01:9DF3 2B              	  2773: 		DEC		HL				; Last byte in string
01:9DF4 44              	  2774: 		LD		B,H				; Address to BC
01:9DF5 4D              	  2775: 		LD		C,L
01:9DF6 2AC310          	  2776: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9DF9 CD458F          	  2777: 		CALL	MOVSTR			; Move string to new address
01:9DFC E1              	  2778: 		POP		HL				; Restore variable address
01:9DFD 71              	  2779: 		LD		(HL),C			; Save new LSB of address
01:9DFE 23              	  2780: 		INC		HL
01:9DFF 70              	  2781: 		LD		(HL),B			; Save new MSB of address
01:9E00 69              	  2782: 		LD		L,C				; Next string area+1 to HL
01:9E01 60              	  2783: 		LD		H,B
01:9E02 2B              	  2784: 		DEC		HL				; Next string area address
01:9E03 C3569D          	  2785: 		JP		GARBLP			; Look for more strings
                        	  2786: 
01:9E06 C5              	  2787: CONCAT: PUSH	BC				; Save prec' opr & code string
01:9E07 E5              	  2788: 		PUSH	HL				; 
01:9E08 2AE410          	  2789: 		LD		HL,(FPREG)		; Get first string
01:9E0B E3              	  2790: 		EX		(SP),HL			; Save first string
01:9E0C CDC098          	  2791: 		CALL	OPRND			; Get second string
01:9E0F E3              	  2792: 		EX		(SP),HL			; Restore first string
01:9E10 CD3B98          	  2793: 		CALL	TSTSTR			; Make sure it's a string
01:9E13 7E              	  2794: 		LD		A,(HL)			; Get length of second string
01:9E14 E5              	  2795: 		PUSH	HL				; Save first string
01:9E15 2AE410          	  2796: 		LD		HL,(FPREG)		; Get second string
01:9E18 E5              	  2797: 		PUSH	HL				; Save second string
01:9E19 86              	  2798: 		ADD		A,(HL)			; Add length of second string
01:9E1A 1E1C            	  2799: 		LD		E,LS			; ?LS Error
01:9E1C DA8A8F          	  2800: 		JP		C,ERROR			; String too long - Error
01:9E1F CDBF9C          	  2801: 		CALL	MKTMST			; Make temporary string
01:9E22 D1              	  2802: 		POP		DE				; Get second string to DE
01:9E23 CD579E          	  2803: 		CALL	GSTRDE			; Move to string pool if needed
01:9E26 E3              	  2804: 		EX		(SP),HL			; Get first string
01:9E27 CD569E          	  2805: 		CALL	GSTRHL			; Move to string pool if needed
01:9E2A E5              	  2806: 		PUSH	HL				; Save first string
01:9E2B 2AC110          	  2807: 		LD		HL,(TMPSTR+2)	; Temporary string address
01:9E2E EB              	  2808: 		EX		DE,HL			; To DE
01:9E2F CD3D9E          	  2809: 		CALL	SSTSA			; First string to string area
01:9E32 CD3D9E          	  2810: 		CALL	SSTSA			; Second string to string area
01:9E35 215598          	  2811: 		LD		HL,EVAL2		; Return to evaluation loop
01:9E38 E3              	  2812: 		EX		(SP),HL			; Save return,get code string
01:9E39 E5              	  2813: 		PUSH	HL				; Save code string address
01:9E3A C3F09C          	  2814: 		JP		TSTOPL			; To temporary string to pool
                        	  2815: 
01:9E3D E1              	  2816: SSTSA:	POP		HL				; Return address
01:9E3E E3              	  2817: 		EX		(SP),HL			; Get string block,save return
01:9E3F 7E              	  2818: 		LD		A,(HL)			; Get length of string
01:9E40 23              	  2819: 		INC		HL
01:9E41 23              	  2820: 		INC		HL
01:9E42 4E              	  2821: 		LD		C,(HL)			; Get LSB of string address
01:9E43 23              	  2822: 		INC		HL
01:9E44 46              	  2823: 		LD		B,(HL)			; Get MSB of string address
01:9E45 6F              	  2824: 		LD		L,A				; Length to L
01:9E46 2C              	  2825: TOSTRA: INC		L				; INC - DECed after
01:9E47 2D              	  2826: TSALP:	DEC		L				; Count bytes moved
01:9E48 C8              	  2827: 		RET		Z				; End of string - Return
01:9E49 0A              	  2828: 		LD		A,(BC)			; Get source
01:9E4A 12              	  2829: 		LD		(DE),A			; Save destination
01:9E4B 03              	  2830: 		INC		BC				; Next source
01:9E4C 13              	  2831: 		INC		DE				; Next destination
01:9E4D C3479E          	  2832: 		JP		TSALP			; Loop until string moved
                        	  2833: 
01:9E50 CD3B98          	  2834: GETSTR: CALL	TSTSTR			; Make sure it's a string
01:9E53 2AE410          	  2835: GSTRCU: LD		HL,(FPREG)		; Get current string
01:9E56 EB              	  2836: GSTRHL: EX		DE,HL			; Save DE
01:9E57 CD719E          	  2837: GSTRDE: CALL	BAKTMP			; Was it last tmp-str?
01:9E5A EB              	  2838: 		EX		DE,HL			; Restore DE
01:9E5B C0              	  2839: 		RET		NZ				; No - Return
01:9E5C D5              	  2840: 		PUSH	DE				; Save string
01:9E5D 50              	  2841: 		LD		D,B				; String block address to DE
01:9E5E 59              	  2842: 		LD		E,C
01:9E5F 1B              	  2843: 		DEC		DE				; Point to length
01:9E60 4E              	  2844: 		LD		C,(HL)			; Get string length
01:9E61 2AC310          	  2845: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9E64 CD3E92          	  2846: 		CALL	CPDEHL			; Last one in string area?
01:9E67 C26F9E          	  2847: 		JP		NZ,POPHL		; No - Return
01:9E6A 47              	  2848: 		LD		B,A				; Clear B (A=0)
01:9E6B 09              	  2849: 		ADD		HL,BC			; Remove string from str' area
01:9E6C 22C310          	  2850: 		LD		(STRBOT),HL		; Save new bottom of str' area
01:9E6F E1              	  2851: POPHL:	POP		HL				; Restore string
01:9E70 C9              	  2852: 		RET
                        	  2853: 
01:9E71 2AB110          	  2854: BAKTMP: LD		HL,(TMSTPT)		; Get temporary string pool top
01:9E74 2B              	  2855: 		DEC		HL				; Back
01:9E75 46              	  2856: 		LD		B,(HL)			; Get MSB of address
01:9E76 2B              	  2857: 		DEC		HL				; Back
01:9E77 4E              	  2858: 		LD		C,(HL)			; Get LSB of address
01:9E78 2B              	  2859: 		DEC		HL				; Back
01:9E79 2B              	  2860: 		DEC		HL				; Back
01:9E7A CD3E92          	  2861: 		CALL	CPDEHL			; String last in string pool?
01:9E7D C0              	  2862: 		RET		NZ				; Yes - Leave it
01:9E7E 22B110          	  2863: 		LD		(TMSTPT),HL		; Save new string pool top
01:9E81 C9              	  2864: 		RET
                        	  2865: 
01:9E82 01019C          	  2866: LEN:	LD		BC,PASSA		; To return integer A
01:9E85 C5              	  2867: 		PUSH	BC				; Save address
01:9E86 CD509E          	  2868: GETLEN: CALL	GETSTR			; Get string and its length
01:9E89 AF              	  2869: 		XOR		A
01:9E8A 57              	  2870: 		LD		D,A				; Clear D
01:9E8B 32AD10          	  2871: 		LD		(TYPE),A		; Set type to numeric
01:9E8E 7E              	  2872: 		LD		A,(HL)			; Get length of string
01:9E8F B7              	  2873: 		OR		A				; Set status flags
01:9E90 C9              	  2874: 		RET
                        	  2875: 
01:9E91 01019C          	  2876: ASCC:	LD		BC,PASSA		; To return integer A
01:9E94 C5              	  2877: 		PUSH	BC				; Save address
01:9E95 CD869E          	  2878: GTFLNM: CALL	GETLEN			; Get length of string
01:9E98 CA9894          	  2879: 		JP		Z,FCERR			; Null string - Error
01:9E9B 23              	  2880: 		INC		HL
01:9E9C 23              	  2881: 		INC		HL
01:9E9D 5E              	  2882: 		LD		E,(HL)			; Get LSB of address
01:9E9E 23              	  2883: 		INC		HL
01:9E9F 56              	  2884: 		LD		D,(HL)			; Get MSB of address
01:9EA0 1A              	  2885: 		LD		A,(DE)			; Get first byte of string
01:9EA1 C9              	  2886: 		RET
                        	  2887: 
01:9EA2 3E01            	  2888: CHR:	LD		A,1				; One character string
01:9EA4 CDBF9C          	  2889: 		CALL	MKTMST			; Make a temporary string
01:9EA7 CD9B9F          	  2890: 		CALL	MAKINT			; Make it integer A
01:9EAA 2AC110          	  2891: 		LD		HL,(TMPSTR+2)	; Get address of string
01:9EAD 73              	  2892: 		LD		(HL),E			; Save character
01:9EAE C1              	  2893: TOPOOL: POP		BC				; Clean up stack
01:9EAF C3F09C          	  2894: 		JP		TSTOPL			; Temporary string to pool
                        	  2895: 
01:9EB2 CD4B9F          	  2896: LEFT:	CALL	LFRGNM			; Get number and ending ")"
01:9EB5 AF              	  2897: 		XOR		A				; Start at first byte in string
01:9EB6 E3              	  2898: RIGHT1: EX		(SP),HL			; Save code string,Get string
01:9EB7 4F              	  2899: 		LD		C,A				; Starting position in string
01:9EB8 E5              	  2900: MID1:	PUSH	HL				; Save string block address
01:9EB9 7E              	  2901: 		LD		A,(HL)			; Get length of string
01:9EBA B8              	  2902: 		CP		B				; Compare with number given
01:9EBB DAC09E          	  2903: 		JP		C,ALLFOL		; All following bytes required
01:9EBE 78              	  2904: 		LD		A,B				; Get new length
01:9EBF 11              	  2905: 		db	   11H			   ; Skip "LD C,0"
01:9EC0 0E00            	  2906: ALLFOL: LD		C,0				; First byte of string
01:9EC2 C5              	  2907: 		PUSH	BC				; Save position in string
01:9EC3 CD299D          	  2908: 		CALL	TESTR			; See if enough string space
01:9EC6 C1              	  2909: 		POP		BC				; Get position in string
01:9EC7 E1              	  2910: 		POP		HL				; Restore string block address
01:9EC8 E5              	  2911: 		PUSH	HL				; And re-save it
01:9EC9 23              	  2912: 		INC		HL
01:9ECA 23              	  2913: 		INC		HL
01:9ECB 46              	  2914: 		LD		B,(HL)			; Get LSB of address
01:9ECC 23              	  2915: 		INC		HL
01:9ECD 66              	  2916: 		LD		H,(HL)			; Get MSB of address
01:9ECE 68              	  2917: 		LD		L,B				; HL = address of string
01:9ECF 0600            	  2918: 		LD		B,0				; BC = starting address
01:9ED1 09              	  2919: 		ADD		HL,BC			; Point to that byte
01:9ED2 44              	  2920: 		LD		B,H				; BC = source string
01:9ED3 4D              	  2921: 		LD		C,L
01:9ED4 CDC29C          	  2922: 		CALL	CRTMST			; Create a string entry
01:9ED7 6F              	  2923: 		LD		L,A				; Length of new string
01:9ED8 CD469E          	  2924: 		CALL	TOSTRA			; Move string to string area
01:9EDB D1              	  2925: 		POP		DE				; Clear stack
01:9EDC CD579E          	  2926: 		CALL	GSTRDE			; Move to string pool if needed
01:9EDF C3F09C          	  2927: 		JP		TSTOPL			; Temporary string to pool
                        	  2928: 
01:9EE2 CD4B9F          	  2929: RIGHT:	CALL	LFRGNM			; Get number and ending ")"
01:9EE5 D1              	  2930: 		POP		DE				; Get string length
01:9EE6 D5              	  2931: 		PUSH	DE				; And re-save
01:9EE7 1A              	  2932: 		LD		A,(DE)			; Get length
01:9EE8 90              	  2933: 		SUB		B				; Move back N bytes
01:9EE9 C3B69E          	  2934: 		JP		RIGHT1			; Go and get sub-string
                        	  2935: 
01:9EEC EB              	  2936: MID:	EX		DE,HL			; Get code string address
01:9EED 7E              	  2937: 		LD		A,(HL)			; Get next byte ',' or ")"
01:9EEE CD509F          	  2938: 		CALL	MIDNUM			; Get number supplied
01:9EF1 04              	  2939: 		INC		B				; Is it character zero?
01:9EF2 05              	  2940: 		DEC		B
01:9EF3 CA9894          	  2941: 		JP		Z,FCERR			; Yes - Error
01:9EF6 C5              	  2942: 		PUSH	BC				; Save starting position
01:9EF7 1EFF            	  2943: 		LD		E,255			; All of string
01:9EF9 FE29            	  2944: 		CP		')'				; Any length given?
01:9EFB CA059F          	  2945: 		JP		Z,RSTSTR		; No - Rest of string
01:9EFE CD4492          	  2946: 		CALL	CHKSYN			; Make sure ',' follows
01:9F01 2C              	  2947: 		db	   ','
01:9F02 CD989F          	  2948: 		CALL	GETINT			; Get integer 0-255
01:9F05 CD4492          	  2949: RSTSTR: CALL	CHKSYN			; Make sure ")" follows
01:9F08 29              	  2950: 		db	   ")"
01:9F09 F1              	  2951: 		POP		AF				; Restore starting position
01:9F0A E3              	  2952: 		EX		(SP),HL			; Get string,8ave code string
01:9F0B 01B89E          	  2953: 		LD		BC,MID1			; Continuation of MID$ routine
01:9F0E C5              	  2954: 		PUSH	BC				; Save for return
01:9F0F 3D              	  2955: 		DEC		A				; Starting position-1
01:9F10 BE              	  2956: 		CP		(HL)			; Compare with length
01:9F11 0600            	  2957: 		LD		B,0				; Zero bytes length
01:9F13 D0              	  2958: 		RET		NC				; Null string if start past end
01:9F14 4F              	  2959: 		LD		C,A				; Save starting position-1
01:9F15 7E              	  2960: 		LD		A,(HL)			; Get length of string
01:9F16 91              	  2961: 		SUB		C				; Subtract start
01:9F17 BB              	  2962: 		CP		E				; Enough string for it?
01:9F18 47              	  2963: 		LD		B,A				; Save maximum length available
01:9F19 D8              	  2964: 		RET		C				; Truncate string if needed
01:9F1A 43              	  2965: 		LD		B,E				; Set specified length
01:9F1B C9              	  2966: 		RET						; Go and create string
                        	  2967: 
01:9F1C CD869E          	  2968: VAL:	CALL	GETLEN			; Get length of string
01:9F1F CA39A0          	  2969: 		JP		Z,RESZER		; Result zero
01:9F22 5F              	  2970: 		LD		E,A				; Save length
01:9F23 23              	  2971: 		INC		HL
01:9F24 23              	  2972: 		INC		HL
01:9F25 7E              	  2973: 		LD		A,(HL)			; Get LSB of address
01:9F26 23              	  2974: 		INC		HL
01:9F27 66              	  2975: 		LD		H,(HL)			; Get MSB of address
01:9F28 6F              	  2976: 		LD		L,A				; HL = String address
01:9F29 E5              	  2977: 		PUSH	HL				; Save string address
01:9F2A 19              	  2978: 		ADD		HL,DE
01:9F2B 46              	  2979: 		LD		B,(HL)			; Get end of string+1 byte
01:9F2C 72              	  2980: 		LD		(HL),D			; Zero it to terminate
01:9F2D E3              	  2981: 		EX		(SP),HL			; Save string end,get start
01:9F2E C5              	  2982: 		PUSH	BC				; Save end+1 byte
01:9F2F 7E              	  2983: 		LD		A,(HL)			; Get starting byte
01:9F30 FE24            	  2984: 		CP		'$'				; Hex number indicated? [function added]
01:9F32 C23A9F          	  2985: 		JP		NZ,VAL1
01:9F35 CD68A7          	  2986: 		CALL	HEXTFP			; Convert Hex to FPREG
01:9F38 180D            	  2987: 		JR		VAL3
01:9F3A FE25            	  2988: VAL1:	CP		'%'				; Binary number indicated? [function added]
01:9F3C C2449F          	  2989: 		JP		NZ,VAL2
01:9F3F CDD8A7          	  2990: 		CALL	BINTFP		; Convert Bin to FPREG
01:9F42 1803            	  2991: 		JR		VAL3
01:9F44 CD20A3          	  2992: VAL2:	CALL	ASCTFP			; Convert ASCII string to FP
01:9F47 C1              	  2993: VAL3:	POP		BC				; Restore end+1 byte
01:9F48 E1              	  2994: 		POP		HL				; Restore end+1 address
01:9F49 70              	  2995: 		LD		(HL),B			; Put back original byte
01:9F4A C9              	  2996: 		RET
                        	  2997: 
01:9F4B EB              	  2998: LFRGNM: EX		DE,HL			; Code string address to HL
01:9F4C CD4492          	  2999: 		CALL	CHKSYN			; Make sure ")" follows
01:9F4F 29              	  3000: 		db	   ")"
01:9F50 C1              	  3001: MIDNUM: POP		BC				; Get return address
01:9F51 D1              	  3002: 		POP		DE				; Get number supplied
01:9F52 C5              	  3003: 		PUSH	BC				; Re-save return address
01:9F53 43              	  3004: 		LD		B,E				; Number to B
01:9F54 C9              	  3005: 		RET
                        	  3006: 
01:9F55 CD9B9F          	  3007: INP:	CALL	MAKINT			; Make it integer A
01:9F58 323F10          	  3008: 		LD		(INPORT),A		; Set input port
01:9F5B CD3E10          	  3009: 		CALL	INPSUB			; Get input from port
01:9F5E C3019C          	  3010: 		JP		PASSA			; Return integer A
                        	  3011: 
01:9F61 CD859F          	  3012: POUT:	CALL	SETIO			; Set up port number
01:9F64 C30610          	  3013: 		JP		OUTSUB			; Output data and return
                        	  3014: 
01:9F67 CD859F          	  3015: WAIT:	CALL	SETIO			; Set up port number
01:9F6A F5              	  3016: 		PUSH	AF				; Save AND mask
01:9F6B 1E00            	  3017: 		LD		E,0				; Assume zero if none given
01:9F6D 2B              	  3018: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9F6E CDCE93          	  3019: 		CALL	GETCHR			; Get next character
01:9F71 CA7B9F          	  3020: 		JP		Z,NOXOR			; No XOR byte given
01:9F74 CD4492          	  3021: 		CALL	CHKSYN			; Make sure ',' follows
01:9F77 2C              	  3022: 		db	   ','
01:9F78 CD989F          	  3023: 		CALL	GETINT			; Get integer 0-255 to XOR with
01:9F7B C1              	  3024: NOXOR:	POP		BC				; Restore AND mask
01:9F7C CD3E10          	  3025: WAITLP: CALL	INPSUB			; Get input
01:9F7F AB              	  3026: 		XOR		E				; Flip selected bits
01:9F80 A0              	  3027: 		AND		B				; Result non-zero?
01:9F81 CA7C9F          	  3028: 		JP		Z,WAITLP		; No = keep waiting
01:9F84 C9              	  3029: 		RET
                        	  3030: 
01:9F85 CD989F          	  3031: SETIO:	CALL	GETINT			; Get integer 0-255
01:9F88 323F10          	  3032: 		LD		(INPORT),A		; Set input port
01:9F8B 320710          	  3033: 		LD		(OTPORT),A		; Set output port
01:9F8E CD4492          	  3034: 		CALL	CHKSYN			; Make sure ',' follows
01:9F91 2C              	  3035: 		db	   ','
01:9F92 C3989F          	  3036: 		JP		GETINT			; Get integer 0-255 and return
                        	  3037: 
01:9F95 CDCE93          	  3038: FNDNUM: CALL	GETCHR			; Get next character
01:9F98 CD3798          	  3039: GETINT: CALL	GETNUM			; Get a number from 0 to 255
01:9F9B CD7D94          	  3040: MAKINT: CALL	DEPINT			; Make sure value 0 - 255
01:9F9E 7A              	  3041: 		LD		A,D				; Get MSB of number
01:9F9F B7              	  3042: 		OR		A				; Zero?
01:9FA0 C29894          	  3043: 		JP		NZ,FCERR		; No - Error
01:9FA3 2B              	  3044: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9FA4 CDCE93          	  3045: 		CALL	GETCHR			; Get next character
01:9FA7 7B              	  3046: 		LD		A,E				; Get number to A
01:9FA8 C9              	  3047: 		RET
                        	  3048: 
01:9FA9 CD8394          	  3049: PEEK:	CALL	DEINT			; Get memory address
01:9FAC 1A              	  3050: 		LD		A,(DE)			; Get byte in memory
01:9FAD C3019C          	  3051: 		JP		PASSA			; Return integer A
                        	  3052: 
01:9FB0 CD3798          	  3053: POKE:	CALL	GETNUM			; Get memory address
01:9FB3 CD8394          	  3054: 		CALL	DEINT			; Get integer -32768 to 3276
01:9FB6 D5              	  3055: 		PUSH	DE				; Save memory address
01:9FB7 CD4492          	  3056: 		CALL	CHKSYN			; Make sure ',' follows
01:9FBA 2C              	  3057: 		db	   ','
01:9FBB CD989F          	  3058: 		CALL	GETINT			; Get integer 0-255
01:9FBE D1              	  3059: 		POP		DE				; Restore memory address
01:9FBF 12              	  3060: 		LD		(DE),A			; Load it into memory
01:9FC0 C9              	  3061: 		RET
                        	  3062: 
01:9FC1 2197A4          	  3063: ROUND:	LD		HL,HALF			; Add 0.5 to FPREG
01:9FC4 CD68A2          	  3064: ADDPHL: CALL	LOADFP			; Load FP at (HL) to BCDE
01:9FC7 C3D39F          	  3065: 		JP		FPADD			; Add BCDE to FPREG
                        	  3066: 
01:9FCA CD68A2          	  3067: SUBPHL: CALL	LOADFP			; FPREG = -FPREG + number at HL
01:9FCD 21              	  3068: 		db	   21H			   ; Skip "POP BC" and "POP DE"
01:9FCE C1              	  3069: PSUB:	POP		BC				; Get FP number from stack
01:9FCF D1              	  3070: 		POP		DE
01:9FD0 CD42A2          	  3071: SUBCDE: CALL	INVSGN			; Negate FPREG
01:9FD3 78              	  3072: FPADD:	LD		A,B				; Get FP exponent
01:9FD4 B7              	  3073: 		OR		A				; Is number zero?
01:9FD5 C8              	  3074: 		RET		Z				; Yes - Nothing to add
01:9FD6 3AE710          	  3075: 		LD		A,(FPEXP)		; Get FPREG exponent
01:9FD9 B7              	  3076: 		OR		A				; Is this number zero?
01:9FDA CA5AA2          	  3077: 		JP		Z,FPBCDE		; Yes - Move BCDE to FPREG
01:9FDD 90              	  3078: 		SUB		B				; BCDE number larger?
01:9FDE D2ED9F          	  3079: 		JP		NC,NOSWAP		; No - Don't swap them
01:9FE1 2F              	  3080: 		CPL						; Two's complement
01:9FE2 3C              	  3081: 		INC		A				;  FP exponent
01:9FE3 EB              	  3082: 		EX		DE,HL
01:9FE4 CD4AA2          	  3083: 		CALL	STAKFP			; Put FPREG on stack
01:9FE7 EB              	  3084: 		EX		DE,HL
01:9FE8 CD5AA2          	  3085: 		CALL	FPBCDE			; Move BCDE to FPREG
01:9FEB C1              	  3086: 		POP		BC				; Restore number from stack
01:9FEC D1              	  3087: 		POP		DE
01:9FED FE19            	  3088: NOSWAP: CP		24+1			; Second number insignificant?
01:9FEF D0              	  3089: 		RET		NC				; Yes - First number is result
01:9FF0 F5              	  3090: 		PUSH	AF				; Save number of bits to scale
01:9FF1 CD7FA2          	  3091: 		CALL	SIGNS			; Set MSBs & sign of result
01:9FF4 67              	  3092: 		LD		H,A				; Save sign of result
01:9FF5 F1              	  3093: 		POP		AF				; Restore scaling factor
01:9FF6 CD98A0          	  3094: 		CALL	SCALE			; Scale BCDE to same exponent
01:9FF9 B4              	  3095: 		OR		H				; Result to be positive?
01:9FFA 21E410          	  3096: 		LD		HL,FPREG		; Point to FPREG
01:9FFD F213A0          	  3097: 		JP		P,MINCDE		; No - Subtract FPREG from CDE
01:A000 CD78A0          	  3098: 		CALL	PLUCDE			; Add FPREG to CDE
01:A003 D259A0          	  3099: 		JP		NC,RONDUP		; No overflow - Round it up
01:A006 23              	  3100: 		INC		HL				; Point to exponent
01:A007 34              	  3101: 		INC		(HL)			; Increment it
01:A008 CA858F          	  3102: 		JP		Z,OVERR			; Number overflowed - Error
01:A00B 2E01            	  3103: 		LD		L,1				; 1 bit to shift right
01:A00D CDAEA0          	  3104: 		CALL	SHRT1			; Shift result right
01:A010 C359A0          	  3105: 		JP		RONDUP			; Round it up
                        	  3106: 
01:A013 AF              	  3107: MINCDE: XOR		A				; Clear A and carry
01:A014 90              	  3108: 		SUB		B				; Negate exponent
01:A015 47              	  3109: 		LD		B,A				; Re-save exponent
01:A016 7E              	  3110: 		LD		A,(HL)			; Get LSB of FPREG
01:A017 9B              	  3111: 		SBC		A, E			; Subtract LSB of BCDE
01:A018 5F              	  3112: 		LD		E,A				; Save LSB of BCDE
01:A019 23              	  3113: 		INC		HL
01:A01A 7E              	  3114: 		LD		A,(HL)			; Get NMSB of FPREG
01:A01B 9A              	  3115: 		SBC		A,D				; Subtract NMSB of BCDE
01:A01C 57              	  3116: 		LD		D,A				; Save NMSB of BCDE
01:A01D 23              	  3117: 		INC		HL
01:A01E 7E              	  3118: 		LD		A,(HL)			; Get MSB of FPREG
01:A01F 99              	  3119: 		SBC		A,C				; Subtract MSB of BCDE
01:A020 4F              	  3120: 		LD		C,A				; Save MSB of BCDE
01:A021 DC84A0          	  3121: CONPOS: CALL	C,COMPL			; Overflow - Make it positive
                        	  3122: 
01:A024 68              	  3123: BNORM:	LD		L,B				; L = Exponent
01:A025 63              	  3124: 		LD		H,E				; H = LSB
01:A026 AF              	  3125: 		XOR		A
01:A027 47              	  3126: BNRMLP: LD		B,A				; Save bit count
01:A028 79              	  3127: 		LD		A,C				; Get MSB
01:A029 B7              	  3128: 		OR		A				; Is it zero?
01:A02A C246A0          	  3129: 		JP		NZ,PNORM		; No - Do it bit at a time
01:A02D 4A              	  3130: 		LD		C,D				; MSB = NMSB
01:A02E 54              	  3131: 		LD		D,H				; NMSB= LSB
01:A02F 65              	  3132: 		LD		H,L				; LSB = VLSB
01:A030 6F              	  3133: 		LD		L,A				; VLSB= 0
01:A031 78              	  3134: 		LD		A,B				; Get exponent
01:A032 D608            	  3135: 		SUB		8				; Count 8 bits
01:A034 FEE0            	  3136: 		CP		-24-8			; Was number zero?
01:A036 C227A0          	  3137: 		JP		NZ,BNRMLP		; No - Keep normalising
01:A039 AF              	  3138: RESZER: XOR		A				; Result is zero
01:A03A 32E710          	  3139: SAVEXP: LD		(FPEXP),A		; Save result as zero
01:A03D C9              	  3140: 		RET
                        	  3141: 
01:A03E 05              	  3142: NORMAL: DEC		B				; Count bits
01:A03F 29              	  3143: 		ADD		HL,HL			; Shift HL left
01:A040 7A              	  3144: 		LD		A,D				; Get NMSB
01:A041 17              	  3145: 		RLA						; Shift left with last bit
01:A042 57              	  3146: 		LD		D,A				; Save NMSB
01:A043 79              	  3147: 		LD		A,C				; Get MSB
01:A044 8F              	  3148: 		ADC		A,A				; Shift left with last bit
01:A045 4F              	  3149: 		LD		C,A				; Save MSB
01:A046 F23EA0          	  3150: PNORM:	JP		P,NORMAL		; Not done - Keep going
01:A049 78              	  3151: 		LD		A,B				; Number of bits shifted
01:A04A 5C              	  3152: 		LD		E,H				; Save HL in EB
01:A04B 45              	  3153: 		LD		B,L
01:A04C B7              	  3154: 		OR		A				; Any shifting done?
01:A04D CA59A0          	  3155: 		JP		Z,RONDUP		; No - Round it up
01:A050 21E710          	  3156: 		LD		HL,FPEXP		; Point to exponent
01:A053 86              	  3157: 		ADD		A,(HL)			; Add shifted bits
01:A054 77              	  3158: 		LD		(HL),A			; Re-save exponent
01:A055 D239A0          	  3159: 		JP		NC,RESZER		; Underflow - Result is zero
01:A058 C8              	  3160: 		RET		Z				; Result is zero
01:A059 78              	  3161: RONDUP: LD		A,B				; Get VLSB of number
01:A05A 21E710          	  3162: RONDB:	LD		HL,FPEXP		; Point to exponent
01:A05D B7              	  3163: 		OR		A				; Any rounding?
01:A05E FC6BA0          	  3164: 		CALL	M,FPROND		; Yes - Round number up
01:A061 46              	  3165: 		LD		B,(HL)			; B = Exponent
01:A062 23              	  3166: 		INC		HL
01:A063 7E              	  3167: 		LD		A,(HL)			; Get sign of result
01:A064 E680            	  3168: 		AND		10000000B		; Only bit 7 needed
01:A066 A9              	  3169: 		XOR		C				; Set correct sign
01:A067 4F              	  3170: 		LD		C,A				; Save correct sign in number
01:A068 C35AA2          	  3171: 		JP		FPBCDE			; Move BCDE to FPREG
                        	  3172: 
01:A06B 1C              	  3173: FPROND: INC		E				; Round LSB
01:A06C C0              	  3174: 		RET		NZ				; Return if ok
01:A06D 14              	  3175: 		INC		D				; Round NMSB
01:A06E C0              	  3176: 		RET		NZ				; Return if ok
01:A06F 0C              	  3177: 		INC		C				; Round MSB
01:A070 C0              	  3178: 		RET		NZ				; Return if ok
01:A071 0E80            	  3179: 		LD		C,80H			; Set normal value
01:A073 34              	  3180: 		INC		(HL)			; Increment exponent
01:A074 C0              	  3181: 		RET		NZ				; Return if ok
01:A075 C3858F          	  3182: 		JP		OVERR			; Overflow error
                        	  3183: 
01:A078 7E              	  3184: PLUCDE: LD		A,(HL)			; Get LSB of FPREG
01:A079 83              	  3185: 		ADD		A,E				; Add LSB of BCDE
01:A07A 5F              	  3186: 		LD		E,A				; Save LSB of BCDE
01:A07B 23              	  3187: 		INC		HL
01:A07C 7E              	  3188: 		LD		A,(HL)			; Get NMSB of FPREG
01:A07D 8A              	  3189: 		ADC		A,D				; Add NMSB of BCDE
01:A07E 57              	  3190: 		LD		D,A				; Save NMSB of BCDE
01:A07F 23              	  3191: 		INC		HL
01:A080 7E              	  3192: 		LD		A,(HL)			; Get MSB of FPREG
01:A081 89              	  3193: 		ADC		A,C				; Add MSB of BCDE
01:A082 4F              	  3194: 		LD		C,A				; Save MSB of BCDE
01:A083 C9              	  3195: 		RET
                        	  3196: 
01:A084 21E810          	  3197: COMPL:	LD		HL,SGNRES		; Sign of result
01:A087 7E              	  3198: 		LD		A,(HL)			; Get sign of result
01:A088 2F              	  3199: 		CPL						; Negate it
01:A089 77              	  3200: 		LD		(HL),A			; Put it back
01:A08A AF              	  3201: 		XOR		A
01:A08B 6F              	  3202: 		LD		L,A				; Set L to zero
01:A08C 90              	  3203: 		SUB		B				; Negate exponent,set carry
01:A08D 47              	  3204: 		LD		B,A				; Re-save exponent
01:A08E 7D              	  3205: 		LD		A,L				; Load zero
01:A08F 9B              	  3206: 		SBC		A,E				; Negate LSB
01:A090 5F              	  3207: 		LD		E,A				; Re-save LSB
01:A091 7D              	  3208: 		LD		A,L				; Load zero
01:A092 9A              	  3209: 		SBC		A,D				; Negate NMSB
01:A093 57              	  3210: 		LD		D,A				; Re-save NMSB
01:A094 7D              	  3211: 		LD		A,L				; Load zero
01:A095 99              	  3212: 		SBC		A,C				; Negate MSB
01:A096 4F              	  3213: 		LD		C,A				; Re-save MSB
01:A097 C9              	  3214: 		RET
                        	  3215: 
01:A098 0600            	  3216: SCALE:	LD		B,0				; Clear underflow
01:A09A D608            	  3217: SCALLP: SUB		8				; 8 bits (a whole byte)?
01:A09C DAA7A0          	  3218: 		JP		C,SHRITE		; No - Shift right A bits
01:A09F 43              	  3219: 		LD		B,E				; <- Shift
01:A0A0 5A              	  3220: 		LD		E,D				; <- right
01:A0A1 51              	  3221: 		LD		D,C				; <- eight
01:A0A2 0E00            	  3222: 		LD		C,0				; <- bits
01:A0A4 C39AA0          	  3223: 		JP		SCALLP			; More bits to shift
                        	  3224: 
01:A0A7 C609            	  3225: SHRITE: ADD		A,8+1			; Adjust count
01:A0A9 6F              	  3226: 		LD		L,A				; Save bits to shift
01:A0AA AF              	  3227: SHRLP:	XOR		A				; Flag for all done
01:A0AB 2D              	  3228: 		DEC		L				; All shifting done?
01:A0AC C8              	  3229: 		RET		Z				; Yes - Return
01:A0AD 79              	  3230: 		LD		A,C				; Get MSB
01:A0AE 1F              	  3231: SHRT1:	RRA						; Shift it right
01:A0AF 4F              	  3232: 		LD		C,A				; Re-save
01:A0B0 7A              	  3233: 		LD		A,D				; Get NMSB
01:A0B1 1F              	  3234: 		RRA						; Shift right with last bit
01:A0B2 57              	  3235: 		LD		D,A				; Re-save it
01:A0B3 7B              	  3236: 		LD		A,E				; Get LSB
01:A0B4 1F              	  3237: 		RRA						; Shift right with last bit
01:A0B5 5F              	  3238: 		LD		E,A				; Re-save it
01:A0B6 78              	  3239: 		LD		A,B				; Get underflow
01:A0B7 1F              	  3240: 		RRA						; Shift right with last bit
01:A0B8 47              	  3241: 		LD		B,A				; Re-save underflow
01:A0B9 C3AAA0          	  3242: 		JP		SHRLP			; More bits to do
                        	  3243: 
01:A0BC 00              	  3244: UNITY:	db		000H,000H,000H,081H	   ; 1.00000
01:A0BD 00
01:A0BE 00
01:A0BF 81
                        	  3245: 
01:A0C0 03              	  3246: LOGTAB: db	   3					   ; Table used by LOG
01:A0C1 AA              	  3247: 		db	   0AAH,056H,019H,080H	   ; 0.59898
01:A0C2 56
01:A0C3 19
01:A0C4 80
01:A0C5 F1              	  3248: 		db	   0F1H,022H,076H,080H	   ; 0.96147
01:A0C6 22
01:A0C7 76
01:A0C8 80
01:A0C9 45              	  3249: 		db	   045H,0AAH,038H,082H	   ; 2.88539
01:A0CA AA
01:A0CB 38
01:A0CC 82
                        	  3250: 
01:A0CD CD19A2          	  3251: LOG:	CALL	TSTSGN			; Test sign of value
01:A0D0 B7              	  3252: 		OR		A
01:A0D1 EA9894          	  3253: 		JP		PE,FCERR		; ?FC Error if <= zero
01:A0D4 21E710          	  3254: 		LD		HL,FPEXP		; Point to exponent
01:A0D7 7E              	  3255: 		LD		A,(HL)			; Get exponent
01:A0D8 013580          	  3256: 		LD		BC,8035H		; BCDE = SQR(1/2)
01:A0DB 11F304          	  3257: 		LD		DE,04F3H
01:A0DE 90              	  3258: 		SUB		B				; Scale value to be < 1
01:A0DF F5              	  3259: 		PUSH	AF				; Save scale factor
01:A0E0 70              	  3260: 		LD		(HL),B			; Save new exponent
01:A0E1 D5              	  3261: 		PUSH	DE				; Save SQR(1/2)
01:A0E2 C5              	  3262: 		PUSH	BC
01:A0E3 CDD39F          	  3263: 		CALL	FPADD			; Add SQR(1/2) to value
01:A0E6 C1              	  3264: 		POP		BC				; Restore SQR(1/2)
01:A0E7 D1              	  3265: 		POP		DE
01:A0E8 04              	  3266: 		INC		B				; Make it SQR(2)
01:A0E9 CD6FA1          	  3267: 		CALL	DVBCDE			; Divide by SQR(2)
01:A0EC 21BCA0          	  3268: 		LD		HL,UNITY		; Point to 1.
01:A0EF CDCA9F          	  3269: 		CALL	SUBPHL			; Subtract FPREG from 1
01:A0F2 21C0A0          	  3270: 		LD		HL,LOGTAB		; Coefficient table
01:A0F5 CD61A5          	  3271: 		CALL	SUMSER			; Evaluate sum of series
01:A0F8 018080          	  3272: 		LD		BC,8080H		; BCDE = -0.5
01:A0FB 110000          	  3273: 		LD		DE,0000H
01:A0FE CDD39F          	  3274: 		CALL	FPADD			; Subtract 0.5 from FPREG
01:A101 F1              	  3275: 		POP		AF				; Restore scale factor
01:A102 CD94A3          	  3276: 		CALL	RSCALE			; Re-scale number
01:A105 013180          	  3277: MULLN2: LD		BC,8031H		; BCDE = Ln(2)
01:A108 111872          	  3278: 		LD		DE,7218H
01:A10B 21              	  3279: 		db	   21H			   ; Skip "POP BC" and "POP DE"
                        	  3280: 
01:A10C C1              	  3281: MULTT:	POP		BC				; Get number from stack
01:A10D D1              	  3282: 		POP		DE
01:A10E CD19A2          	  3283: FPMULT: CALL	TSTSGN			; Test sign of FPREG
01:A111 C8              	  3284: 		RET		Z				; Return zero if zero
01:A112 2E00            	  3285: 		LD		L,0				; Flag add exponents
01:A114 CDD7A1          	  3286: 		CALL	ADDEXP			; Add exponents
01:A117 79              	  3287: 		LD		A,C				; Get MSB of multiplier
01:A118 32F610          	  3288: 		LD		(MULVAL),A		; Save MSB of multiplier
01:A11B EB              	  3289: 		EX		DE,HL
01:A11C 22F710          	  3290: 		LD		(MULVAL+1),HL	; Save rest of multiplier
01:A11F 010000          	  3291: 		LD		BC,0			; Partial product (BCDE) = zero
01:A122 50              	  3292: 		LD		D,B
01:A123 58              	  3293: 		LD		E,B
01:A124 2124A0          	  3294: 		LD		HL,BNORM		; Address of normalise
01:A127 E5              	  3295: 		PUSH	HL				; Save for return
01:A128 2130A1          	  3296: 		LD		HL,MULT8		; Address of 8 bit multiply
01:A12B E5              	  3297: 		PUSH	HL				; Save for NMSB,MSB
01:A12C E5              	  3298: 		PUSH	HL				; 
01:A12D 21E410          	  3299: 		LD		HL,FPREG		; Point to number
01:A130 7E              	  3300: MULT8:	LD		A,(HL)			; Get LSB of number
01:A131 23              	  3301: 		INC		HL				; Point to NMSB
01:A132 B7              	  3302: 		OR		A				; Test LSB
01:A133 CA5CA1          	  3303: 		JP		Z,BYTSFT		; Zero - shift to next byte
01:A136 E5              	  3304: 		PUSH	HL				; Save address of number
01:A137 2E08            	  3305: 		LD		L,8				; 8 bits to multiply by
01:A139 1F              	  3306: MUL8LP: RRA						; Shift LSB right
01:A13A 67              	  3307: 		LD		H,A				; Save LSB
01:A13B 79              	  3308: 		LD		A,C				; Get MSB
01:A13C D24AA1          	  3309: 		JP		NC,NOMADD		; Bit was zero - Don't add
01:A13F E5              	  3310: 		PUSH	HL				; Save LSB and count
01:A140 2AF710          	  3311: 		LD		HL,(MULVAL+1)	; Get LSB and NMSB
01:A143 19              	  3312: 		ADD		HL,DE			; Add NMSB and LSB
01:A144 EB              	  3313: 		EX		DE,HL			; Leave sum in DE
01:A145 E1              	  3314: 		POP		HL				; Restore MSB and count
01:A146 3AF610          	  3315: 		LD		A,(MULVAL)		; Get MSB of multiplier
01:A149 89              	  3316: 		ADC		A,C				; Add MSB
01:A14A 1F              	  3317: NOMADD: RRA						; Shift MSB right
01:A14B 4F              	  3318: 		LD		C,A				; Re-save MSB
01:A14C 7A              	  3319: 		LD		A,D				; Get NMSB
01:A14D 1F              	  3320: 		RRA						; Shift NMSB right
01:A14E 57              	  3321: 		LD		D,A				; Re-save NMSB
01:A14F 7B              	  3322: 		LD		A,E				; Get LSB
01:A150 1F              	  3323: 		RRA						; Shift LSB right
01:A151 5F              	  3324: 		LD		E,A				; Re-save LSB
01:A152 78              	  3325: 		LD		A,B				; Get VLSB
01:A153 1F              	  3326: 		RRA						; Shift VLSB right
01:A154 47              	  3327: 		LD		B,A				; Re-save VLSB
01:A155 2D              	  3328: 		DEC		L				; Count bits multiplied
01:A156 7C              	  3329: 		LD		A,H				; Get LSB of multiplier
01:A157 C239A1          	  3330: 		JP		NZ,MUL8LP		; More - Do it
01:A15A E1              	  3331: POPHRT: POP		HL				; Restore address of number
01:A15B C9              	  3332: 		RET
                        	  3333: 
01:A15C 43              	  3334: BYTSFT: LD		B,E				; Shift partial product left
01:A15D 5A              	  3335: 		LD		E,D
01:A15E 51              	  3336: 		LD		D,C
01:A15F 4F              	  3337: 		LD		C,A
01:A160 C9              	  3338: 		RET
                        	  3339: 
01:A161 CD4AA2          	  3340: DIV10:	CALL	STAKFP			; Save FPREG on stack
01:A164 012084          	  3341: 		LD		BC,8420H		; BCDE = 10.
01:A167 110000          	  3342: 		LD		DE,0000H
01:A16A CD5AA2          	  3343: 		CALL	FPBCDE			; Move 10 to FPREG
                        	  3344: 
01:A16D C1              	  3345: DIV:	POP		BC				; Get number from stack
01:A16E D1              	  3346: 		POP		DE
01:A16F CD19A2          	  3347: DVBCDE: CALL	TSTSGN			; Test sign of FPREG
01:A172 CA798F          	  3348: 		JP		Z,DZERR			; Error if division by zero
01:A175 2EFF            	  3349: 		LD		L,-1			; Flag subtract exponents
01:A177 CDD7A1          	  3350: 		CALL	ADDEXP			; Subtract exponents
01:A17A 34              	  3351: 		INC		(HL)			; Add 2 to exponent to adjust
01:A17B 34              	  3352: 		INC		(HL)
01:A17C 2B              	  3353: 		DEC		HL				; Point to MSB
01:A17D 7E              	  3354: 		LD		A,(HL)			; Get MSB of dividend
01:A17E 321210          	  3355: 		LD		(DIV3),A		; Save for subtraction
01:A181 2B              	  3356: 		DEC		HL
01:A182 7E              	  3357: 		LD		A,(HL)			; Get NMSB of dividend
01:A183 320E10          	  3358: 		LD		(DIV2),A		; Save for subtraction
01:A186 2B              	  3359: 		DEC		HL
01:A187 7E              	  3360: 		LD		A,(HL)			; Get MSB of dividend
01:A188 320A10          	  3361: 		LD		(DIV1),A		; Save for subtraction
01:A18B 41              	  3362: 		LD		B,C				; Get MSB
01:A18C EB              	  3363: 		EX		DE,HL			; NMSB,LSB to HL
01:A18D AF              	  3364: 		XOR		A
01:A18E 4F              	  3365: 		LD		C,A				; Clear MSB of quotient
01:A18F 57              	  3366: 		LD		D,A				; Clear NMSB of quotient
01:A190 5F              	  3367: 		LD		E,A				; Clear LSB of quotient
01:A191 321510          	  3368: 		LD		(DIV4),A		; Clear overflow count
01:A194 E5              	  3369: DIVLP:	PUSH	HL				; Save divisor
01:A195 C5              	  3370: 		PUSH	BC
01:A196 7D              	  3371: 		LD		A,L				; Get LSB of number
01:A197 CD0910          	  3372: 		CALL	DIVSUP			; Subt' divisor from dividend
01:A19A DE00            	  3373: 		SBC		A,0				; Count for overflows
01:A19C 3F              	  3374: 		CCF
01:A19D D2A7A1          	  3375: 		JP		NC,RESDIV		; Restore divisor if borrow
01:A1A0 321510          	  3376: 		LD		(DIV4),A		; Re-save overflow count
01:A1A3 F1              	  3377: 		POP		AF				; Scrap divisor
01:A1A4 F1              	  3378: 		POP		AF
01:A1A5 37              	  3379: 		SCF						; Set carry to
01:A1A6 D2              	  3380: 		db	   0D2H			   ; Skip "POP BC" and "POP HL"
                        	  3381: 
01:A1A7 C1              	  3382: RESDIV: POP		BC				; Restore divisor
01:A1A8 E1              	  3383: 		POP		HL
01:A1A9 79              	  3384: 		LD		A,C				; Get MSB of quotient
01:A1AA 3C              	  3385: 		INC		A
01:A1AB 3D              	  3386: 		DEC		A
01:A1AC 1F              	  3387: 		RRA						; Bit 0 to bit 7
01:A1AD FA5AA0          	  3388: 		JP		M,RONDB			; Done - Normalise result
01:A1B0 17              	  3389: 		RLA						; Restore carry
01:A1B1 7B              	  3390: 		LD		A,E				; Get LSB of quotient
01:A1B2 17              	  3391: 		RLA						; Double it
01:A1B3 5F              	  3392: 		LD		E,A				; Put it back
01:A1B4 7A              	  3393: 		LD		A,D				; Get NMSB of quotient
01:A1B5 17              	  3394: 		RLA						; Double it
01:A1B6 57              	  3395: 		LD		D,A				; Put it back
01:A1B7 79              	  3396: 		LD		A,C				; Get MSB of quotient
01:A1B8 17              	  3397: 		RLA						; Double it
01:A1B9 4F              	  3398: 		LD		C,A				; Put it back
01:A1BA 29              	  3399: 		ADD		HL,HL			; Double NMSB,LSB of divisor
01:A1BB 78              	  3400: 		LD		A,B				; Get MSB of divisor
01:A1BC 17              	  3401: 		RLA						; Double it
01:A1BD 47              	  3402: 		LD		B,A				; Put it back
01:A1BE 3A1510          	  3403: 		LD		A,(DIV4)		; Get VLSB of quotient
01:A1C1 17              	  3404: 		RLA						; Double it
01:A1C2 321510          	  3405: 		LD		(DIV4),A		; Put it back
01:A1C5 79              	  3406: 		LD		A,C				; Get MSB of quotient
01:A1C6 B2              	  3407: 		OR		D				; Merge NMSB
01:A1C7 B3              	  3408: 		OR		E				; Merge LSB
01:A1C8 C294A1          	  3409: 		JP		NZ,DIVLP		; Not done - Keep dividing
01:A1CB E5              	  3410: 		PUSH	HL				; Save divisor
01:A1CC 21E710          	  3411: 		LD		HL,FPEXP		; Point to exponent
01:A1CF 35              	  3412: 		DEC		(HL)			; Divide by 2
01:A1D0 E1              	  3413: 		POP		HL				; Restore divisor
01:A1D1 C294A1          	  3414: 		JP		NZ,DIVLP		; Ok - Keep going
01:A1D4 C3858F          	  3415: 		JP		OVERR			; Overflow error
                        	  3416: 
01:A1D7 78              	  3417: ADDEXP: LD		A,B				; Get exponent of dividend
01:A1D8 B7              	  3418: 		OR		A				; Test it
01:A1D9 CAFBA1          	  3419: 		JP		Z,OVTST3		; Zero - Result zero
01:A1DC 7D              	  3420: 		LD		A,L				; Get add/subtract flag
01:A1DD 21E710          	  3421: 		LD		HL,FPEXP		; Point to exponent
01:A1E0 AE              	  3422: 		XOR		(HL)			; Add or subtract it
01:A1E1 80              	  3423: 		ADD		A,B				; Add the other exponent
01:A1E2 47              	  3424: 		LD		B,A				; Save new exponent
01:A1E3 1F              	  3425: 		RRA						; Test exponent for overflow
01:A1E4 A8              	  3426: 		XOR		B
01:A1E5 78              	  3427: 		LD		A,B				; Get exponent
01:A1E6 F2FAA1          	  3428: 		JP		P,OVTST2		; Positive - Test for overflow
01:A1E9 C680            	  3429: 		ADD		A,80H			; Add excess 128
01:A1EB 77              	  3430: 		LD		(HL),A			; Save new exponent
01:A1EC CA5AA1          	  3431: 		JP		Z,POPHRT		; Zero - Result zero
01:A1EF CD7FA2          	  3432: 		CALL	SIGNS			; Set MSBs and sign of result
01:A1F2 77              	  3433: 		LD		(HL),A			; Save new exponent
01:A1F3 2B              	  3434: 		DEC		HL				; Point to MSB
01:A1F4 C9              	  3435: 		RET
                        	  3436: 
01:A1F5 CD19A2          	  3437: OVTST1: CALL	TSTSGN			; Test sign of FPREG
01:A1F8 2F              	  3438: 		CPL						; Invert sign
01:A1F9 E1              	  3439: 		POP		HL				; Clean up stack
01:A1FA B7              	  3440: OVTST2: OR		A				; Test if new exponent zero
01:A1FB E1              	  3441: OVTST3: POP		HL				; Clear off return address
01:A1FC F239A0          	  3442: 		JP		P,RESZER		; Result zero
01:A1FF C3858F          	  3443: 		JP		OVERR			; Overflow error
                        	  3444: 
01:A202 CD65A2          	  3445: MLSP10: CALL	BCDEFP			; Move FPREG to BCDE
01:A205 78              	  3446: 		LD		A,B				; Get exponent
01:A206 B7              	  3447: 		OR		A				; Is it zero?
01:A207 C8              	  3448: 		RET		Z				; Yes - Result is zero
01:A208 C602            	  3449: 		ADD		A,2				; Multiply by 4
01:A20A DA858F          	  3450: 		JP		C,OVERR			; Overflow - ?OV Error
01:A20D 47              	  3451: 		LD		B,A				; Re-save exponent
01:A20E CDD39F          	  3452: 		CALL	FPADD			; Add BCDE to FPREG (Times 5)
01:A211 21E710          	  3453: 		LD		HL,FPEXP		; Point to exponent
01:A214 34              	  3454: 		INC		(HL)			; Double number (Times 10)
01:A215 C0              	  3455: 		RET		NZ				; Ok - Return
01:A216 C3858F          	  3456: 		JP		OVERR			; Overflow error
                        	  3457: 
01:A219 3AE710          	  3458: TSTSGN: LD		A,(FPEXP)		; Get sign of FPREG
01:A21C B7              	  3459: 		OR		A
01:A21D C8              	  3460: 		RET		Z				; RETurn if number is zero
01:A21E 3AE610          	  3461: 		LD		A,(FPREG+2)		; Get MSB of FPREG
01:A221 FE              	  3462: 		db	   0FEH			   ; Test sign
01:A222 2F              	  3463: RETREL: CPL						; Invert sign
01:A223 17              	  3464: 		RLA						; Sign bit to carry
01:A224 9F              	  3465: FLGDIF: SBC		A,A				; Carry to all bits of A
01:A225 C0              	  3466: 		RET		NZ				; Return -1 if negative
01:A226 3C              	  3467: 		INC		A				; Bump to +1
01:A227 C9              	  3468: 		RET						; Positive - Return +1
                        	  3469: 
01:A228 CD19A2          	  3470: SGN:	CALL	TSTSGN			; Test sign of FPREG
01:A22B 0688            	  3471: FLGREL: LD		B,80H+8			; 8 bit integer in exponent
01:A22D 110000          	  3472: 		LD		DE,0			; Zero NMSB and LSB
01:A230 21E710          	  3473: RETINT: LD		HL,FPEXP		; Point to exponent
01:A233 4F              	  3474: 		LD		C,A				; CDE = MSB,NMSB and LSB
01:A234 70              	  3475: 		LD		(HL),B			; Save exponent
01:A235 0600            	  3476: 		LD		B,0				; CDE = integer to normalise
01:A237 23              	  3477: 		INC		HL				; Point to sign of result
01:A238 3680            	  3478: 		LD		(HL),80H		; Set sign of result
01:A23A 17              	  3479: 		RLA						; Carry = sign of integer
01:A23B C321A0          	  3480: 		JP		CONPOS			; Set sign of result
                        	  3481: 
01:A23E CD19A2          	  3482: ABS:	CALL	TSTSGN			; Test sign of FPREG
01:A241 F0              	  3483: 		RET		P				; Return if positive
01:A242 21E610          	  3484: INVSGN: LD		HL,FPREG+2		; Point to MSB
01:A245 7E              	  3485: 		LD		A,(HL)			; Get sign of mantissa
01:A246 EE80            	  3486: 		XOR		80H				; Invert sign of mantissa
01:A248 77              	  3487: 		LD		(HL),A			; Re-save sign of mantissa
01:A249 C9              	  3488: 		RET
                        	  3489: 
01:A24A EB              	  3490: STAKFP: EX		DE,HL			; Save code string address
01:A24B 2AE410          	  3491: 		LD		HL,(FPREG)		; LSB,NLSB of FPREG
01:A24E E3              	  3492: 		EX		(SP),HL			; Stack them,get return
01:A24F E5              	  3493: 		PUSH	HL				; Re-save return
01:A250 2AE610          	  3494: 		LD		HL,(FPREG+2)	; MSB and exponent of FPREG
01:A253 E3              	  3495: 		EX		(SP),HL			; Stack them,get return
01:A254 E5              	  3496: 		PUSH	HL				; Re-save return
01:A255 EB              	  3497: 		EX		DE,HL			; Restore code string address
01:A256 C9              	  3498: 		RET
                        	  3499: 
01:A257 CD68A2          	  3500: PHLTFP: CALL	LOADFP			; Number at HL to BCDE
01:A25A EB              	  3501: FPBCDE: EX		DE,HL			; Save code string address
01:A25B 22E410          	  3502: 		LD		(FPREG),HL		; Save LSB,NLSB of number
01:A25E 60              	  3503: 		LD		H,B				; Exponent of number
01:A25F 69              	  3504: 		LD		L,C				; MSB of number
01:A260 22E610          	  3505: 		LD		(FPREG+2),HL	; Save MSB and exponent
01:A263 EB              	  3506: 		EX		DE,HL			; Restore code string address
01:A264 C9              	  3507: 		RET
                        	  3508: 
01:A265 21E410          	  3509: BCDEFP: LD		HL,FPREG		; Point to FPREG
01:A268 5E              	  3510: LOADFP: LD		E,(HL)			; Get LSB of number
01:A269 23              	  3511: 		INC		HL
01:A26A 56              	  3512: 		LD		D,(HL)			; Get NMSB of number
01:A26B 23              	  3513: 		INC		HL
01:A26C 4E              	  3514: 		LD		C,(HL)			; Get MSB of number
01:A26D 23              	  3515: 		INC		HL
01:A26E 46              	  3516: 		LD		B,(HL)			; Get exponent of number
01:A26F 23              	  3517: INCHL:	INC		HL				; Used for conditional "INC HL"
01:A270 C9              	  3518: 		RET
                        	  3519: 
01:A271 11E410          	  3520: FPTHL:	LD		DE,FPREG		; Point to FPREG
01:A274 0604            	  3521: DETHL4: LD		B,4				; 4 bytes to move
01:A276 1A              	  3522: DETHLB: LD		A,(DE)			; Get source
01:A277 77              	  3523: 		LD		(HL),A			; Save destination
01:A278 13              	  3524: 		INC		DE				; Next source
01:A279 23              	  3525: 		INC		HL				; Next destination
01:A27A 05              	  3526: 		DEC		B				; Count bytes
01:A27B C276A2          	  3527: 		JP		NZ,DETHLB		; Loop if more
01:A27E C9              	  3528: 		RET
                        	  3529: 
01:A27F 21E610          	  3530: SIGNS:	LD		HL,FPREG+2		; Point to MSB of FPREG
01:A282 7E              	  3531: 		LD		A,(HL)			; Get MSB
01:A283 07              	  3532: 		RLCA					; Old sign to carry
01:A284 37              	  3533: 		SCF						; Set MSBit
01:A285 1F              	  3534: 		RRA						; Set MSBit of MSB
01:A286 77              	  3535: 		LD		(HL),A			; Save new MSB
01:A287 3F              	  3536: 		CCF						; Complement sign
01:A288 1F              	  3537: 		RRA						; Old sign to carry
01:A289 23              	  3538: 		INC		HL
01:A28A 23              	  3539: 		INC		HL
01:A28B 77              	  3540: 		LD		(HL),A			; Set sign of result
01:A28C 79              	  3541: 		LD		A,C				; Get MSB
01:A28D 07              	  3542: 		RLCA					; Old sign to carry
01:A28E 37              	  3543: 		SCF						; Set MSBit
01:A28F 1F              	  3544: 		RRA						; Set MSBit of MSB
01:A290 4F              	  3545: 		LD		C,A				; Save MSB
01:A291 1F              	  3546: 		RRA
01:A292 AE              	  3547: 		XOR		(HL)			; New sign of result
01:A293 C9              	  3548: 		RET
                        	  3549: 
01:A294 78              	  3550: CMPNUM: LD		A,B				; Get exponent of number
01:A295 B7              	  3551: 		OR		A
01:A296 CA19A2          	  3552: 		JP		Z,TSTSGN		; Zero - Test sign of FPREG
01:A299 2122A2          	  3553: 		LD		HL,RETREL		; Return relation routine
01:A29C E5              	  3554: 		PUSH	HL				; Save for return
01:A29D CD19A2          	  3555: 		CALL	TSTSGN			; Test sign of FPREG
01:A2A0 79              	  3556: 		LD		A,C				; Get MSB of number
01:A2A1 C8              	  3557: 		RET		Z				; FPREG zero - Number's MSB
01:A2A2 21E610          	  3558: 		LD		HL,FPREG+2		; MSB of FPREG
01:A2A5 AE              	  3559: 		XOR		(HL)			; Combine signs
01:A2A6 79              	  3560: 		LD		A,C				; Get MSB of number
01:A2A7 F8              	  3561: 		RET		M				; Exit if signs different
01:A2A8 CDAEA2          	  3562: 		CALL	CMPFP			; Compare FP numbers
01:A2AB 1F              	  3563: 		RRA						; Get carry to sign
01:A2AC A9              	  3564: 		XOR		C				; Combine with MSB of number
01:A2AD C9              	  3565: 		RET
                        	  3566: 
01:A2AE 23              	  3567: CMPFP:	INC		HL				; Point to exponent
01:A2AF 78              	  3568: 		LD		A,B				; Get exponent
01:A2B0 BE              	  3569: 		CP		(HL)			; Compare exponents
01:A2B1 C0              	  3570: 		RET		NZ				; Different
01:A2B2 2B              	  3571: 		DEC		HL				; Point to MBS
01:A2B3 79              	  3572: 		LD		A,C				; Get MSB
01:A2B4 BE              	  3573: 		CP		(HL)			; Compare MSBs
01:A2B5 C0              	  3574: 		RET		NZ				; Different
01:A2B6 2B              	  3575: 		DEC		HL				; Point to NMSB
01:A2B7 7A              	  3576: 		LD		A,D				; Get NMSB
01:A2B8 BE              	  3577: 		CP		(HL)			; Compare NMSBs
01:A2B9 C0              	  3578: 		RET		NZ				; Different
01:A2BA 2B              	  3579: 		DEC		HL				; Point to LSB
01:A2BB 7B              	  3580: 		LD		A,E				; Get LSB
01:A2BC 96              	  3581: 		SUB		(HL)			; Compare LSBs
01:A2BD C0              	  3582: 		RET		NZ				; Different
01:A2BE E1              	  3583: 		POP		HL				; Drop RETurn
01:A2BF E1              	  3584: 		POP		HL				; Drop another RETurn
01:A2C0 C9              	  3585: 		RET
                        	  3586: 
01:A2C1 47              	  3587: FPINT:	LD		B,A				; <- Move
01:A2C2 4F              	  3588: 		LD		C,A				; <- exponent
01:A2C3 57              	  3589: 		LD		D,A				; <- to all
01:A2C4 5F              	  3590: 		LD		E,A				; <- bits
01:A2C5 B7              	  3591: 		OR		A				; Test exponent
01:A2C6 C8              	  3592: 		RET		Z				; Zero - Return zero
01:A2C7 E5              	  3593: 		PUSH	HL				; Save pointer to number
01:A2C8 CD65A2          	  3594: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A2CB CD7FA2          	  3595: 		CALL	SIGNS			; Set MSBs & sign of result
01:A2CE AE              	  3596: 		XOR		(HL)			; Combine with sign of FPREG
01:A2CF 67              	  3597: 		LD		H,A				; Save combined signs
01:A2D0 FCE5A2          	  3598: 		CALL	M,DCBCDE		; Negative - Decrement BCDE
01:A2D3 3E98            	  3599: 		LD		A,80H+24		; 24 bits
01:A2D5 90              	  3600: 		SUB		B				; Bits to shift
01:A2D6 CD98A0          	  3601: 		CALL	SCALE			; Shift BCDE
01:A2D9 7C              	  3602: 		LD		A,H				; Get combined sign
01:A2DA 17              	  3603: 		RLA						; Sign to carry
01:A2DB DC6BA0          	  3604: 		CALL	C,FPROND		; Negative - Round number up
01:A2DE 0600            	  3605: 		LD		B,0				; Zero exponent
01:A2E0 DC84A0          	  3606: 		CALL	C,COMPL			; If negative make positive
01:A2E3 E1              	  3607: 		POP		HL				; Restore pointer to number
01:A2E4 C9              	  3608: 		RET
                        	  3609: 
01:A2E5 1B              	  3610: DCBCDE: DEC		DE				; Decrement BCDE
01:A2E6 7A              	  3611: 		LD		A,D				; Test LSBs
01:A2E7 A3              	  3612: 		AND		E
01:A2E8 3C              	  3613: 		INC		A
01:A2E9 C0              	  3614: 		RET		NZ				; Exit if LSBs not FFFF
01:A2EA 0B              	  3615: 		DEC		BC				; Decrement MSBs
01:A2EB C9              	  3616: 		RET
                        	  3617: 
01:A2EC 21E710          	  3618: INT:	LD		HL,FPEXP		; Point to exponent
01:A2EF 7E              	  3619: 		LD		A,(HL)			; Get exponent
01:A2F0 FE98            	  3620: 		CP		80H+24			; Integer accuracy only?
01:A2F2 3AE410          	  3621: 		LD		A,(FPREG)		; Get LSB
01:A2F5 D0              	  3622: 		RET		NC				; Yes - Already integer
01:A2F6 7E              	  3623: 		LD		A,(HL)			; Get exponent
01:A2F7 CDC1A2          	  3624: 		CALL	FPINT			; F.P to integer
01:A2FA 3698            	  3625: 		LD		(HL),80H+24		; Save 24 bit integer
01:A2FC 7B              	  3626: 		LD		A,E				; Get LSB of number
01:A2FD F5              	  3627: 		PUSH	AF				; Save LSB
01:A2FE 79              	  3628: 		LD		A,C				; Get MSB of number
01:A2FF 17              	  3629: 		RLA						; Sign to carry
01:A300 CD21A0          	  3630: 		CALL	CONPOS			; Set sign of result
01:A303 F1              	  3631: 		POP		AF				; Restore LSB of number
01:A304 C9              	  3632: 		RET
                        	  3633: 
01:A305 210000          	  3634: MLDEBC: LD		HL,0			; Clear partial product
01:A308 78              	  3635: 		LD		A,B				; Test multiplier
01:A309 B1              	  3636: 		OR		C
01:A30A C8              	  3637: 		RET		Z				; Return zero if zero
01:A30B 3E10            	  3638: 		LD		A,16			; 16 bits
01:A30D 29              	  3639: MLDBLP: ADD		HL,HL			; Shift P.P left
01:A30E DA459B          	  3640: 		JP		C,BSERR			; ?BS Error if overflow
01:A311 EB              	  3641: 		EX		DE,HL
01:A312 29              	  3642: 		ADD		HL,HL			; Shift multiplier left
01:A313 EB              	  3643: 		EX		DE,HL
01:A314 D21BA3          	  3644: 		JP		NC,NOMLAD		; Bit was zero - No add
01:A317 09              	  3645: 		ADD		HL,BC			; Add multiplicand
01:A318 DA459B          	  3646: 		JP		C,BSERR			; ?BS Error if overflow
01:A31B 3D              	  3647: NOMLAD: DEC		A				; Count bits
01:A31C C20DA3          	  3648: 		JP		NZ,MLDBLP		; More
01:A31F C9              	  3649: 		RET
                        	  3650: 
01:A320 FE2D            	  3651: ASCTFP: CP		'-'				; Negative?
01:A322 F5              	  3652: 		PUSH	AF				; Save it and flags
01:A323 CA2CA3          	  3653: 		JP		Z,CNVNUM		; Yes - Convert number
01:A326 FE2B            	  3654: 		CP		'+'				; Positive?
01:A328 CA2CA3          	  3655: 		JP		Z,CNVNUM		; Yes - Convert number
01:A32B 2B              	  3656: 		DEC		HL				; DEC 'cos GETCHR INCs
01:A32C CD39A0          	  3657: CNVNUM: CALL	RESZER			; Set result to zero
01:A32F 47              	  3658: 		LD		B,A				; Digits after point counter
01:A330 57              	  3659: 		LD		D,A				; Sign of exponent
01:A331 5F              	  3660: 		LD		E,A				; Exponent of ten
01:A332 2F              	  3661: 		CPL
01:A333 4F              	  3662: 		LD		C,A				; Before or after point flag
01:A334 CDCE93          	  3663: MANLP:	CALL	GETCHR			; Get next character
01:A337 DA7DA3          	  3664: 		JP		C,ADDIG			; Digit - Add to number
01:A33A FE2E            	  3665: 		CP		'.'
01:A33C CA58A3          	  3666: 		JP		Z,DPOINT		; '.' - Flag point
01:A33F FE45            	  3667: 		CP		'E'
01:A341 C25CA3          	  3668: 		JP		NZ,CONEXP		; Not 'E' - Scale number
01:A344 CDCE93          	  3669: 		CALL	GETCHR			; Get next character
01:A347 CD7099          	  3670: 		CALL	SGNEXP			; Get sign of exponent
01:A34A CDCE93          	  3671: EXPLP:	CALL	GETCHR			; Get next character
01:A34D DA9FA3          	  3672: 		JP		C,EDIGIT		; Digit - Add to exponent
01:A350 14              	  3673: 		INC		D				; Is sign negative?
01:A351 C25CA3          	  3674: 		JP		NZ,CONEXP		; No - Scale number
01:A354 AF              	  3675: 		XOR		A
01:A355 93              	  3676: 		SUB		E				; Negate exponent
01:A356 5F              	  3677: 		LD		E,A				; And re-save it
01:A357 0C              	  3678: 		INC		C				; Flag end of number
01:A358 0C              	  3679: DPOINT: INC		C				; Flag point passed
01:A359 CA34A3          	  3680: 		JP		Z,MANLP			; Zero - Get another digit
01:A35C E5              	  3681: CONEXP: PUSH	HL				; Save code string address
01:A35D 7B              	  3682: 		LD		A,E				; Get exponent
01:A35E 90              	  3683: 		SUB		B				; Subtract digits after point
01:A35F F475A3          	  3684: SCALMI: CALL	P,SCALPL		; Positive - Multiply number
01:A362 F26BA3          	  3685: 		JP		P,ENDCON		; Positive - All done
01:A365 F5              	  3686: 		PUSH	AF				; Save number of times to /10
01:A366 CD61A1          	  3687: 		CALL	DIV10			; Divide by 10
01:A369 F1              	  3688: 		POP		AF				; Restore count
01:A36A 3C              	  3689: 		INC		A				; Count divides
                        	  3690: 
01:A36B C25FA3          	  3691: ENDCON: JP		NZ,SCALMI		; More to do
01:A36E D1              	  3692: 		POP		DE				; Restore code string address
01:A36F F1              	  3693: 		POP		AF				; Restore sign of number
01:A370 CC42A2          	  3694: 		CALL	Z,INVSGN		; Negative - Negate number
01:A373 EB              	  3695: 		EX		DE,HL			; Code string address to HL
01:A374 C9              	  3696: 		RET
                        	  3697: 
01:A375 C8              	  3698: SCALPL: RET		Z				; Exit if no scaling needed
01:A376 F5              	  3699: MULTEN: PUSH	AF				; Save count
01:A377 CD02A2          	  3700: 		CALL	MLSP10			; Multiply number by 10
01:A37A F1              	  3701: 		POP		AF				; Restore count
01:A37B 3D              	  3702: 		DEC		A				; Count multiplies
01:A37C C9              	  3703: 		RET
                        	  3704: 
01:A37D D5              	  3705: ADDIG:	PUSH	DE				; Save sign of exponent
01:A37E 57              	  3706: 		LD		D,A				; Save digit
01:A37F 78              	  3707: 		LD		A,B				; Get digits after point
01:A380 89              	  3708: 		ADC		A,C				; Add one if after point
01:A381 47              	  3709: 		LD		B,A				; Re-save counter
01:A382 C5              	  3710: 		PUSH	BC				; Save point flags
01:A383 E5              	  3711: 		PUSH	HL				; Save code string address
01:A384 D5              	  3712: 		PUSH	DE				; Save digit
01:A385 CD02A2          	  3713: 		CALL	MLSP10			; Multiply number by 10
01:A388 F1              	  3714: 		POP		AF				; Restore digit
01:A389 D630            	  3715: 		SUB		'0'				; Make it absolute
01:A38B CD94A3          	  3716: 		CALL	RSCALE			; Re-scale number
01:A38E E1              	  3717: 		POP		HL				; Restore code string address
01:A38F C1              	  3718: 		POP		BC				; Restore point flags
01:A390 D1              	  3719: 		POP		DE				; Restore sign of exponent
01:A391 C334A3          	  3720: 		JP		MANLP			; Get another digit
                        	  3721: 
01:A394 CD4AA2          	  3722: RSCALE: CALL	STAKFP			; Put number on stack
01:A397 CD2BA2          	  3723: 		CALL	FLGREL			; Digit to add to FPREG
01:A39A C1              	  3724: PADD:	POP		BC				; Restore number
01:A39B D1              	  3725: 		POP		DE
01:A39C C3D39F          	  3726: 		JP		FPADD			; Add BCDE to FPREG and return
                        	  3727: 
01:A39F 7B              	  3728: EDIGIT: LD		A,E				; Get digit
01:A3A0 07              	  3729: 		RLCA					; Times 2
01:A3A1 07              	  3730: 		RLCA					; Times 4
01:A3A2 83              	  3731: 		ADD		A,E				; Times 5
01:A3A3 07              	  3732: 		RLCA					; Times 10
01:A3A4 86              	  3733: 		ADD		A,(HL)			; Add next digit
01:A3A5 D630            	  3734: 		SUB		'0'				; Make it absolute
01:A3A7 5F              	  3735: 		LD		E,A				; Save new digit
01:A3A8 C34AA3          	  3736: 		JP		EXPLP			; Look for another digit
                        	  3737: 
01:A3AB E5              	  3738: LINEIN: PUSH	HL				; Save code string address
01:A3AC 210E8F          	  3739: 		LD		HL,INMSG		; Output " in "
01:A3AF CD109D          	  3740: 		CALL	PRS				; Output string at HL
01:A3B2 E1              	  3741: 		POP		HL				; Restore code string address
01:A3B3 EB              	  3742: PRNTHL: EX		DE,HL			; Code string address to DE
01:A3B4 AF              	  3743: 		XOR		A
01:A3B5 0698            	  3744: 		LD		B,80H+24		; 24 bits
01:A3B7 CD30A2          	  3745: 		CALL	RETINT			; Return the integer
01:A3BA 210F9D          	  3746: 		LD		HL,PRNUMS		; Print number string
01:A3BD E5              	  3747: 		PUSH	HL				; Save for return
01:A3BE 21E910          	  3748: NUMASC: LD		HL,PBUFF		; Convert number to ASCII
01:A3C1 E5              	  3749: 		PUSH	HL				; Save for return
01:A3C2 CD19A2          	  3750: 		CALL	TSTSGN			; Test sign of FPREG
01:A3C5 3620            	  3751: 		LD		(HL),' '		; Space at start
01:A3C7 F2CCA3          	  3752: 		JP		P,SPCFST		; Positive - Space to start
01:A3CA 362D            	  3753: 		LD		(HL),'-'		; '-' sign at start
01:A3CC 23              	  3754: SPCFST: INC		HL				; First byte of number
01:A3CD 3630            	  3755: 		LD		(HL),'0'		; '0' if zero
01:A3CF CA82A4          	  3756: 		JP		Z,JSTZER		; Return '0' if zero
01:A3D2 E5              	  3757: 		PUSH	HL				; Save buffer address
01:A3D3 FC42A2          	  3758: 		CALL	M,INVSGN		; Negate FPREG if negative
01:A3D6 AF              	  3759: 		XOR		A				; Zero A
01:A3D7 F5              	  3760: 		PUSH	AF				; Save it
01:A3D8 CD88A4          	  3761: 		CALL	RNGTST			; Test number is in range
01:A3DB 014391          	  3762: SIXDIG: LD		BC,9143H		; BCDE - 99999.9
01:A3DE 11F84F          	  3763: 		LD		DE,4FF8H
01:A3E1 CD94A2          	  3764: 		CALL	CMPNUM			; Compare numbers
01:A3E4 B7              	  3765: 		OR		A
01:A3E5 E2F9A3          	  3766: 		JP		PO,INRNG		; > 99999.9 - Sort it out
01:A3E8 F1              	  3767: 		POP		AF				; Restore count
01:A3E9 CD76A3          	  3768: 		CALL	MULTEN			; Multiply by ten
01:A3EC F5              	  3769: 		PUSH	AF				; Re-save count
01:A3ED C3DBA3          	  3770: 		JP		SIXDIG			; Test it again
                        	  3771: 
01:A3F0 CD61A1          	  3772: GTSIXD: CALL	DIV10			; Divide by 10
01:A3F3 F1              	  3773: 		POP		AF				; Get count
01:A3F4 3C              	  3774: 		INC		A				; Count divides
01:A3F5 F5              	  3775: 		PUSH	AF				; Re-save count
01:A3F6 CD88A4          	  3776: 		CALL	RNGTST			; Test number is in range
01:A3F9 CDC19F          	  3777: INRNG:	CALL	ROUND			; Add 0.5 to FPREG
01:A3FC 3C              	  3778: 		INC		A
01:A3FD CDC1A2          	  3779: 		CALL	FPINT			; F.P to integer
01:A400 CD5AA2          	  3780: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A403 010603          	  3781: 		LD		BC,0306H		; 1E+06 to 1E-03 range
01:A406 F1              	  3782: 		POP		AF				; Restore count
01:A407 81              	  3783: 		ADD		A,C				; 6 digits before point
01:A408 3C              	  3784: 		INC		A				; Add one
01:A409 FA15A4          	  3785: 		JP		M,MAKNUM		; Do it in 'E' form if < 1E-02
01:A40C FE08            	  3786: 		CP		6+1+1			; More than 999999 ?
01:A40E D215A4          	  3787: 		JP		NC,MAKNUM		; Yes - Do it in 'E' form
01:A411 3C              	  3788: 		INC		A				; Adjust for exponent
01:A412 47              	  3789: 		LD		B,A				; Exponent of number
01:A413 3E02            	  3790: 		LD		A,2				; Make it zero after
                        	  3791: 
01:A415 3D              	  3792: MAKNUM: DEC		A				; Adjust for digits to do
01:A416 3D              	  3793: 		DEC		A
01:A417 E1              	  3794: 		POP		HL				; Restore buffer address
01:A418 F5              	  3795: 		PUSH	AF				; Save count
01:A419 119BA4          	  3796: 		LD		DE,POWERS		; Powers of ten
01:A41C 05              	  3797: 		DEC		B				; Count digits before point
01:A41D C226A4          	  3798: 		JP		NZ,DIGTXT		; Not zero - Do number
01:A420 362E            	  3799: 		LD		(HL),'.'		; Save point
01:A422 23              	  3800: 		INC		HL				; Move on
01:A423 3630            	  3801: 		LD		(HL),'0'		; Save zero
01:A425 23              	  3802: 		INC		HL				; Move on
01:A426 05              	  3803: DIGTXT: DEC		B				; Count digits before point
01:A427 362E            	  3804: 		LD		(HL),'.'		; Save point in case
01:A429 CC6FA2          	  3805: 		CALL	Z,INCHL			; Last digit - move on
01:A42C C5              	  3806: 		PUSH	BC				; Save digits before point
01:A42D E5              	  3807: 		PUSH	HL				; Save buffer address
01:A42E D5              	  3808: 		PUSH	DE				; Save powers of ten
01:A42F CD65A2          	  3809: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A432 E1              	  3810: 		POP		HL				; Powers of ten table
01:A433 062F            	  3811: 		LD		B, '0'-1		; ASCII '0' - 1
01:A435 04              	  3812: TRYAGN: INC		B				; Count subtractions
01:A436 7B              	  3813: 		LD		A,E				; Get LSB
01:A437 96              	  3814: 		SUB		(HL)			; Subtract LSB
01:A438 5F              	  3815: 		LD		E,A				; Save LSB
01:A439 23              	  3816: 		INC		HL
01:A43A 7A              	  3817: 		LD		A,D				; Get NMSB
01:A43B 9E              	  3818: 		SBC		A,(HL)			; Subtract NMSB
01:A43C 57              	  3819: 		LD		D,A				; Save NMSB
01:A43D 23              	  3820: 		INC		HL
01:A43E 79              	  3821: 		LD		A,C				; Get MSB
01:A43F 9E              	  3822: 		SBC		A,(HL)			; Subtract MSB
01:A440 4F              	  3823: 		LD		C,A				; Save MSB
01:A441 2B              	  3824: 		DEC		HL				; Point back to start
01:A442 2B              	  3825: 		DEC		HL
01:A443 D235A4          	  3826: 		JP		NC,TRYAGN		; No overflow - Try again
01:A446 CD78A0          	  3827: 		CALL	PLUCDE			; Restore number
01:A449 23              	  3828: 		INC		HL				; Start of next number
01:A44A CD5AA2          	  3829: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A44D EB              	  3830: 		EX		DE,HL			; Save point in table
01:A44E E1              	  3831: 		POP		HL				; Restore buffer address
01:A44F 70              	  3832: 		LD		(HL),B			; Save digit in buffer
01:A450 23              	  3833: 		INC		HL				; And move on
01:A451 C1              	  3834: 		POP		BC				; Restore digit count
01:A452 0D              	  3835: 		DEC		C				; Count digits
01:A453 C226A4          	  3836: 		JP		NZ,DIGTXT		; More - Do them
01:A456 05              	  3837: 		DEC		B				; Any decimal part?
01:A457 CA66A4          	  3838: 		JP		Z,DOEBIT		; No - Do 'E' bit
01:A45A 2B              	  3839: SUPTLZ: DEC		HL				; Move back through buffer
01:A45B 7E              	  3840: 		LD		A,(HL)			; Get character
01:A45C FE30            	  3841: 		CP		'0'				; '0' character?
01:A45E CA5AA4          	  3842: 		JP		Z,SUPTLZ		; Yes - Look back for more
01:A461 FE2E            	  3843: 		CP		'.'				; A decimal point?
01:A463 C46FA2          	  3844: 		CALL	NZ,INCHL		; Move back over digit
                        	  3845: 
01:A466 F1              	  3846: DOEBIT: POP		AF				; Get 'E' flag
01:A467 CA85A4          	  3847: 		JP		Z,NOENED		; No 'E' needed - End buffer
01:A46A 3645            	  3848: 		LD		(HL),'E'		; Put 'E' in buffer
01:A46C 23              	  3849: 		INC		HL				; And move on
01:A46D 362B            	  3850: 		LD		(HL),'+'		; Put '+' in buffer
01:A46F F276A4          	  3851: 		JP		P,OUTEXP		; Positive - Output exponent
01:A472 362D            	  3852: 		LD		(HL),'-'		; Put '-' in buffer
01:A474 2F              	  3853: 		CPL						; Negate exponent
01:A475 3C              	  3854: 		INC		A
01:A476 062F            	  3855: OUTEXP: LD		B,'0'-1			; ASCII '0' - 1
01:A478 04              	  3856: EXPTEN: INC		B				; Count subtractions
01:A479 D60A            	  3857: 		SUB		10				; Tens digit
01:A47B D278A4          	  3858: 		JP		NC,EXPTEN		; More to do
01:A47E C63A            	  3859: 		ADD		A,'0'+10		; Restore and make ASCII
01:A480 23              	  3860: 		INC		HL				; Move on
01:A481 70              	  3861: 		LD		(HL),B			; Save MSB of exponent
01:A482 23              	  3862: JSTZER: INC		HL				;
01:A483 77              	  3863: 		LD		(HL),A			; Save LSB of exponent
01:A484 23              	  3864: 		INC		HL
01:A485 71              	  3865: NOENED: LD		(HL),C			; Mark end of buffer
01:A486 E1              	  3866: 		POP		HL				; Restore code string address
01:A487 C9              	  3867: 		RET
                        	  3868: 
01:A488 017494          	  3869: RNGTST: LD		BC,9474H		; BCDE = 999999.
01:A48B 11F723          	  3870: 		LD		DE,23F7H
01:A48E CD94A2          	  3871: 		CALL	CMPNUM			; Compare numbers
01:A491 B7              	  3872: 		OR		A
01:A492 E1              	  3873: 		POP		HL				; Return address to HL
01:A493 E2F0A3          	  3874: 		JP		PO,GTSIXD		; Too big - Divide by ten
01:A496 E9              	  3875: 		JP		(HL)			; Otherwise return to caller
                        	  3876: 
01:A497 00              	  3877: HALF:	db	   00H,00H,00H,80H ; 0.5
01:A498 00
01:A499 00
01:A49A 80
                        	  3878: 
01:A49B A0              	  3879: POWERS: db	   0A0H,086H,001H  ; 100000
01:A49C 86
01:A49D 01
01:A49E 10              	  3880: 		db	   010H,027H,000H  ;  10000
01:A49F 27
01:A4A0 00
01:A4A1 E8              	  3881: 		db	   0E8H,003H,000H  ;   1000
01:A4A2 03
01:A4A3 00
01:A4A4 64              	  3882: 		db	   064H,000H,000H  ;	100
01:A4A5 00
01:A4A6 00
01:A4A7 0A              	  3883: 		db	   00AH,000H,000H  ;	 10
01:A4A8 00
01:A4A9 00
01:A4AA 01              	  3884: 		db	   001H,000H,000H  ;	  1
01:A4AB 00
01:A4AC 00
                        	  3885: 
01:A4AD 2142A2          	  3886: NEGAFT: LD	HL,INVSGN			; Negate result
01:A4B0 E3              	  3887: 		EX		(SP),HL			; To be done after caller
01:A4B1 E9              	  3888: 		JP		(HL)			; Return to caller
                        	  3889: 
01:A4B2 CD4AA2          	  3890: SQR:	CALL	STAKFP			; Put value on stack
01:A4B5 2197A4          	  3891: 		LD		HL,HALF			; Set power to 1/2
01:A4B8 CD57A2          	  3892: 		CALL	PHLTFP			; Move 1/2 to FPREG
                        	  3893: 
01:A4BB C1              	  3894: POWER:	POP		BC				; Get base
01:A4BC D1              	  3895: 		POP		DE
01:A4BD CD19A2          	  3896: 		CALL	TSTSGN			; Test sign of power
01:A4C0 78              	  3897: 		LD		A,B				; Get exponent of base
01:A4C1 CA00A5          	  3898: 		JP		Z,EXPP			; Make result 1 if zero
01:A4C4 F2CBA4          	  3899: 		JP		P,POWER1		; Positive base - Ok
01:A4C7 B7              	  3900: 		OR		A				; Zero to negative power?
01:A4C8 CA798F          	  3901: 		JP		Z,DZERR			; Yes - ?/0 Error
01:A4CB B7              	  3902: POWER1: OR		A				; Base zero?
01:A4CC CA3AA0          	  3903: 		JP		Z,SAVEXP		; Yes - Return zero
01:A4CF D5              	  3904: 		PUSH	DE				; Save base
01:A4D0 C5              	  3905: 		PUSH	BC
01:A4D1 79              	  3906: 		LD		A,C				; Get MSB of base
01:A4D2 F67F            	  3907: 		OR		01111111B		; Get sign status
01:A4D4 CD65A2          	  3908: 		CALL	BCDEFP			; Move power to BCDE
01:A4D7 F2E8A4          	  3909: 		JP		P,POWER2		; Positive base - Ok
01:A4DA D5              	  3910: 		PUSH	DE				; Save power
01:A4DB C5              	  3911: 		PUSH	BC
01:A4DC CDECA2          	  3912: 		CALL	INT				; Get integer of power
01:A4DF C1              	  3913: 		POP		BC				; Restore power
01:A4E0 D1              	  3914: 		POP		DE
01:A4E1 F5              	  3915: 		PUSH	AF				; MSB of base
01:A4E2 CD94A2          	  3916: 		CALL	CMPNUM			; Power an integer?
01:A4E5 E1              	  3917: 		POP		HL				; Restore MSB of base
01:A4E6 7C              	  3918: 		LD		A,H				; but don't affect flags
01:A4E7 1F              	  3919: 		RRA						; Exponent odd or even?
01:A4E8 E1              	  3920: POWER2: POP		HL				; Restore MSB and exponent
01:A4E9 22E610          	  3921: 		LD		(FPREG+2),HL	; Save base in FPREG
01:A4EC E1              	  3922: 		POP		HL				; LSBs of base
01:A4ED 22E410          	  3923: 		LD		(FPREG),HL		; Save in FPREG
01:A4F0 DCADA4          	  3924: 		CALL	C,NEGAFT		; Odd power - Negate result
01:A4F3 CC42A2          	  3925: 		CALL	Z,INVSGN		; Negative base - Negate it
01:A4F6 D5              	  3926: 		PUSH	DE				; Save power
01:A4F7 C5              	  3927: 		PUSH	BC
01:A4F8 CDCDA0          	  3928: 		CALL	LOG				; Get LOG of base
01:A4FB C1              	  3929: 		POP		BC				; Restore power
01:A4FC D1              	  3930: 		POP		DE
01:A4FD CD0EA1          	  3931: 		CALL	FPMULT			; Multiply LOG by power
                        	  3932: 
01:A500 CD4AA2          	  3933: EXPP:	CALL	STAKFP			; Put value on stack
01:A503 013881          	  3934: 		LD		BC,08138H		; BCDE = 1/Ln(2)
01:A506 113BAA          	  3935: 		LD		DE,0AA3BH
01:A509 CD0EA1          	  3936: 		CALL	FPMULT			; Multiply value by 1/LN(2)
01:A50C 3AE710          	  3937: 		LD		A,(FPEXP)		; Get exponent
01:A50F FE88            	  3938: 		CP		80H+8			; Is it in range?
01:A511 D2F5A1          	  3939: 		JP		NC,OVTST1		; No - Test for overflow
01:A514 CDECA2          	  3940: 		CALL	INT				; Get INT of FPREG
01:A517 C680            	  3941: 		ADD		A,80H			; For excess 128
01:A519 C602            	  3942: 		ADD		A,2				; Exponent > 126?
01:A51B DAF5A1          	  3943: 		JP		C,OVTST1		; Yes - Test for overflow
01:A51E F5              	  3944: 		PUSH	AF				; Save scaling factor
01:A51F 21BCA0          	  3945: 		LD		HL,UNITY		; Point to 1.
01:A522 CDC49F          	  3946: 		CALL	ADDPHL			; Add 1 to FPREG
01:A525 CD05A1          	  3947: 		CALL	MULLN2			; Multiply by LN(2)
01:A528 F1              	  3948: 		POP		AF				; Restore scaling factor
01:A529 C1              	  3949: 		POP		BC				; Restore exponent
01:A52A D1              	  3950: 		POP		DE
01:A52B F5              	  3951: 		PUSH	AF				; Save scaling factor
01:A52C CDD09F          	  3952: 		CALL	SUBCDE			; Subtract exponent from FPREG
01:A52F CD42A2          	  3953: 		CALL	INVSGN			; Negate result
01:A532 2140A5          	  3954: 		LD		HL,EXPTAB		; Coefficient table
01:A535 CD70A5          	  3955: 		CALL	SMSER1			; Sum the series
01:A538 110000          	  3956: 		LD		DE,0			; Zero LSBs
01:A53B C1              	  3957: 		POP		BC				; Scaling factor
01:A53C 4A              	  3958: 		LD		C,D				; Zero MSB
01:A53D C30EA1          	  3959: 		JP		FPMULT			; Scale result to correct value
                        	  3960: 
01:A540 08              	  3961: EXPTAB: db	   8					; Table used by EXP
01:A541 40              	  3962: 		db	   040H,02EH,094H,074H	; -1/7! (-1/5040)
01:A542 2E
01:A543 94
01:A544 74
01:A545 70              	  3963: 		db	   070H,04FH,02EH,077H	;  1/6! ( 1/720)
01:A546 4F
01:A547 2E
01:A548 77
01:A549 6E              	  3964: 		db	   06EH,002H,088H,07AH	; -1/5! (-1/120)
01:A54A 02
01:A54B 88
01:A54C 7A
01:A54D E6              	  3965: 		db	   0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
01:A54E A0
01:A54F 2A
01:A550 7C
01:A551 50              	  3966: 		db	   050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
01:A552 AA
01:A553 AA
01:A554 7E
01:A555 FF              	  3967: 		db	   0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
01:A556 FF
01:A557 7F
01:A558 7F
01:A559 00              	  3968: 		db	   000H,000H,080H,081H	; -1/1! (-1/1)
01:A55A 00
01:A55B 80
01:A55C 81
01:A55D 00              	  3969: 		db	   000H,000H,000H,081H	;  1/0! ( 1/1)
01:A55E 00
01:A55F 00
01:A560 81
                        	  3970: 
01:A561 CD4AA2          	  3971: SUMSER: CALL	STAKFP			; Put FPREG on stack
01:A564 110CA1          	  3972: 		LD		DE,MULTT			; Multiply by "X"
01:A567 D5              	  3973: 		PUSH	DE				; To be done after
01:A568 E5              	  3974: 		PUSH	HL				; Save address of table
01:A569 CD65A2          	  3975: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A56C CD0EA1          	  3976: 		CALL	FPMULT			; Square the value
01:A56F E1              	  3977: 		POP		HL				; Restore address of table
01:A570 CD4AA2          	  3978: SMSER1: CALL	STAKFP			; Put value on stack
01:A573 7E              	  3979: 		LD		A,(HL)			; Get number of coefficients
01:A574 23              	  3980: 		INC		HL				; Point to start of table
01:A575 CD57A2          	  3981: 		CALL	PHLTFP			; Move coefficient to FPREG
01:A578 06              	  3982: 		db	   06H			   ; Skip "POP AF"
01:A579 F1              	  3983: SUMLP:	POP		AF				; Restore count
01:A57A C1              	  3984: 		POP		BC				; Restore number
01:A57B D1              	  3985: 		POP		DE
01:A57C 3D              	  3986: 		DEC		A				; Cont coefficients
01:A57D C8              	  3987: 		RET		Z				; All done
01:A57E D5              	  3988: 		PUSH	DE				; Save number
01:A57F C5              	  3989: 		PUSH	BC
01:A580 F5              	  3990: 		PUSH	AF				; Save count
01:A581 E5              	  3991: 		PUSH	HL				; Save address in table
01:A582 CD0EA1          	  3992: 		CALL	FPMULT			; Multiply FPREG by BCDE
01:A585 E1              	  3993: 		POP		HL				; Restore address in table
01:A586 CD68A2          	  3994: 		CALL	LOADFP			; Number at HL to BCDE
01:A589 E5              	  3995: 		PUSH	HL				; Save address in table
01:A58A CDD39F          	  3996: 		CALL	FPADD			; Add coefficient to FPREG
01:A58D E1              	  3997: 		POP		HL				; Restore address in table
01:A58E C379A5          	  3998: 		JP		SUMLP			; More coefficients
                        	  3999: 
01:A591 CD19A2          	  4000: RND:	CALL	TSTSGN			; Test sign of FPREG
01:A594 211910          	  4001: 		LD		HL,SEED+2		; Random number seed
01:A597 FAF2A5          	  4002: 		JP		M,RESEED		; Negative - Re-seed
01:A59A 213A10          	  4003: 		LD		HL,LSTRND		; Last random number
01:A59D CD57A2          	  4004: 		CALL	PHLTFP			; Move last RND to FPREG
01:A5A0 211910          	  4005: 		LD		HL,SEED+2		; Random number seed
01:A5A3 C8              	  4006: 		RET		Z				; Return if RND(0)
01:A5A4 86              	  4007: 		ADD		A,(HL)			; Add (SEED)+2)
01:A5A5 E607            	  4008: 		AND		00000111B		; 0 to 7
01:A5A7 0600            	  4009: 		LD		B,0
01:A5A9 77              	  4010: 		LD		(HL),A			; Re-save seed
01:A5AA 23              	  4011: 		INC		HL				; Move to coefficient table
01:A5AB 87              	  4012: 		ADD		A,A				; 4 bytes
01:A5AC 87              	  4013: 		ADD		A,A				; per entry
01:A5AD 4F              	  4014: 		LD		C,A				; BC = Offset into table
01:A5AE 09              	  4015: 		ADD		HL,BC			; Point to coefficient
01:A5AF CD68A2          	  4016: 		CALL	LOADFP			; Coefficient to BCDE
01:A5B2 CD0EA1          	  4017: 		CALL	FPMULT	;		; Multiply FPREG by coefficient
01:A5B5 3A1810          	  4018: 		LD		A,(SEED+1)		; Get (SEED+1)
01:A5B8 3C              	  4019: 		INC		A				; Add 1
01:A5B9 E603            	  4020: 		AND		00000011B		; 0 to 3
01:A5BB 0600            	  4021: 		LD		B,0
01:A5BD FE01            	  4022: 		CP		1				; Is it zero?
01:A5BF 88              	  4023: 		ADC		A,B				; Yes - Make it 1
01:A5C0 321810          	  4024: 		LD		(SEED+1),A		; Re-save seed
01:A5C3 21F6A5          	  4025: 		LD		HL,RNDTAB-4		; Addition table
01:A5C6 87              	  4026: 		ADD		A,A				; 4 bytes
01:A5C7 87              	  4027: 		ADD		A,A				; per entry
01:A5C8 4F              	  4028: 		LD		C,A				; BC = Offset into table
01:A5C9 09              	  4029: 		ADD		HL,BC			; Point to value
01:A5CA CDC49F          	  4030: 		CALL	ADDPHL			; Add value to FPREG
01:A5CD CD65A2          	  4031: RND1:	CALL	BCDEFP			; Move FPREG to BCDE
01:A5D0 7B              	  4032: 		LD		A,E				; Get LSB
01:A5D1 59              	  4033: 		LD		E,C				; LSB = MSB
01:A5D2 EE4F            	  4034: 		XOR		01001111B		; Fiddle around
01:A5D4 4F              	  4035: 		LD		C,A				; New MSB
01:A5D5 3680            	  4036: 		LD		(HL),80H		; Set exponent
01:A5D7 2B              	  4037: 		DEC		HL				; Point to MSB
01:A5D8 46              	  4038: 		LD		B,(HL)			; Get MSB
01:A5D9 3680            	  4039: 		LD		(HL),80H		; Make value -0.5
01:A5DB 211710          	  4040: 		LD		HL,SEED			; Random number seed
01:A5DE 34              	  4041: 		INC		(HL)			; Count seed
01:A5DF 7E              	  4042: 		LD		A,(HL)			; Get seed
01:A5E0 D6AB            	  4043: 		SUB		171				; Do it modulo 171
01:A5E2 C2E9A5          	  4044: 		JP		NZ,RND2			; Non-zero - Ok
01:A5E5 77              	  4045: 		LD		(HL),A			; Zero seed
01:A5E6 0C              	  4046: 		INC		C				; Fillde about
01:A5E7 15              	  4047: 		DEC		D				; with the
01:A5E8 1C              	  4048: 		INC		E				; number
01:A5E9 CD24A0          	  4049: RND2:	CALL	BNORM			; Normalise number
01:A5EC 213A10          	  4050: 		LD		HL,LSTRND		; Save random number
01:A5EF C371A2          	  4051: 		JP		FPTHL			; Move FPREG to last and return
                        	  4052: 
01:A5F2 77              	  4053: RESEED: LD		(HL),A			; Re-seed random numbers
01:A5F3 2B              	  4054: 		DEC		HL
01:A5F4 77              	  4055: 		LD		(HL),A
01:A5F5 2B              	  4056: 		DEC		HL
01:A5F6 77              	  4057: 		LD		(HL),A
01:A5F7 C3CDA5          	  4058: 		JP		RND1			; Return RND seed
                        	  4059: 
01:A5FA 68              	  4060: RNDTAB: db		068H,0B1H,046H,068H	; Table used by RND
01:A5FB B1
01:A5FC 46
01:A5FD 68
01:A5FE 99              	  4061: 		db		099H,0E9H,092H,069H
01:A5FF E9
01:A600 92
01:A601 69
01:A602 10              	  4062: 		db		010H,0D1H,075H,068H
01:A603 D1
01:A604 75
01:A605 68
                        	  4063: 
01:A606 2150A6          	  4064: COS:	LD		HL,HALFPI		; Point to PI/2
01:A609 CDC49F          	  4065: 		CALL	ADDPHL			; Add it to PPREG
01:A60C CD4AA2          	  4066: SIN:	CALL	STAKFP			; Put angle on stack
01:A60F 014983          	  4067: 		LD		BC,8349H		; BCDE = 2 PI
01:A612 11DB0F          	  4068: 		LD		DE,0FDBH
01:A615 CD5AA2          	  4069: 		CALL	FPBCDE			; Move 2 PI to FPREG
01:A618 C1              	  4070: 		POP		BC				; Restore angle
01:A619 D1              	  4071: 		POP		DE
01:A61A CD6FA1          	  4072: 		CALL	DVBCDE			; Divide angle by 2 PI
01:A61D CD4AA2          	  4073: 		CALL	STAKFP			; Put it on stack
01:A620 CDECA2          	  4074: 		CALL	INT				; Get INT of result
01:A623 C1              	  4075: 		POP		BC				; Restore number
01:A624 D1              	  4076: 		POP		DE
01:A625 CDD09F          	  4077: 		CALL	SUBCDE			; Make it 0 <= value < 1
01:A628 2154A6          	  4078: 		LD		HL,QUARTR		; Point to 0.25
01:A62B CDCA9F          	  4079: 		CALL	SUBPHL			; Subtract value from 0.25
01:A62E CD19A2          	  4080: 		CALL	TSTSGN			; Test sign of value
01:A631 37              	  4081: 		SCF						; Flag positive
01:A632 F23CA6          	  4082: 		JP		P,SIN1			; Positive - Ok
01:A635 CDC19F          	  4083: 		CALL	ROUND			; Add 0.5 to value
01:A638 CD19A2          	  4084: 		CALL	TSTSGN			; Test sign of value
01:A63B B7              	  4085: 		OR		A				; Flag negative
01:A63C F5              	  4086: SIN1:	PUSH	AF				; Save sign
01:A63D F442A2          	  4087: 		CALL	P,INVSGN		; Negate value if positive
01:A640 2154A6          	  4088: 		LD		HL,QUARTR		; Point to 0.25
01:A643 CDC49F          	  4089: 		CALL	ADDPHL			; Add 0.25 to value
01:A646 F1              	  4090: 		POP		AF				; Restore sign
01:A647 D442A2          	  4091: 		CALL	NC,INVSGN		; Negative - Make positive
01:A64A 2158A6          	  4092: 		LD		HL,SINTAB		; Coefficient table
01:A64D C361A5          	  4093: 		JP		SUMSER			; Evaluate sum of series
                        	  4094: 
01:A650 DB              	  4095: HALFPI: db		0DBH,00FH,049H,081H	; 1.5708 (PI/2)
01:A651 0F
01:A652 49
01:A653 81
                        	  4096: 
01:A654 00              	  4097: QUARTR: db		000H,000H,000H,07FH	; 0.25
01:A655 00
01:A656 00
01:A657 7F
                        	  4098: 
01:A658 05              	  4099: SINTAB: db		5					; Table used by SIN
01:A659 BA              	  4100: 		db		0BAH,0D7H,01EH,086H	; 39.711
01:A65A D7
01:A65B 1E
01:A65C 86
01:A65D 64              	  4101: 		db		064H,026H,099H,087H	;-76.575
01:A65E 26
01:A65F 99
01:A660 87
01:A661 58              	  4102: 		db		058H,034H,023H,087H	; 81.602
01:A662 34
01:A663 23
01:A664 87
01:A665 E0              	  4103: 		db		0E0H,05DH,0A5H,086H	;-41.342
01:A666 5D
01:A667 A5
01:A668 86
01:A669 DA              	  4104: 		db		0DAH,00FH,049H,083H	;  6.2832
01:A66A 0F
01:A66B 49
01:A66C 83
                        	  4105: 
01:A66D CD4AA2          	  4106: TAN:	CALL	STAKFP			; Put angle on stack
01:A670 CD0CA6          	  4107: 		CALL	SIN				; Get SIN of angle
01:A673 C1              	  4108: 		POP		BC				; Restore angle
01:A674 E1              	  4109: 		POP		HL
01:A675 CD4AA2          	  4110: 		CALL	STAKFP			; Save SIN of angle
01:A678 EB              	  4111: 		EX		DE,HL			; BCDE = Angle
01:A679 CD5AA2          	  4112: 		CALL	FPBCDE			; Angle to FPREG
01:A67C CD06A6          	  4113: 		CALL	COS				; Get COS of angle
01:A67F C36DA1          	  4114: 		JP		DIV				; TAN = SIN / COS
                        	  4115: 
01:A682 CD19A2          	  4116: ATN:	CALL	TSTSGN			; Test sign of value
01:A685 FCADA4          	  4117: 		CALL	M,NEGAFT		; Negate result after if -ve
01:A688 FC42A2          	  4118: 		CALL	M,INVSGN		; Negate value if -ve
01:A68B 3AE710          	  4119: 		LD		A,(FPEXP)		; Get exponent
01:A68E FE81            	  4120: 		CP		81H				; Number less than 1?
01:A690 DA9FA6          	  4121: 		JP		C,ATN1			; Yes - Get arc tangnt
01:A693 010081          	  4122: 		LD		BC,8100H		; BCDE = 1
01:A696 51              	  4123: 		LD		D,C
01:A697 59              	  4124: 		LD		E,C
01:A698 CD6FA1          	  4125: 		CALL	DVBCDE			; Get reciprocal of number
01:A69B 21CA9F          	  4126: 		LD		HL,SUBPHL		; Sub angle from PI/2
01:A69E E5              	  4127: 		PUSH	HL				; Save for angle > 1
01:A69F 21A9A6          	  4128: ATN1:	LD		HL,ATNTAB		; Coefficient table
01:A6A2 CD61A5          	  4129: 		CALL	SUMSER			; Evaluate sum of series
01:A6A5 2150A6          	  4130: 		LD		HL,HALFPI		; PI/2 - angle in case > 1
01:A6A8 C9              	  4131: 		RET						; Number > 1 - Sub from PI/2
                        	  4132: 
01:A6A9 09              	  4133: ATNTAB: db		9					; Table used by ATN
01:A6AA 4A              	  4134: 		db		04AH,0D7H,03BH,078H	;  1/17
01:A6AB D7
01:A6AC 3B
01:A6AD 78
01:A6AE 02              	  4135: 		db		002H,06EH,084H,07BH	; -1/15
01:A6AF 6E
01:A6B0 84
01:A6B1 7B
01:A6B2 FE              	  4136: 		db		0FEH,0C1H,02FH,07CH	;  1/13
01:A6B3 C1
01:A6B4 2F
01:A6B5 7C
01:A6B6 74              	  4137: 		db		074H,031H,09AH,07DH	; -1/11
01:A6B7 31
01:A6B8 9A
01:A6B9 7D
01:A6BA 84              	  4138: 		db		084H,03DH,05AH,07DH	;  1/9
01:A6BB 3D
01:A6BC 5A
01:A6BD 7D
01:A6BE C8              	  4139: 		db		0C8H,07FH,091H,07EH	; -1/7
01:A6BF 7F
01:A6C0 91
01:A6C1 7E
01:A6C2 E4              	  4140: 		db		0E4H,0BBH,04CH,07EH	;  1/5
01:A6C3 BB
01:A6C4 4C
01:A6C5 7E
01:A6C6 6C              	  4141: 		db		06CH,0AAH,0AAH,07FH	; -1/3
01:A6C7 AA
01:A6C8 AA
01:A6C9 7F
01:A6CA 00              	  4142: 		db		000H,000H,000H,081H	;  1/1
01:A6CB 00
01:A6CC 00
01:A6CD 81
                        	  4143: 
                        	  4144: ARET:
01:A6CE C9              	  4145: 	ret								; A RETurn instruction
                        	  4146: 
                        	  4147: GETINP:
01:A6CF CDC780          	  4148: 	call	ReadChar				;input a character
01:A6D2 C9              	  4149: 	ret
                        	  4150: 
                        	  4151: CLS:
01:A6D3 C3AA82          	  4152: 	jp		ClearScreen
                        	  4153: 
                        	  4154: WIDTH:
01:A6D6 CD989F          	  4155: 	call	GETINT					; Get integer 0-255
01:A6D9 7B              	  4156: 	ld		A,E						; Width to A
01:A6DA 324210          	  4157: 	ld		(LWIDTH),A				; Set width
01:A6DD C9              	  4158: 	ret			
                        	  4159: 			
                        	  4160: LINES:			
01:A6DE CD3798          	  4161: 	call	GETNUM					; Get a number
01:A6E1 CD8394          	  4162: 	call	DEINT					; Get integer -32768 to 32767
01:A6E4 ED534610        	  4163: 	ld		(LINESC),DE				; Set lines counter
01:A6E8 ED534810        	  4164: 	ld		(LINESN),DE				; Set lines number
01:A6EC C9              	  4165: 	ret			
                        	  4166: 			
                        	  4167: DEEK:			
01:A6ED CD8394          	  4168: 	call	DEINT					; Get integer -32768 to 32767
01:A6F0 D5              	  4169: 	push	DE						; Save number
01:A6F1 E1              	  4170: 	pop		HL						; Number to HL
01:A6F2 46              	  4171: 	ld		B,(HL)					; Get LSB of contents
01:A6F3 23              	  4172: 	inc		HL			
01:A6F4 7E              	  4173: 	ld		A,(HL)					; Get MSB of contents
01:A6F5 C3F29B          	  4174: 	jp		ABPASS					; Return integer AB
                        	  4175: 			
                        	  4176: DOKE:			
01:A6F8 CD3798          	  4177: 	call	GETNUM					; Get a number
01:A6FB CD8394          	  4178: 	call	DEINT					; Get integer -32768 to 32767
01:A6FE D5              	  4179: 	push	DE						; Save address
01:A6FF CD4492          	  4180: 	call	CHKSYN					; Make sure ',' follows
01:A702 2C              	  4181: 	db	   ','			
01:A703 CD3798          	  4182: 	call	GETNUM					; Get a number
01:A706 CD8394          	  4183: 	call	DEINT					; Get integer -32768 to 32767
01:A709 E3              	  4184: 	ex		(SP),HL					; Save value,get address
01:A70A 73              	  4185: 	ld		(HL),E					; Save LSB of value
01:A70B 23              	  4186: 	inc		HL			
01:A70C 72              	  4187: 	ld		(HL),D					; Save MSB of value
01:A70D E1              	  4188: 	pop		HL						; Restore code string address
01:A70E C9              	  4189: 	ret
                        	  4190: 
                        	  4191: 
                        	  4192: ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        	  4193: 
                        	  4194: HEX:
01:A70F CD3A98          	  4195: 	call	TSTNUM					; Verify it's a number
01:A712 CD8394          	  4196: 	call	DEINT					; Get integer -32768 to 32767
01:A715 C5              	  4197: 	push	BC						; Save contents of BC
01:A716 21E910          	  4198: 	ld		HL,PBUFF			
01:A719 7A              	  4199: 	ld		A,D						; Get high order into A
01:A71A FE00            	  4200: 	cp		$0			
01:A71C 280C            	  4201: 	jr		z,HEX2					; Skip output if both high digits are zero
01:A71E CD47A7          	  4202: 	call	BYT2ASC					; Convert D to ASCII
01:A721 78              	  4203: 	ld		A,B			
01:A722 FE30            	  4204: 	cp		'0'			
01:A724 2802            	  4205: 	jr		z,HEX1					; Don't store high digit if zero
01:A726 70              	  4206: 	ld		(HL),B					; Store it to PBUFF
01:A727 23              	  4207: 	inc		HL						; Next location
                        	  4208: HEX1:			
01:A728 71              	  4209: 	ld		(HL),C					; Store C to PBUFF+1
01:A729 23              	  4210: 	inc		HL						; Next location
                        	  4211: HEX2:			
01:A72A 7B              	  4212: 	ld		A,E						; Get lower byte
01:A72B CD47A7          	  4213: 	call	BYT2ASC					; Convert E to ASCII
01:A72E 7A              	  4214: 	ld		A,D			
01:A72F FE00            	  4215: 	cp		$0			
01:A731 2005            	  4216: 	jr		nz,HEX3					; If upper byte was not zero then always print lower byte
01:A733 78              	  4217: 	ld		A,B			
01:A734 FE30            	  4218: 	cp		'0'						; If high digit of lower byte is zero then don't print
01:A736 2802            	  4219: 	jr		z,HEX4			
                        	  4220: HEX3:			
01:A738 70              	  4221: 	ld		(HL),B					; to PBUFF+2
01:A739 23              	  4222: 	inc		HL						; Next location
                        	  4223: HEX4:			
01:A73A 71              	  4224: 	ld		(HL),C					; to PBUFF+3
01:A73B 23              	  4225: 	inc		HL						; PBUFF+4 to zero
01:A73C AF              	  4226: 	xor		A						; Terminating character
01:A73D 77              	  4227: 	ld		(HL),A					; Store zero to terminate
01:A73E 23              	  4228: 	inc		HL						; Make sure PBUFF is terminated
01:A73F 77              	  4229: 	ld		(HL),A					; Store the double zero there
01:A740 C1              	  4230: 	pop		BC						; Get BC back
01:A741 21E910          	  4231: 	ld		HL,PBUFF				; Reset to start of PBUFF
01:A744 C3A09C          	  4232: 	jp		STR1					; Convert the PBUFF to a string and return it
                        	  4233: 			
                        	  4234: BYT2ASC:			
01:A747 47              	  4235: 	ld		B,A						; Save original value
01:A748 E60F            	  4236: 	and		$0F						; Strip off upper nybble
01:A74A FE0A            	  4237: 	cp		$0A						; 0-9?
01:A74C 3802            	  4238: 	jr		c,ADD30					; If A-F, add 7 more
01:A74E C607            	  4239: 	add		A,$07					; Bring value up to ASCII A-F
                        	  4240: ADD30:			
01:A750 C630            	  4241: 	add		A,$30					; And make ASCII
01:A752 4F              	  4242: 	ld		C,A						; Save converted char to C
01:A753 78              	  4243: 	ld		A,B						; Retrieve original value
01:A754 CB0F            	  4244: 	rrc		A							; and Rotate it right
01:A756 CB0F            	  4245: 	rrc		A			
01:A758 CB0F            	  4246: 	rrc		A			
01:A75A CB0F            	  4247: 	rrc		A			
01:A75C E60F            	  4248: 	and		$0F						; Mask off upper nybble
01:A75E FE0A            	  4249: 	cp		$0A						; 0-9? < A hex?
01:A760 3802            	  4250: 	jr		c,ADD301				; Skip Add 7
01:A762 C607            	  4251: 	add		A,$07					; Bring it up to ASCII A-F
                        	  4252: ADD301:			
01:A764 C630            	  4253: 	add		A,$30					; And make it full ASCII
01:A766 47              	  4254: 	ld		B,A						; Store high order byte
01:A767 C9              	  4255: 	ret	
                        	  4256: 
                        	  4257: ; Convert "&Hnnnn" to FPREG
                        	  4258: ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        	  4259: ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
                        	  4260: HEXTFP:
01:A768 EB              	  4261: 	ex		DE,HL					; Move code string pointer to DE
01:A769 210000          	  4262: 	ld		HL,$0000				; Zero out the value
01:A76C CD81A7          	  4263: 	call	GETHEX					; Check the number for valid hex
01:A76F DAA1A7          	  4264: 	jp		c,HXERR					; First value wasn't hex, HX error
01:A772 1805            	  4265: 	jr		HEXLP1					; Convert first character
                        	  4266: HEXLP:			
01:A774 CD81A7          	  4267: 	call	GETHEX					; Get second and addtional characters
01:A777 381F            	  4268: 	jr		c,HEXIT					; Exit if not a hex character
                        	  4269: HEXLP1:			
01:A779 29              	  4270: 	add		HL,HL					; Rotate 4 bits to the left
01:A77A 29              	  4271: 	add		HL,HL			
01:A77B 29              	  4272: 	add		HL,HL			
01:A77C 29              	  4273: 	add		HL,HL			
01:A77D B5              	  4274: 	or		L						; Add in D0-D3 into L
01:A77E 6F              	  4275: 	ld		L,A						; Save new value
01:A77F 18F3            	  4276: 	jr		HEXLP					; And continue until all hex characters are in
                        	  4277: 			
                        	  4278: GETHEX:			
01:A781 13              	  4279: 	inc		DE						; Next location
01:A782 1A              	  4280: 	ld		A,(DE)					; Load character at pointer
01:A783 FE20            	  4281: 	cp		' '			
01:A785 CA81A7          	  4282: 	jp		z,GETHEX				; Skip spaces
01:A788 D630            	  4283: 	sub		$30						; Get absolute value
01:A78A D8              	  4284: 	ret		c						; < "0", error
01:A78B FE0A            	  4285: 	cp		$0A			
01:A78D 3805            	  4286: 	jr		c,NOSUB7				; Is already in the range 0-9
01:A78F D607            	  4287: 	sub		$07						; Reduce to A-F
01:A791 FE0A            	  4288: 	cp		$0A						; Value should be $0A-$0F at this point
01:A793 D8              	  4289: 	ret		c						; CY set if was :			 ; < = > ? @
                        	  4290: NOSUB7:			
01:A794 FE10            	  4291: 	cp		$10						; > Greater than "F"?
01:A796 3F              	  4292: 	ccf			
01:A797 C9              	  4293: 	ret								; CY set if it wasn't valid hex
                        	  4294: 				
                        	  4295: HEXIT:			
01:A798 EB              	  4296: 	ex		DE,HL					; Value into DE, Code string into HL
01:A799 7A              	  4297: 	ld		A,D						; Load DE into AC
01:A79A 4B              	  4298: 	ld		C,E						; For prep to 
01:A79B E5              	  4299: 	push	HL			
01:A79C CDF19B          	  4300: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A79F E1              	  4301: 	pop		HL
01:A7A0 C9              	  4302: 	ret
                        	  4303: 
                        	  4304: HXERR:
01:A7A1 1E26            	  4305: 	ld		E,HX					; ?HEX Error
01:A7A3 C38A8F          	  4306: 	jp		ERROR
                        	  4307: 
                        	  4308: ; BIN$(NN) Convert integer to a 1-16 char binary string
                        	  4309: BIN:
01:A7A6 CD3A98          	  4310: 	call	TSTNUM					; Verify it's a number
01:A7A9 CD8394          	  4311: 	call	DEINT					; Get integer -32768 to 32767
                        	  4312: BIN2:			
01:A7AC C5              	  4313: 	push	BC						; Save contents of BC
01:A7AD 21E910          	  4314: 	ld		HL,PBUFF			
01:A7B0 0611            	  4315: 	ld		B,17					; One higher than max char count
                        	  4316: ZEROSUP:								; Suppress leading zeros
01:A7B2 05              	  4317: 	dec		B						; Max 16 chars
01:A7B3 78              	  4318: 	ld		A,B			
01:A7B4 FE01            	  4319: 	cp		$01			
01:A7B6 2808            	  4320: 	jr		z,BITOUT				; Always output at least one character
01:A7B8 CB13            	  4321: 	rl		E			
01:A7BA CB12            	  4322: 	rl		D			
01:A7BC 30F4            	  4323: 	jr		NC,ZEROSUP			
01:A7BE 1804            	  4324: 	jr		BITOUT2			
                        	  4325: BITOUT:		 			
01:A7C0 CB13            	  4326: 	rl		E			
01:A7C2 CB12            	  4327: 	rl		D						; Top bit now in carry
                        	  4328: BITOUT2:			
01:A7C4 3E30            	  4329: 	ld		A,'0'					; Char for '0'
01:A7C6 CE00            	  4330: 	adc		A,0						; If carry set then '0' --> '1'
01:A7C8 77              	  4331: 	ld		(HL),A			
01:A7C9 23              	  4332: 	inc		HL			
01:A7CA 05              	  4333: 	dec		B			
01:A7CB 20F3            	  4334: 	jr		NZ,BITOUT			
01:A7CD AF              	  4335: 	xor		A						; Terminating character
01:A7CE 77              	  4336: 	ld		(HL),A					; Store zero to terminate
01:A7CF 23              	  4337: 	inc		HL						; Make sure PBUFF is terminated
01:A7D0 77              	  4338: 	ld		(HL),A					; Store the double zero there
01:A7D1 C1              	  4339: 	pop		BC
01:A7D2 21E910          	  4340: 	ld		HL,PBUFF
01:A7D5 C3A09C          	  4341: 	jp		STR1
                        	  4342: 
                        	  4343: ; Convert "&Bnnnn" to FPREG
                        	  4344: ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
                        	  4345: BINTFP: 
01:A7D8 EB              	  4346: 	ex		DE,HL					; Move code string pointer to DE
01:A7D9 210000          	  4347: 	ld		HL,$0000				; Zero out the value
01:A7DC CDF5A7          	  4348: 	call	CHKBIN					; Check the number for valid bin
01:A7DF DA03A8          	  4349: 	jp		c,BINERR				; First value wasn't bin, HX error
                        	  4350: BINIT:
01:A7E2 D630            	  4351: 	sub		'0'
01:A7E4 29              	  4352: 	add		HL,HL					; Rotate HL left
01:A7E5 B5              	  4353: 	or		L
01:A7E6 6F              	  4354: 	ld		L,A
01:A7E7 CDF5A7          	  4355: 	call	CHKBIN					; Get second and addtional characters
01:A7EA 30F6            	  4356: 	jr		NC,BINIT				; Process if a bin character
01:A7EC EB              	  4357: 	ex		DE,HL					; Value into DE, Code string into HL
01:A7ED 7A              	  4358: 	ld		A,D						; Load DE into AC
01:A7EE 4B              	  4359: 	ld		C,E						; For prep to 
01:A7EF E5              	  4360: 	push	HL
01:A7F0 CDF19B          	  4361: 	call	ACPASS					; ACPASS to set AC as integer into FPREG
01:A7F3 E1              	  4362: 	pop		HL
01:A7F4 C9              	  4363: 	ret
                        	  4364: 
                        	  4365: ; Char is in A, NC if char is 0 or 1
                        	  4366: CHKBIN: 
01:A7F5 13              	  4367: 	inc		DE
01:A7F6 1A              	  4368: 	ld		A,(DE)
01:A7F7 FE20            	  4369: 	cp		' '
01:A7F9 CAF5A7          	  4370: 	jp		Z,CHKBIN				; Skip spaces
01:A7FC FE30            	  4371: 	cp		'0'						; Set C if < '0'
01:A7FE D8              	  4372: 	ret		c
01:A7FF FE32            	  4373: 	cp		'2'
01:A801 3F              	  4374: 	ccf								; Set C if > '1'
01:A802 C9              	  4375: 	ret
                        	  4376: 
                        	  4377: BINERR:
01:A803 1E28            	  4378: 	ld		E,BN					; ?BIN Error
01:A805 C38A8F          	  4379: 	jp		ERROR
                        	  4380: 
                        	  4381: JJUMP1: 
01:A808 DD21FFFF        	  4382: 	ld		IX,-1					; Flag cold start
01:A80C C3D58B          	  4383: 	jp		CSTART					; Go and initialise
                        	  4384: 
                        	  4385: MONOUT: 
01:A80F C37480          	  4386: 	jp		PrintChar				; Output a char
                        	  4387: 
                        	  4388: MONITR: 
01:A812 C30080          	  4389: 	jp		$8000					; Restart (Normally Monitor Start)
                        	  4390: 
                        	  4391: INITST:
01:A815 3E00            	  4392: 	ld		A,0						; Clear break flag
01:A817 324D10          	  4393: 	ld		(BRKFLG),A
01:A81A C3DC8B          	  4394: 	jp		INIT
                        	  4395: 
                        	  4396: ARETN:
01:A81D ED45            	  4397: 	retn							; Return from NMI
                        	  4398: 
                        	  4399: TSTBIT:
01:A81F F5              	  4400: 	push	AF						; Save bit mask
01:A820 A0              	  4401: 	and		B						; Get common bits
01:A821 C1              	  4402: 	pop		BC						; Restore bit mask
01:A822 B8              	  4403: 	cp		B						; Same bit set?
01:A823 3E00            	  4404: 	ld		A,0						; Return 0 in A
01:A825 C9              	  4405: 	ret
                        	  4406: 
                        	  4407: OUTNCR:
01:A826 CD4F92          	  4408: 	call	OUTC					; Output character in A
01:A829 C37F80          	  4409: 	jp		PrintCRLF				; Output CRLF
                        	  4410: 
                        	  4411: EXIT:
01:A82C C30080          	  4412: 	jp		$8000
                        	  4413: 

Source: "main.asm"
                        	   274: 	.include	"data.asm"			; Various data and text messages. Keep last in list of includes

Source: "data.asm"
                        	     1: ;  ____            _           
                        	     2: ; |  _ \    __ _  | |_    __ _ 
                        	     3: ; | | | |  / _` | | __|  / _` |
                        	     4: ; | |_| | | (_| | | |_  | (_| |
                        	     5: ; |____/   \__,_|  \__|  \__,_|
                        	     6: ;
                        	     7: ; ---------------------------------------------------------------------------------------------------------------------
                        	     8: 
                        	     9: BootMsg:
01:A82F 5A65644569676874	    10: 	db		"ZedEighty Project by Frederic Segard",CR,LF
01:A837 792050726F6A6563
01:A83F 7420627920467265
01:A847 6465726963205365
01:A84F 67617264
01:A853 0D
01:A854 0A
01:A855 7777772E796F7574	    11: 	db		"www.youtube.com/@microhobbyist",CR,LF
01:A85D 7562652E636F6D2F
01:A865 406D6963726F686F
01:A86D 626279697374
01:A873 0D
01:A874 0A
01:A875 7777772E67697468	    12: 	db		"www.github.com/FredericSegard",CR,LF,0
01:A87D 75622E636F6D2F46
01:A885 7265646572696353
01:A88D 6567617264
01:A892 0D
01:A893 0A
01:A894 00
01:A895 42494F5320302E37	    13: 	db		"BIOS 0.7  (c)2023  ",0," bytes free",CR,LF,LF,0
01:A89D 2020286329323032
01:A8A5 332020
01:A8A8 00
01:A8A9 2062797465732066
01:A8B1 726565
01:A8B4 0D
01:A8B5 0A
01:A8B6 0A
01:A8B7 00
                        	    14: 
                        	    15: CommandList:						; Commands must be in uppercase, and the jp opcode also acts as a delimiter
01:A8B8 41444452        	    16: 	db		"ADDR"					; Sets current address
01:A8BC C39B87          	    17: 	jp		SetAddress				;
01:A8BF 42414E4B        	    18: 	db		"BANK"					; Sets current bank
01:A8C3 C3BC87          	    19: 	jp		SetBank					;
01:A8C6 4241534943      	    20: 	db		"BASIC"					; Tiny Basic
01:A8CB C3458B          	    21: 	jp		BASIC					;
01:A8CE 434C53          	    22: 	db		"CLS"					; Clear screen command
01:A8D1 C3AA82          	    23: 	jp		ClearScreen				;
01:A8D4 434F5059        	    24: 	db		"COPY"					; Copy data from one place to another (destructive)
01:A8D8 C3B382          	    25: 	jp		CopyBlock				;
01:A8DB 44494147        	    26: 	db		"DIAG"					; Test RAM (and eventually other system components)
01:A8DF C31883          	    27: 	jp		Diagnostics				;
01:A8E2 46494C4C        	    28: 	db		"FILL"					; Fill a region of memory with a byte of data 
01:A8E6 C3E883          	    29: 	jp		FillMemory				;
                        	    30: ;	db		"FORTH"					; Camel Forth
                        	    31: ;	jp		FORTH					;
01:A8E9 44554D50        	    32: 	db		"DUMP"					; Hex dump command
01:A8ED C38784          	    33: 	jp		HexDump					;
01:A8F0 4C495354        	    34: 	db		"LIST"					; List of commands
01:A8F4 C3D385          	    35: 	jp		ListCmd					;
01:A8F7 4C4F4144        	    36: 	db		"LOAD"					; Intel Hex load command
01:A8FB C30385          	    37: 	jp		IntelHex				;
01:A8FE 5045454B        	    38: 	db		"PEEK"					; Read a byte of memory
01:A902 C3E285          	    39: 	jp		PeekCmd					;
01:A905 504F4B45        	    40: 	db		"POKE"					; Write a byte of memory (destructive)
01:A909 C31186          	    41: 	jp		PokeCmd					;
01:A90C 524547          	    42: 	db		"REG"					; Prints the content of the registers
01:A90F C34E86          	    43: 	jp		Registers				;
01:A912 52554E          	    44: 	db		"RUN"					; Execute a program in RAM
01:A915 C38887          	    45: 	jp		RunCode					;
01:A918 535953494E464F  	    46: 	db		"SYSINFO"				; Info command
01:A91F C3ED87          	    47: 	jp		SysInfo					;
01:A922 5752495445      	    48: 	db		"WRITE"					; Write up to 8 bytes of data
01:A927 C30A88          	    49: 	jp		Write					;
01:A92A 5A45524F        	    50: 	db		"ZERO"					; Zero all memory, including banks
01:A92E C35A88          	    51: 	jp		ZeroAllRam				;
01:A931 FF              	    52: 	db		EOT
                        	    53: 
                        	    54: ListOfCommands:
                        	    55: 	;		"                                        "
01:A932 0A              	    56: 	db		LF
01:A933 4D6F6E69746F7220	    57: 	db		"Monitor Commands",CR,LF,0
01:A93B 436F6D6D616E6473
01:A943 0D
01:A944 0A
01:A945 00
01:A946 2D2041444452205B	    58: 	db		"- ADDR [AAAA]: Sets current address",CR,LF
01:A94E 414141415D3A2053
01:A956 6574732063757272
01:A95E 656E742061646472
01:A966 657373
01:A969 0D
01:A96A 0A
01:A96B 2D2042414E4B205B	    59: 	db		"- BANK [N]: Sets current bank",CR,LF
01:A973 4E5D3A2053657473
01:A97B 2063757272656E74
01:A983 2062616E6B
01:A988 0D
01:A989 0A
01:A98A 2D2042415349433A	    60: 	db		"- BASIC: Nascom MS BASIC",CR,LF
01:A992 204E6173636F6D20
01:A99A 4D53204241534943
01:A9A2 0D
01:A9A3 0A
01:A9A4 2D20434C533A2043	    61: 	db		"- CLS: Clear screen",CR,LF
01:A9AC 6C65617220736372
01:A9B4 65656E
01:A9B7 0D
01:A9B8 0A
01:A9B9 2D20434F50592053	    62: 	db		"- COPY SSSS DDDD BBBB: Copy memory block"
01:A9C1 5353532044444444
01:A9C9 20424242423A2043
01:A9D1 6F7079206D656D6F
01:A9D9 727920626C6F636B
01:A9E1 2D20444941473A20	    63: 	db		"- DIAG: Diagnostics (RAM)",CR,LF
01:A9E9 446961676E6F7374
01:A9F1 696373202852414D
01:A9F9 29
01:A9FA 0D
01:A9FB 0A
01:A9FC 2D2044554D50205B	    64: 	db		"- DUMP [AAAA] [LL]: Memory hex dump",CR,LF
01:AA04 414141415D205B4C
01:AA0C 4C5D3A204D656D6F
01:AA14 7279206865782064
01:AA1C 756D70
01:AA1F 0D
01:AA20 0A
01:AA21 2D2046494C4C2053	    65: 	db		"- FILL SSSS EEEE BB: Fill memory",CR,LF
01:AA29 5353532045454545
01:AA31 2042423A2046696C
01:AA39 6C206D656D6F7279
01:AA41 0D
01:AA42 0A
                        	    66: ;	db		"- FORTH: Camel Forth, by Brad Rodriguez",CR,LF
01:AA43 2D204C4953543A20	    67: 	db		"- LIST: List of commands",CR,LF
01:AA4B 4C697374206F6620
01:AA53 636F6D6D616E6473
01:AA5B 0D
01:AA5C 0A
01:AA5D 2D204C4F41443A20	    68: 	db		"- LOAD: Intel Hex loader",CR,LF
01:AA65 496E74656C204865
01:AA6D 78206C6F61646572
01:AA75 0D
01:AA76 0A
01:AA77 2D205045454B3A20	    69: 	db		"- PEEK: Read a byte of memory",CR,LF
01:AA7F 5265616420612062
01:AA87 797465206F66206D
01:AA8F 656D6F7279
01:AA94 0D
01:AA95 0A
01:AA96 2D20504F4B453A20	    70: 	db		"- POKE: Write a byte in memory",CR,LF
01:AA9E 5772697465206120
01:AAA6 6279746520696E20
01:AAAE 6D656D6F7279
01:AAB4 0D
01:AAB5 0A
01:AAB6 2D205245473A205A	    71: 	db		"- REG: Z80 registers",CR,LF
01:AABE 3830207265676973
01:AAC6 74657273
01:AACA 0D
01:AACB 0A
01:AACC 2D2052554E205B41	    72: 	db		"- RUN [AAAA]: Esecute a program",CR,LF
01:AAD4 4141415D3A204573
01:AADC 6563757465206120
01:AAE4 70726F6772616D
01:AAEB 0D
01:AAEC 0A
01:AAED 2D20535953494E46	    73: 	db		"- SYSINFO: System information",CR,LF
01:AAF5 4F3A205379737465
01:AAFD 6D20696E666F726D
01:AB05 6174696F6E
01:AB0A 0D
01:AB0B 0A
01:AB0C 2D20575249544520	    74: 	db		"- WRITE AAAA BB [BB]...: Write x bytes",CR,LF
01:AB14 4141414120424220
01:AB1C 5B42425D2E2E2E3A
01:AB24 2057726974652078
01:AB2C 206279746573
01:AB32 0D
01:AB33 0A
01:AB34 2D205A45524F3A20	    75: 	db		"- ZERO: Zero free RAM, banks included",CR,LF
01:AB3C 5A65726F20667265
01:AB44 652052414D2C2062
01:AB4C 616E6B7320696E63
01:AB54 6C75646564
01:AB59 0D
01:AB5A 0A
01:AB5B 0A              	    76: 	db		LF
01:AB5C 202A205479706520	    77: 	db		" * Type ? in command parameter for help",CR,LF
01:AB64 3F20696E20636F6D
01:AB6C 6D616E6420706172
01:AB74 616D657465722066
01:AB7C 6F722068656C70
01:AB83 0D
01:AB84 0A
01:AB85 0A              	    78: 	db		LF,0
01:AB86 00
                        	    79: 
                        	    80: FlagBits:
01:AB87 737A68766E63    	    81: 	db		"szhvnc"				; Flag short hand. Use UpperCase to indicate set, else lowercase indicated clear
                        	    82: 	
                        	    83: ClearScreenSeq:
01:AB8D 1B              	    84: 	db		ESC, "[", "2", "J"		; Clears the screen
01:AB8E 5B
01:AB8F 32
01:AB90 4A
01:AB91 1B              	    85: 	db		ESC, "[", "0", "1", ";", "0", "1", "H", 0 ; Sets to home position
01:AB92 5B
01:AB93 30
01:AB94 31
01:AB95 3B
01:AB96 30
01:AB97 31
01:AB98 48
01:AB99 00
                        	    86: 	
                        	    87: SysInfoMsg:
                        	    88: 	;		"                                        "
01:AB9A 0A              	    89: 	db		LF
01:AB9B 5A65644569676874	    90: 	db		"ZedEighty System Information",CR,LF,0
01:ABA3 792053797374656D
01:ABAB 20496E666F726D61
01:ABB3 74696F6E
01:ABB7 0D
01:ABB8 0A
01:ABB9 00
01:ABBA 2D204350553A2020	    91: 	db		"- CPU:   Z84C00 Z80 @",0,"7.3728 MHz",CR,LF
01:ABC2 205A383443303020
01:ABCA 5A38302040
01:ABCF 00
01:ABD0 372E33373238204D
01:ABD8 487A
01:ABDA 0D
01:ABDB 0A
01:ABDC 2D20524F4D3A2020	    92: 	db		"- ROM:   64KB FLASH (Shadow ROM)",CR,LF
01:ABE4 2036344B4220464C
01:ABEC 4153482028536861
01:ABF4 646F7720524F4D29
01:ABFC 0D
01:ABFD 0A
01:ABFE 2D2052414D3A2020	    93: 	db		"- RAM:   64KB SRAM, ",0," bytes free",CR,LF
01:AC06 2036344B42205352
01:AC0E 414D2C20
01:AC12 00
01:AC13 2062797465732066
01:AC1B 726565
01:AC1E 0D
01:AC1F 0A
01:AC20 2D2042414E4B533A	    94: 	db		"- BANKS: 480KB (15x 32KB in low RAM)",CR,LF
01:AC28 203438304B422028
01:AC30 3135782033324B42
01:AC38 20696E206C6F7720
01:AC40 52414D29
01:AC44 0D
01:AC45 0A
01:AC46 2D20554152543A20	    95: 	db		"- UART:  Z84C40 SIO/0",CR,LF
01:AC4E 205A383443343020
01:AC56 53494F2F30
01:AC5B 0D
01:AC5C 0A
01:AC5D 0A              	    96: 	db		LF,0
01:AC5E 00
                        	    97: 
                        	    98: 
                        	    99: 
                        	   100: 
                        	   101: ;  __  __                                                 
                        	   102: ; |  \/  |   ___   ___   ___    __ _    __ _    ___   ___ 
                        	   103: ; | |\/| |  / _ \ / __| / __|  / _` |  / _` |  / _ \ / __|
                        	   104: ; | |  | | |  __/ \__ \ \__ \ | (_| | | (_| | |  __/ \__ \
                        	   105: ; |_|  |_|  \___| |___/ |___/  \__,_|  \__, |  \___| |___/
                        	   106: ;                                      |___/
                        	   107: ; ---------------------------------------------------------------------------------------------------------------------
                        	   108: ; SYSTEM MESSAGES, AND ERROR MESSAGES
                        	   109: 
                        	   110: 
01:AC5F 436F6D6D616E6420	   111: ParseInvalidErr:		db	"Command not found or invalid syntax",CR,LF,0
01:AC67 6E6F7420666F756E
01:AC6F 64206F7220696E76
01:AC77 616C69642073796E
01:AC7F 746178
01:AC82 0D
01:AC83 0A
01:AC84 00
01:AC85 496E76616C696420	   112: InvalidHexDigitErr:		db	"Invalid hexadecimal digit in parameter",CR,LF,0
01:AC8D 6865786164656369
01:AC95 6D616C2064696769
01:AC9D 7420696E20706172
01:ACA5 616D65746572
01:ACAB 0D
01:ACAC 0A
01:ACAD 00
01:ACAE 546F6F206D616E79	   113: TooManyDigitsErr:		db	"Too many number of digits in parameter",CR,LF,0
01:ACB6 206E756D62657220
01:ACBE 6F66206469676974
01:ACC6 7320696E20706172
01:ACCE 616D65746572
01:ACD4 0D
01:ACD5 0A
01:ACD6 00
01:ACD7 4D697373696E6720	   114: MissingParameterErr:	db	"Missing Parameter(s)",CR,LF,0
01:ACDF 506172616D657465
01:ACE7 72287329
01:ACEB 0D
01:ACEC 0A
01:ACED 00
01:ACEE 556E7265636F676E	   115: UnrecognizedParamErr:	db	"Unrecognized parameter",CR,LF,0
01:ACF6 697A656420706172
01:ACFE 616D65746572
01:AD04 0D
01:AD05 0A
01:AD06 00
01:AD07 5374617274206772	   116: StartGreaterEndErr:		db	"Start greater than end address",CR,LF,0
01:AD0F 6561746572207468
01:AD17 616E20656E642061
01:AD1F 646472657373
01:AD25 0D
01:AD26 0A
01:AD27 00
01:AD28 5265636F72642074	   117: IntelHexUnsupportedErr:	db	"Record type unsupported: ",0
01:AD30 79706520756E7375
01:AD38 70706F727465643A
01:AD40 20
01:AD41 00
01:AD42 5265736572766564	   118: InvalidVectorRangeErr:	db	"Reserved vector/stack area",CR,LF,0
01:AD4A 20766563746F722F
01:AD52 737461636B206172
01:AD5A 6561
01:AD5C 0D
01:AD5D 0A
01:AD5E 00
01:AD5F 5265736572766564	   119: ReservedBiosAreaErr:	db	"Reserved BIOS range",CR,LF,0
01:AD67 2042494F53207261
01:AD6F 6E6765
01:AD72 0D
01:AD73 0A
01:AD74 00
01:AD75 52616E6765206973	   120: RangeTooSmallErr:		db	"Range is null or too small",CR,LF,0
01:AD7D 206E756C6C206F72
01:AD85 20746F6F20736D61
01:AD8D 6C6C
01:AD8F 0D
01:AD90 0A
01:AD91 00
01:AD92 496E76616C696420	   121: InvalidBankNumberErr:	db	"Invalid bank number ($0-$E)",CR,LF,0
01:AD9A 62616E6B206E756D
01:ADA2 626572202824302D
01:ADAA 244529
01:ADAD 0D
01:ADAE 0A
01:ADAF 00
01:ADB0 496E76616C696420	   122: InvalidDecimalNumberErr	db	"Invalid decimal number",CR,LF,0
01:ADB8 646563696D616C20
01:ADC0 6E756D626572
01:ADC6 0D
01:ADC7 0A
01:ADC8 00
01:ADC9 4E756D6265722069	   123: NumberOutOfRangeErr		db	"Number is out of range",CR,LF,0
01:ADD1 73206F7574206F66
01:ADD9 2072616E6765
01:ADDF 0D
01:ADE0 0A
01:ADE1 00
01:ADE2 4572726F72206174	   124: BadMemory1Err:			db	"Error at ",0
01:ADEA 20
01:ADEB 00
01:ADEC 2C20676F7420    	   125: BadMemory2Err:			db	", got ",0,", expected ",0
01:ADF2 00
01:ADF3 2C20657870656374
01:ADFB 656420
01:ADFE 00
01:ADFF 4E6F7468696E6720	   126: NothingToCopyErr:		db	"Nothing to copy",CR,LF,0
01:AE07 746F20636F7079
01:AE0E 0D
01:AE0F 0A
01:AE10 00
                        	   127: 
01:AE11 54657374696E6720	   128: TestingBankNumberMsg:	db	"Testing Bank RAM #",0
01:AE19 42616E6B2052414D
01:AE21 2023
01:AE23 00
01:AE24 54657374696E6720	   129: TestingHighRamMsg:		db	"Testing High RAM",CR,LF,0
01:AE2C 486967682052414D
01:AE34 0D
01:AE35 0A
01:AE36 00
01:AE37 4D656D6F72792074	   130: MemoryTestPassedMsg:	db	"Memory test Passed",CR,LF,0
01:AE3F 6573742050617373
01:AE47 6564
01:AE49 0D
01:AE4A 0A
01:AE4B 00
01:AE4C 4164647265737320	   131: RangeMsg:				db	"Address range:",0
01:AE54 72616E67653A
01:AE5A 00
01:AE5B 46696C6520747261	   132: IntelHexFinishedMsg:	db	"File transfer: ",0
01:AE63 6E736665723A20
01:AE6A 00
01:AE6B 756E737563636573	   133: IntelHexSuccessMsg:		db	"unsuccessful",CR,LF,0
01:AE73 7366756C
01:AE77 0D
01:AE78 0A
01:AE79 00
01:AE7A 4C6F616420612070	   134: IntelHexLoadMsg:		db	"Load a program using Intel Hex format",CR,LF,"Press ESC to cancel",CR,LF,0
01:AE82 726F6772616D2075
01:AE8A 73696E6720496E74
01:AE92 656C204865782066
01:AE9A 6F726D6174
01:AE9F 0D
01:AEA0 0A
01:AEA1 5072657373204553
01:AEA9 4320746F2063616E
01:AEB1 63656C
01:AEB4 0D
01:AEB5 0A
01:AEB6 00
01:AEB7 5472616E73666572	   135: IntelHexAbortedMsg:		db	"Transfer aborted by user",CR,LF,0
01:AEBF 2061626F72746564
01:AEC7 2062792075736572
01:AECF 0D
01:AED0 0A
01:AED1 00
01:AED2 2062797465732074	   136: DownloadedBytesMsg:		db	" bytes transfered",CR,LF,0
01:AEDA 72616E7366657265
01:AEE2 64
01:AEE3 0D
01:AEE4 0A
01:AEE5 00
                        	   137: 
                        	   138: ;					"                                        "
01:AEE6 46696C6C73206120	   139: FillHelp:		db	"Fills a range of memory with a byte.",CR,LF
01:AEEE 72616E6765206F66
01:AEF6 206D656D6F727920
01:AEFE 7769746820612062
01:AF06 7974652E
01:AF0A 0D
01:AF0B 0A
01:AF0C 50726F7465637473	   140: 				db	"Protects the vector areas and the BIOS.",CR,LF
01:AF14 2074686520766563
01:AF1C 746F722061726561
01:AF24 7320616E64207468
01:AF2C 652042494F532E
01:AF33 0D
01:AF34 0A
01:AF35 55736167653A2046	   141: 				db	"Usage: Fill 2400 A400 8A",CR,LF,LF,0
01:AF3D 696C6C2032343030
01:AF45 2041343030203841
01:AF4D 0D
01:AF4E 0A
01:AF4F 0A
01:AF50 00
                        	   142: 
01:AF51 446973706C617973	   143: HexDumpHelp:	db	"Displays the content of memory. The",CR,LF
01:AF59 2074686520636F6E
01:AF61 74656E74206F6620
01:AF69 6D656D6F72792E20
01:AF71 546865
01:AF74 0D
01:AF75 0A
01:AF76 7365636F6E642070	   144: 				db	"second parameter is the number of lines.",CR,LF
01:AF7E 6172616D65746572
01:AF86 2069732074686520
01:AF8E 6E756D626572206F
01:AF96 66206C696E65732E
01:AF9E 0D
01:AF9F 0A
01:AFA0 55736167653A2044	   145: 				db	"Usage: DUMP 1000 4",CR,LF,LF,0
01:AFA8 554D502031303030
01:AFB0 2034
01:AFB2 0D
01:AFB3 0A
01:AFB4 0A
01:AFB5 00
                        	   146: 
01:AFB6 4C6F616420496E74	   147: IntelHexHelp:	db	"Load IntelHex binary programs via the",CR,LF
01:AFBE 656C486578206269
01:AFC6 6E6172792070726F
01:AFCE 6772616D73207669
01:AFD6 6120746865
01:AFDB 0D
01:AFDC 0A
01:AFDD 53494F20506F7274	   148: 				db	"SIO Port A.",CR,LF
01:AFE5 20412E
01:AFE8 0D
01:AFE9 0A
01:AFEA 55736167653A204C	   149: 				db	"Usage: LOAD",CR,LF,LF,0
01:AFF2 4F4144
01:AFF5 0D
01:AFF6 0A
01:AFF7 0A
01:AFF8 00
                        	   150: 
                        	   151: Range:
01:AFF9 E5              	   152: 	push	HL
01:AFFA 214CAE          	   153: 	ld		HL,RangeMsg
01:AFFD CDAE80          	   154: 	call	PrintString
01:B000 E1              	   155: 	pop		HL
01:B001 C9              	   156: 	ret
                        	   157: 
                        	   158: InvalidVectorRange:
01:B002 E5              	   159: 	push	HL
01:B003 2142AD          	   160: 	ld		HL,InvalidVectorRangeErr
01:B006 CDAE80          	   161: 	call	PrintString
01:B009 E1              	   162: 	pop		HL
01:B00A C9              	   163: 	ret
                        	   164: 
                        	   165: RangeTooSmall:
01:B00B E5              	   166: 	push	HL
01:B00C 2175AD          	   167: 	ld		HL,RangeTooSmallErr
01:B00F CDAE80          	   168: 	call	PrintString
01:B012 E1              	   169: 	pop		HL
01:B013 C9              	   170: 	ret
                        	   171: 
                        	   172: BiosRange:
01:B014 E5              	   173: 	push	HL
01:B015 215FAD          	   174: 	ld		HL,ReservedBiosAreaErr
01:B018 CDAE80          	   175: 	call	PrintString
01:B01B E1              	   176: 	pop		HL
01:B01C C9              	   177: 	ret
                        	   178: 
                        	   179: RangeInverted:
01:B01D E5              	   180: 	push	HL
01:B01E 2107AD          	   181: 	ld		HL,StartGreaterEndErr
01:B021 CDAE80          	   182: 	call	PrintString
01:B024 E1              	   183: 	pop		HL
01:B025 C9              	   184: 	ret
                        	   185: 
                        	   186: NoParameter:
01:B026 E5              	   187: 	push	HL
01:B027 CDBC89          	   188: 	call	PrintErrorPointer
01:B02A 21D7AC          	   189: 	ld		HL,MissingParameterErr
01:B02D CDAE80          	   190: 	call	PrintString
01:B030 E1              	   191: 	pop		HL
01:B031 C9              	   192: 	ret
                        	   193: 
                        	   194: InvalidBank:
01:B032 E5              	   195: 	push	HL
01:B033 2192AD          	   196: 	ld		HL,InvalidBankNumberErr
01:B036 CDAE80          	   197: 	call	PrintString
01:B039 E1              	   198: 	pop		HL
01:B03A C9              	   199: 	ret
                        	   200: 
                        	   201: TooManyDigits:
01:B03B E5              	   202: 	push	HL
01:B03C 21AEAC          	   203: 	ld		HL,TooManyDigitsErr
01:B03F CDAE80          	   204: 	call	PrintString
01:B042 E1              	   205: 	pop		HL
01:B043 C9              	   206: 	ret
                        	   207: 
                        	   208: InvalidHexDigit:
01:B044 E5              	   209: 	push	HL
01:B045 2185AC          	   210: 	ld		HL,InvalidHexDigitErr
01:B048 CDAE80          	   211: 	call	PrintString
01:B04B E1              	   212: 	pop		HL
01:B04C C9              	   213: 	ret
                        	   214: 
                        	   215: NumberOutOfRange:
01:B04D E5              	   216: 	push	HL
01:B04E 21C9AD          	   217: 	ld		HL,NumberOutOfRangeErr
01:B051 CDAE80          	   218: 	call	PrintString
01:B054 E1              	   219: 	pop		HL
01:B055 C9              	   220: 	ret
                        	   221: 
                        	   222: InvalidDecimalNumber:
01:B056 E5              	   223: 	push	HL
01:B057 21B0AD          	   224: 	ld		HL,InvalidDecimalNumberErr
01:B05A CDAE80          	   225: 	call	PrintString
01:B05D E1              	   226: 	pop		HL
01:B05E C9              	   227: 	ret
                        	   228: 
                        	   229: NothingToCopy:
01:B05F E5              	   230: 	push	HL
01:B060 CDBF88          	   231: 	call	DecErrorPointer
01:B063 CDBC89          	   232: 	call	PrintErrorPointer
01:B066 21FFAD          	   233: 	ld		HL,NothingToCopyErr
01:B069 CDAE80          	   234: 	call	PrintString
01:B06C E1              	   235: 	pop		HL
01:B06D C9              	   236: 	ret
                        	   237: 	

Source: "main.asm"
                        	   275: 
                        	   276: 
                        	   277: ; __     __                 _           _       _              
                        	   278: ; \ \   / /   __ _   _ __  (_)   __ _  | |__   | |   ___   ___ 
                        	   279: ;  \ \ / /   / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
                        	   280: ;   \ V /   | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
                        	   281: ;    \_/     \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
                        	   282: ;
                        	   283: ; ---------------------------------------------------------------------------------------------------------------------
                        	   284: ; VARIABLES ARE DECLARED IN BYTE SIZE
                        	   285: 
01:B06E 00              	   286: CommandBuffer:		ds	HorizTextRes-10	; Command prompt buffer
01:B06F *
01:B08C 00              	   287: BufferPointer:		ds	2			; Buffer pointer
01:B08D *
01:B08E 00              	   288: CmdErrorPointer:	ds	1			; Command line error pointer
01:B08F 00              	   289: CurrentBank:		ds	1			; Keep track of current bank
01:B090 00              	   290: CurrentAddress:		ds	2			; Current Address for prompt
01:B091 *
01:B092 00              	   291: DigitString			ds	9			; Digit string for numeric conversions (so they are printable with PrintString)
01:B093 *
01:B09B 0200            	   292: ParseSaveHL			dw	2			; Saves the HL, as HL is used to call routines, and interferes with registers
01:B09D 00              	   293: RegA:				ds	1			; Register A
01:B09E 00              	   294: RegBC:				ds	2			; Register BC
01:B09F *
01:B0A0 00              	   295: RegDE:				ds	2			; Register DE
01:B0A1 *
01:B0A2 00              	   296: RegHL:				ds	2			; Register HL
01:B0A3 *
01:B0A4 00              	   297: RegIX:				ds	2			; Index IX
01:B0A5 *
01:B0A6 00              	   298: RegIY:				ds	2			; Index IY
01:B0A7 *
01:B0A8 00              	   299: StackPtr:			ds	2			; Index SP
01:B0A9 *
01:B0AA 00              	   300: FlagsReg:			ds	1			; Status flags
                        	   301: ;RegI:				ds	1			; 
                        	   302: ;RegR:				ds	1			; 
01:B0AB 00              	   303: StartAddress:		ds	2			; Original start or source address
01:B0AC *
01:B0AD 00              	   304: EndAddress:			ds	2			; Original end or destination address
01:B0AE *
01:B0AF 00              	   305: StartAddressAlt:	ds	2			; Original start or source address
01:B0B0 *
01:B0B1 00              	   306: EndAddressAlt: 		ds	2			; Original end or destination address
01:B0B2 *
01:B0B3 00              	   307: ByteTransfer:		ds	1			; Byte to copy/transfer
01:B0B4 00              	   308: UserCodeSize		ds	2			; Size of uploaded user code 
01:B0B5 *
                        	   309: 
                        	   310: EndOfCode:
01:B0B6 FF              	   311: 	ds	VectorTable-$,$FF			; Fill gap with $FF to optimize speed when programming the FLASH/EEPROM
01:B0B7 *
                        	   312: 
                        	   313: 
                        	   314: ; __     __                _                      _____           _       _        
                        	   315: ; \ \   / /   ___    ___  | |_    ___    _ __    |_   _|   __ _  | |__   | |   ___ 
                        	   316: ;  \ \ / /   / _ \  / __| | __|  / _ \  | '__|     | |    / _` | | '_ \  | |  / _ \
                        	   317: ;   \ V /   |  __/ | (__  | |_  | (_) | | |        | |   | (_| | | |_) | | | |  __/
                        	   318: ;    \_/     \___|  \___|  \__|  \___/  |_|        |_|    \__,_| |_.__/  |_|  \___|
                        	   319: ;
                        	   320: ; ---------------------------------------------------------------------------------------------------------------------
                        	   321: ; CONSTANT VALUES SO EXTERNALLY LOADED PROGRAMS CAN ACCESS SPECIFIC INFORMATION
                        	   322: 	.org	$FD00
                        	   323: 
                        	   324: VectorTable:
                        	   325: 
02:FD00 8000            	   326: IntVectorEnd:		dw	InterruptVectorEnd	;= $FD00			; End of interrupt vector table
02:FD02 00FD            	   327: VectorTableStart:	dw	VectorTable			;= $FD02			; Start of vector and jump tables
02:FD04 0080            	   328: CodeStartAddr:		dw	StartOfCode			;= $FD04			; Start of code address
02:FD06 B6B0            	   329: CodeEndAddr:		dw	EndOfCode			;= $FD06			; End of code address
                        	   330: 
02:FD08 FF              	   331: 	ds	JumpTable-$,$FF				; $FF up to the jump table
02:FD09 *
                        	   332: 
                        	   333: 
                        	   334: ;      _                                 _____           _       _        
                        	   335: ;     | |  _   _   _ __ ___    _ __     |_   _|   __ _  | |__   | |   ___ 
                        	   336: ;  _  | | | | | | | '_ ` _ \  | '_ \      | |    / _` | | '_ \  | |  / _ \
                        	   337: ; | |_| | | |_| | | | | | | | | |_) |     | |   | (_| | | |_) | | | |  __/
                        	   338: ;  \___/   \__,_| |_| |_| |_| | .__/      |_|    \__,_| |_.__/  |_|  \___|
                        	   339: ;                             |_|                                         
                        	   340: ; ---------------------------------------------------------------------------------------------------------------------
                        	   341: ; JUMP TABLE TO CALL ROUTINES FROM AN EXTERNAL PROGRAM
                        	   342: 
                        	   343: 	.org	$FE00
                        	   344: 	
                        	   345: JumpTable:
03:FE00 C36981          	   346: 	jp		Ascii2HexNibble		;= $FE00				; [A -> A][A -> A]
03:FE03 C38D81          	   347: 	jp		Ascii2HexByte		;= $FE03				; [(HL) -> A][(HL) -> A]
03:FE06 C3AC81          	   348: 	jp		Ascii2HexWord		;= $FE06				; [(HL) -> BC][(HL) -> BC]
03:FE09 C3AA82          	   349: 	jp		ClearScreen			;= $FE09				; [][]
03:FE0C C3C988          	   350: 	jp		GetHexParameter		;= $FE0C				; [(HL) -> BC,A,(HL)][(HL) -> BC,A,(HL)]
03:FE0F C37480          	   351: 	jp		PrintChar			;= $FE0F				; [A ->][A ->]
03:FE12 C3AE80          	   352: 	jp		PrintString			;= $FE12				; [HL ->][HL ->]
03:FE15 C37F80          	   353: 	jp		PrintCRLF			;= $FE15				; [][]
03:FE18 C39E80          	   354: 	jp		PrintNibble			;= $FE18				; [A ->][A ->]
03:FE1B C36180          	   355: 	jp		PrintByte			;= $FE1B				; [A ->][A ->]
03:FE1E C3BC80          	   356: 	jp		PrintWord			;= $FE1E				; [HL ->][HL ->]
03:FE21 C3D489          	   357: 	jp		RangeValidation		;= $FE21				; Start&EndAddress -> C, Start&EndAddress, Start&EndAddressAlt)
03:FE24 C3C780          	   358: 	jp		ReadChar			;= $FE24				; [-> A][-> A]
03:FE27 C3D080          	   359: 	jp		ReadCharNoWait		;= $FE27
03:FE2A C3EE80          	   360: 	jp		ReadString			;= $FE2A				; [HL ->][HL ->]
03:FE2D C3DB80          	   361: 	jp		ReadByte			;= $FE2D				; [-> A][-> A]
03:FE30 C33D81          	   362: 	jp		ReadWord			;= $FE30				; [-> HL][-> HL]
03:FE33 C3378B          	   363: 	jp		SkipSpaces			;= $FE33				; [HL -> HL][HL -> HL]
03:FE36 C39F82          	   364: 	jp		UpperCase			;= $FE36				; [A -> A][A -> A]
03:FE39 C34E86          	   365: 	jp		Registers			;= $FE39				; [][]
03:FE3C C3BF81          	   366: 	jp		Dec2Hex				;= $FE3C				; [(HL) -> BC]
                        	   367: 
                        	   368: VectorEnd:
03:FE3F FF              	   369: 	ds		StackPage-$,$FF		; $FF the rest of the jump table all the way to the stack area
03:FE40 *
                        	   370: 
                        	   371: 
                        	   372: ;  ____    _                    _    
                        	   373: ; / ___|  | |_    __ _    ___  | | __
                        	   374: ; \___ \  | __|  / _` |  / __| | |/ /
                        	   375: ;  ___) | | |_  | (_| | | (__  |   < 
                        	   376: ; |____/   \__|  \__,_|  \___| |_|\_\
                        	   377: ;
                        	   378: ; ---------------------------------------------------------------------------------------------------------------------
                        	   379: ; STACK AREA, ClEAR OUT WITH ZEROS
                        	   380: 
                        	   381: 	.org	$FF00
                        	   382: 
                        	   383: StackPage:
                        	   384: 
04:FF00 00              	   385: 	ds		$FFFF-$,$00			; Zero the stack all the way to end of ROM
04:FF01 *
                        	   386: 
                        	   387: BiosEnd:
                        	   388: .end


Symbols by name:
ABPASS                           A:9BF2
ABS                              A:A23E
ACCSUM                           A:9462
ACPASS                           A:9BF1
ADD30                            A:A750
ADD301                           A:A764
ADDEXP                           A:A1D7
ADDIG                            A:A37D
ADDPHL                           A:9FC4
ALLFOL                           A:9EC0
ANTVLU                           A:975B
ARET                             A:A6CE
ARETN                            A:A81D
ARLDSV                           A:9B12
ARREND                           E:10DA
ARRLP                            A:9D8B
ASCC                             A:9E91
Ascii2BcdDigit                   A:8169
Ascii2HexByte                    A:818D
Ascii2HexByteErr                 A:81A9
Ascii2HexNibble                  A:8169
Ascii2HexNibbleEnd               A:8186
Ascii2HexNibbleErr               A:818B
Ascii2HexNibbleOK                A:817E
Ascii2HexWord                    A:81AC
Ascii2HexWordErr                 A:81BC
ASCTFP                           A:A320
ASPCS                            A:96BD
ATN                              A:A682
ATN1                             A:A69F
ATNTAB                           A:A6A9
ATOH                             A:949D
BADINP                           A:96E2
BadMemory1Err                    A:ADE2
BadMemory2Err                    A:ADEC
BAKSTK                           A:8F1F
BAKTMP                           A:9E71
BankCopyLoop                     A:0083
BankSelect                       E:0030
BASIC                            A:8B45
BASTXT                           E:105E
BCDEFP                           A:A265
BFREE                            A:8C71
BIN                              A:A7A6
BIN2                             A:A7AC
BINERR                           A:A803
BINIT                            A:A7E2
BINTFP                           A:A7D8
BiosEnd                          A:FFFF
BiosRange                        A:B014
BITOUT                           A:A7C0
BITOUT2                          A:A7C4
BKSP                             E:0008
BN                               E:0028
BNORM                            A:A024
BNRMLP                           A:A027
BootMsg                          A:A82F
BRK                              A:9414
BRKFLG                           E:104D
BRKLIN                           E:10CE
BRKMSG                           A:8F19
BRKRET                           A:8C6B
BS                               E:0010
BSERR                            A:9B45
BUFFER                           E:1061
BufferPointer                    A:B08C
BYT2ASC                          A:A747
BytesFree                        E:CBCA
ByteTransfer                     A:B0B3
BYTSFT                           A:A15C
Carry                            E:0000
CFEVAL                           A:9AA8
CHARTY                           A:9A56
CheckIfCold                      A:8B54
CheckIfWarm                      A:8B61
ChecksumErr                      E:0001
CHEKFN                           A:9C89
CHKBIN                           A:A7F5
CHKLTR                           A:946F
CHKSTK                           A:8F53
CHKSUM                           E:104A
CHKSYN                           A:9244
CHKTYP                           A:983C
CHR                              A:9EA2
CLEAR                            A:94C2
ClearScreen                      A:82AA
ClearScreenSeq                   A:AB8D
CLOTST                           A:9279
CLREG                            A:90A8
CLRPTR                           A:9083
CLS                              A:A6D3
CmdErrorPointer                  A:B08E
CMPFP                            A:A2AE
CMPLG1                           A:99BC
CMPLOG                           A:99BA
CMPNUM                           A:A294
CMPRES                           A:99FE
CMPSTR                           A:99E6
CN                               E:0020
CNVNUM                           A:A32C
CodeEndAddr                      A:FD06
CodeStartAddr                    A:FD04
COLD                             A:8BCA
ColdOrWarm                       A:8B4E
COMMAN                           E:1043
CommandBuffer                    A:B06E
CommandList                      A:A8B8
CommandPrompt                    A:889F
COMPL                            A:A084
CONCAT                           A:9E06
CONEXP                           A:A35C
CONPOS                           A:A021
CONT                             A:9447
CONTAD                           E:10D4
CONVAR                           A:9927
CopyBlock                        A:82B3
CopyDestinationAddress           A:82C8
CopyEnd                          A:8313
CopyNoOverlap                    A:8307
CopyNoParameter                  A:830B
CopyNothing                      A:8310
CopyNumberOfBytes                A:82D6
CopySourceAddress                A:82BA
COPYY                            A:8BE4
COS                              A:A606
COUNT                            A:92E9
CPDEHL                           A:923E
CPYLIT                           A:917A
CR                               E:000D
CRARLP                           A:9B65
CREARY                           A:9B4A
CRESTR                           A:95C1
CRNCLP                           A:90DB
CRTMST                           A:9CC2
CRTST                            A:9CCE
CRTSTE                           A:9CE4
CRUNCH                           A:90D2
CSTART                           A:8BD5
CTLOFG                           E:1045
CTRLC                            E:0003
CTRLG                            E:0007
CTRLO                            E:000F
CTRLQ                            E:0011
CTRLR                            E:0012
CTRLS                            E:0013
CTRLU                            E:0015
CUROPR                           E:10C5
CURPOS                           E:10AB
CurrentAddress                   A:B090
CurrentBank                      A:B08F
DATAA                            A:9568
DATFLG                           E:10AE
DATLIN                           E:10C9
DATSNR                           A:8F70
DCBCDE                           A:A2E5
DD                               E:0012
DDERR                            A:8F7F
Dec2Hex                          A:81BF
Dec2HexEnd                       A:8209
Dec2HexInvalidDec                A:8202
Dec2HexLoop                      A:81C8
Dec2HexOutOfRange                A:81FC
Dec2HexShuffleRegs               A:81F6
DecErrorPointer                  A:88BF
DEEK                             A:A6ED
DEF                              A:9C06
DEFSIZ                           A:9B6D
DEINT                            A:9483
DEL                              E:007F
DELCHR                           A:91AA
DELIMITER                        E:0020
DEPINT                           A:947D
DETHL4                           A:A274
DETHLB                           A:A276
DiagMemoryAddr                   A:83AC
DiagMemoryError                  A:8395
Diagnostics                      A:8318
DiagnosticsBankLoop              A:8326
DiagnosticsEnd                   A:83CF
DiagnosticsEnd2                  A:83DF
DiagnosticsTest                  A:8361
DiagnosticsTestLoop              A:8364
DigitString                      A:B092
DIGTXT                           A:A426
DIM                              A:9A28
DIMRET                           A:9A1F
DINPOS                           A:9273
DIV                              A:A16D
DIV1                             E:100A
DIV10                            A:A161
DIV2                             E:100E
DIV3                             E:1012
DIV4                             E:1015
DIVLP                            A:A194
DIVSUP                           E:1009
DOAGN                            A:90C1
DOCOM                            A:968E
DODEL                            A:918A
DOEBIT                           A:A466
DOFN                             A:9C33
DOKE                             A:A6F8
DONULL                           A:967C
DOSPC                            A:96B8
DOTAB                            A:96A5
DownloadedBytesMsg               A:AED2
DPOINT                           A:A358
DTSTR                            A:9CD2
DVBCDE                           A:A16F
DZ                               E:0014
DZERR                            A:8F79
ECHDEL                           A:919E
EDIGIT                           A:A39F
EndAddress                       A:B0AD
EndAddressAlt                    A:B0B1
ENDBUF                           A:9181
ENDCON                           A:A36B
ENDDIM                           A:9BCC
ENDINP                           A:9674
ENDNAM                           A:9A4A
EndOfCode                        A:B0B6
ENDPRG                           A:9423
ENFMEM                           A:8F5C
EOT                              E:00FF
ERRIN                            A:8FAA
ERRLIN                           E:10D2
ERRMSG                           A:8F07
ERROR                            A:8F8A
ERRORPTR                         E:005E
ErrorPtrOffset                   E:0008
ERRORS                           A:8E7D
ESC                              E:001B
EVAL                             A:9849
EVAL1                            A:984C
EVAL2                            A:9855
EVAL3                            A:9858
EVLPAR                           A:990E
EVNOT                            A:9A08
EXCUTE                           A:93AE
EXIT                             A:A82C
EXPLP                            A:A34A
EXPP                             A:A500
EXPTAB                           A:A540
EXPTEN                           A:A478
EXTIG                            A:97B7
FANDT                            A:97E1
FC                               E:0008
FCERR                            A:9498
FDTLP                            A:97C8
FillByte                         A:8412
FillEndAddr                      A:8405
FillHelp                         A:AEE6
FillMemory                       A:83E8
FillMemoryEnd                    A:8482
FillNoParameter                  A:8476
FillPrintHelp                    A:847C
FillRange1                       A:8424
FillRange2                       A:844C
FillStartAddr                    A:83EF
FINDEL                           A:9BA8
FlagBits                         A:AB87
FlagCarryClear                   A:8778
FlagHalfClear                    A:8754
FlagNegativeClear                A:876C
FlagOverClear                    A:8760
FlagSignClear                    A:873C
FlagsReg                         A:B0AA
FlagZeroClear                    A:8748
FLGDIF                           A:A224
FLGREL                           A:A22B
FNARG                            E:10E0
FNCTAB                           A:8CC1
FNDARY                           A:9B18
FNDELP                           A:9BAD
FNDEND                           A:9056
FNDNUM                           A:9F95
FNDTOK                           A:92C8
FNDVAR                           A:9A8F
FNDWRD                           A:9105
FNOFST                           A:9938
FNRGNM                           E:10DE
FNTHR                            A:9A9D
FNVAL                            A:995F
FOPRND                           A:9881
FOR                              A:9315
FORFLG                           E:10CB
FORFND                           A:9345
FORSLP                           A:9329
FPADD                            A:9FD3
FPBCDE                           A:A25A
FPEXP                            E:10E7
FPINT                            A:A2C1
FPMULT                           A:A10E
FPREG                            E:10E4
FPROND                           A:A06B
FPSINT                           A:9477
FPTHL                            A:A271
FRE                              A:9BD0
FRENUM                           A:9BEC
FRMEVL                           A:992A
GARBGE                           A:9D53
GARBLP                           A:9D56
GETCHR                           A:93CE
GETCMD                           A:8FCE
GetErrorPointerLoop              A:8935
GETHEX                           A:A781
GetHexParameter                  A:88C9
GETINP                           A:A6CF
GETINT                           A:9F98
GETLEN                           A:9E86
GETLIN                           A:91BB
GETLN                            A:949E
GETNUM                           A:9837
GETNXT                           A:9120
GetParamCount                    A:88CF
GetParamErrorEnd                 A:8948
GetParameterEnd                  A:892C
GetParamFetch                    A:88E0
GetParamFetch0                   A:88E5
GetParamFetch1                   A:88ED
GetParamFetch2                   A:88FD
GetParamFetch3                   A:890B
GetParamFetch4                   A:8921
GetParamHelp                     A:892E
GetParamHexError                 A:8942
GetParamNumberError              A:8933
GETSTR                           A:9E50
GETVAR                           A:9A2D
GNXARY                           A:9D8A
GOFUNC                           A:9967
GOSUB                            A:9514
GOTO                             A:9525
GRBARY                           A:9DAA
GRBDON                           A:9D2B
GRBLP                            A:9D64
GSTRCU                           A:9E53
GSTRDE                           A:9E57
GSTRHL                           A:9E56
GTFLNM                           A:9E95
GTFNAM                           A:9A32
GTLNLP                           A:94A1
GTSIXD                           A:A3F0
GTVLUS                           A:9733
HALF                             A:A497
HalfCarry                        E:0004
HALFPI                           A:A650
HELP                             E:000F
HEX                              A:A70F
HEX1                             A:A728
HEX2                             A:A72A
Hex2Dec                          A:820C
Hex2Dec1                         A:8289
Hex2Dec10                        A:826C
Hex2Dec100                       A:824F
Hex2Dec1000                      A:8232
Hex2Dec10000                     A:8217
Hex2Dec10000Loop                 A:8219
Hex2Dec10000Set                  A:8229
Hex2Dec1000Loop                  A:8234
Hex2Dec1000Set                   A:8246
Hex2Dec100Loop                   A:8251
Hex2Dec100Set                    A:8263
Hex2Dec10Loop                    A:826E
Hex2Dec10Set                     A:8280
Hex2DecEnd                       A:8296
HEX3                             A:A738
HEX4                             A:A73A
HexDefaultLines                  A:84B2
HexDisplayContent                A:84B4
HexDump                          A:8487
HexDumpEnd                       A:84FE
HexDumpHelp                      A:AF51
HexDumpPrintHelp                 A:84F8
HEXIT                            A:A798
HexLinesToRead                   A:849F
HEXLP                            A:A774
HEXLP1                           A:A779
HexNextByte                      A:84C5
HexNextChar                      A:84D8
HexNextLine                      A:84B5
HexPrintChar                     A:84E5
HexReplaceDot                    A:84E3
HEXTFP                           A:A768
HorizTextRes                     E:0028
HX                               E:0026
HXERR                            A:A7A1
ID                               E:0016
IDTEST                           A:9C7B
IFF                              A:95F7
IFGO                             A:9605
IFJMP                            A:93B5
IncErrorPointer                  A:894A
INCHL                            A:A26F
INCLEN                           A:926F
INDFND                           A:8F39
INEWLN                           A:901E
INIT                             A:8BDC
INITAB                           A:8EA7
INITBE                           A:8F07
INITST                           A:A815
INMSG                            A:8F0E
INP                              A:9F55
INPBIN                           A:9785
INPBRK                           A:9420
INPORT                           E:103F
INPSUB                           E:103E
INPUT                            A:96F3
INRNG                            A:A3F9
INT                              A:A2EC
IntelHex                         A:8503
IntelHexAbort                    A:85A8
IntelHexAbortedMsg               A:AEB7
IntelHexAddress                  A:8535
IntelHexByteCount                A:8530
IntelHexCheckOk                  A:8576
IntelHexChecksum                 A:8568
IntelHexData                     A:855D
IntelHexEnd                      A:85CC
IntelHexFinishedMsg              A:AE5B
IntelHexHelp                     A:AFB6
IntelHexLoadMsg                  A:AE7A
IntelHexParamError               A:85BE
IntelHexPrintEndMsg              A:8583
IntelHexPrintHelp                A:85C6
IntelHexPrintNotOk               A:8595
IntelHexPrintStatus              A:8578
IntelHexRecordType               A:854A
IntelHexStartCode                A:8522
IntelHexSuccessMsg               A:AE6B
IntelHexUnsupported              A:85B0
IntelHexUnsupportedErr           A:AD28
InterruptVectorEnd               A:0080
INTVAR                           A:9092
IntVectorEnd                     A:FD00
InvalidBank                      A:B032
InvalidBankNumberErr             A:AD92
InvalidDecimalNumber             A:B056
InvalidDecimalNumberErr          A:ADB0
InvalidHexDigit                  A:B044
InvalidHexDigitErr               A:AC85
InvalidVectorRange               A:B002
InvalidVectorRangeErr            A:AD42
INVSGN                           A:A242
ITMSEP                           A:9776
JJUMP1                           A:A808
JSTZER                           A:A482
JUMP                             E:00C3
JumpTable                        A:FE00
KILFOR                           A:9827
KILIN                            A:91B5
LastRec                          E:0007
LCRFLG                           E:10AC
LEFT                             A:9EB2
LEN                              A:9E82
LET                              A:957F
LETNUM                           A:95D2
LETSTR                           A:959A
LF                               E:000A
LFRGNM                           A:9F4B
LINEAT                           E:105C
LINEIN                           A:A3AB
LINES                            A:A6DE
LINESC                           E:1046
LINESN                           E:1048
LINFND                           A:9007
ListCmd                          A:85D3
LISTLP                           A:9296
ListOfCommands                   A:A932
LISTT                            A:928A
LOADFP                           A:A268
LOG                              A:A0CD
LOGTAB                           A:A0C0
LOKFOR                           A:8F23
LOOPST                           E:10C7
LS                               E:001C
LSTBIN                           E:10CC
LSTLP2                           A:92B6
LSTLP3                           A:92B9
LSTRAM                           E:10AF
LSTRND                           E:103A
LTSTND                           A:9790
LWIDTH                           E:1042
Main                             A:8044
MAKINT                           A:9F9B
MAKNUM                           A:A415
MANLP                            A:A334
MATCH                            A:9152
MEMMSG                           A:8CB6
MemoryTestPassedMsg              A:AE37
MID                              A:9EEC
MID1                             A:9EB8
MIDNUM                           A:9F50
MINCDE                           A:A013
MINUS                            A:9916
MissingParameterErr              A:ACD7
MKTMST                           A:9CBF
MLDBLP                           A:A30D
MLDEBC                           A:A305
MLOOP                            A:8C0C
MLSP10                           A:A202
MO                               E:0024
MONITR                           A:A812
MONOUT                           A:A80F
MORDT                            A:979C
MORINP                           A:91C4
MOVBUF                           A:903D
MOVDIR                           A:915A
MOVLP                            A:8F48
MOVSTR                           A:8F45
MOVUP                            A:8F42
MRPRNT                           A:9617
MSIZE                            A:8BF9
MUL8LP                           A:A139
MULLN2                           A:A105
MULT8                            A:A130
MULTEN                           A:A376
MULTT                            A:A10C
MULVAL                           E:10F6
MVSTPT                           A:95C9
NEDMOR                           A:972F
NEGAFT                           A:A4AD
Negative                         E:0001
NEW                              A:9082
NEXITM                           A:96C8
NEXT                             A:97EC
NEXT1                            A:97EF
NF                               E:0000
NFERR                            A:8F7C
NMI66                            A:0066
NOCHNG                           A:914A
NOENED                           A:A485
NOLIN                            A:9436
NOMADD                           A:A14A
NOMLAD                           A:A31B
NoParameter                      A:B026
NOPMPT                           A:970D
NORMAL                           A:A03E
NOSPC                            A:9141
NOSUB7                           A:A794
NOSWAP                           A:9FED
NOTAMP                           A:98EB
NothingToCopy                    A:B05F
NothingToCopyErr                 A:ADFF
NOTSTR                           A:9A65
NOXOR                            A:9F7B
NSCFOR                           A:9A75
NULFLG                           E:1044
NULLL                            A:945A
NULLP                            A:9683
NULLS                            E:1041
NUMASC                           A:A3BE
NumberOutOfRange                 A:B04D
NumberOutOfRangeErr              A:ADC9
NXTARY                           A:9B2C
NXTBYT                           A:9130
NXTCHR                           A:9171
NXTDAT                           E:10DC
NXTDTA                           A:9567
NXTITM                           A:9727
NXTOPR                           E:10D0
NXTSTL                           A:956E
NXTSTT                           A:9571
OD                               E:0006
OKMSG                            A:8F13
OM                               E:000C
OMERR                            A:8F6B
ON                               A:95D9
ONGO                             A:95E8
ONGOLP                           A:95E9
ONJMP                            A:93B6
OPNPAR                           A:9845
OPRND                            A:98C0
OS                               E:001A
OTKLN                            A:91B2
OTPORT                           E:1007
OUTC                             A:924F
OUTEXP                           A:A476
OUTIT                            A:9230
OUTNBS                           A:9236
OUTNCR                           A:A826
OUTSUB                           E:1006
OUTWRD                           A:92D2
OV                               E:000A
Overflow                         E:0002
OVERR                            A:8F85
OVTST1                           A:A1F5
OVTST2                           A:A1FA
OVTST3                           A:A1FB
PADD                             A:A39A
PAND                             A:9981
ParseEnd                         A:89B5
ParseExecute                     A:89A0
ParseInvalid                     A:89AF
ParseInvalidErr                  A:AC5F
ParseNextChar                    A:896E
ParseNextCmd                     A:8986
Parser                           A:8954
ParseSaveHL                      A:B09B
ParseValidate                    A:8997
PASSA                            A:9C01
PBUFF                            E:10E9
PEEK                             A:9FA9
PeekAddress                      A:85E8
PeekCmd                          A:85E2
PeekDefault                      A:85F4
PeekEnd                          A:860D
PeekRead                         A:85F8
PEND                             A:941B
PHLTFP                           A:A257
PLUCDE                           A:A078
PNORM                            A:A046
POINT                            E:1051
POKE                             A:9FB0
PokeAddress                      A:8617
PokeByte                         A:8625
PokeCmd                          A:8611
PokeEnd                          A:864A
PokeNoParameter                  A:8647
PokeWrite                        A:862F
POPAF                            A:9D45
POPHL                            A:9E6F
POPHRT                           A:A15A
POPNOK                           A:8FC0
POR                              A:9980
POR1                             A:99A3
POS                              A:9BFE
POSINT                           A:947A
POUT                             A:9F61
POWER                            A:A4BB
POWER1                           A:A4CB
POWER2                           A:A4E8
POWERS                           A:A49B
PrintByte                        A:8061
PrintChar                        A:8074
PrintCharTxWait                  A:8075
PrintCRLF                        A:807F
PrintDec                         A:8058
PrintErrorLoop                   A:89C2
PrintErrorPointer                A:89BC
PrintLine                        A:808C
PrintLineLoop                    A:8093
PrintNibble                      A:809E
PrintNibbleEnd                   A:80A9
PrintString                      A:80AE
PrintStringEnd                   A:80BA
PrintStringLoop                  A:80AF
PRINTT                           A:961B
PrintWord                        A:80BC
PRITAB                           A:8E68
PRNTHL                           A:A3B3
PRNTLP                           A:961E
PRNTNB                           A:9661
PRNTOK                           A:8FC1
PRNTST                           A:9665
PRNUMS                           A:9D0F
PROCES                           A:91DD
PROGND                           E:10D6
PROGST                           E:10F9
PROMPT                           A:90C5
PRS                              A:9D10
PRS1                             A:9D13
PRSLP                            A:9D1A
PSET                             E:1054
PSUB                             A:9FCE
PTRLP                            A:904A
PUTBUF                           A:921C
PUTCTL                           A:9221
PUTFID                           A:938A
QTSTLP                           A:9CD5
QTSTR                            A:9CCF
QUARTR                           A:A654
Range                            A:AFF9
RangeInverted                    A:B01D
RangeMsg                         A:AE4C
RangeTooSmall                    A:B00B
RangeTooSmallErr                 A:AD75
RangeValidation                  A:89D4
RangeValidationEnd               A:8B2B
RangeValidationError             A:8B27
READ                             A:9722
ReadByte                         A:80DB
ReadChar                         A:80C7
ReadCharNoWait                   A:80D0
READFG                           E:10CD
ReadString                       A:80EE
ReadStringBS                     A:8119
ReadStringChar                   A:80F6
ReadStringCR                     A:8133
ReadStringESC                    A:8132
ReadStringSave                   A:810D
ReadWord                         A:813D
REDO                             A:96CF
RegA                             A:B09D
RegBC                            A:B09E
RegDE                            A:B0A0
RegHL                            A:B0A2
Registers                        A:864E
RegIX                            A:B0A4
RegIY                            A:B0A6
REM                              A:956A
RESDIV                           A:A1A7
RESEED                           A:A5F2
ReservedBiosAreaErr              A:AD5F
RESET                            E:1057
ResetErrorPointer                A:8B2F
RESTNL                           A:93F3
RESTOR                           A:93DE
RESZER                           A:A039
RETADR                           A:9ADC
RETINT                           A:A230
RETLIN                           A:9562
RETNAD                           A:9156
RETNUL                           A:9ADF
RETNUM                           A:9922
RETREL                           A:A222
RETURN                           A:9543
RG                               E:0004
RIGHT                            A:9EE2
RIGHT1                           A:9EB6
RINPUT                           E:104E
RLTLP                            A:9865
RND                              A:A591
RND1                             A:A5CD
RND2                             A:A5E9
RNDTAB                           A:A5FA
RNGTST                           A:A488
ROMCopy                          A:0098
RomDisable                       E:0038
RONDB                            A:A05A
RONDUP                           A:A059
ROUND                            A:9FC1
RSCALE                           A:A394
RSLNBK                           A:930C
RST00                            A:0000
RST08                            A:0008
RST10                            A:0010
RST18                            A:0018
RST20                            A:0020
RST28                            A:0028
RST30                            A:0030
RST38                            A:0038
RSTSTR                           A:9F05
RUN                              A:9508
RunCallBC                        A:8798
RUNCNT                           A:938E
RunCode                          A:8788
RunEnd                           A:879A
RUNFST                           A:908E
RUNLIN                           A:9524
SAVEXP                           A:A03A
SAVSTP                           A:9381
SAVSTR                           A:9CAA
SBSCPT                           A:9AEA
SCALE                            A:A098
SCALLP                           A:A09A
SCALMI                           A:A35F
SCALPL                           A:A375
SCNEND                           A:9DE1
SCPTLP                           A:9AF0
SEARCH                           A:911E
SEED                             E:1017
SetAddress                       A:879B
SetAddressDefault                A:87B1
SetAddressEnd                    A:87B7
SetBank                          A:87BC
SetBankDefault                   A:87DC
SetBankEnd                       A:87E8
SetBankError                     A:87E5
SETIO                            A:9F85
SETLIN                           A:92E0
SETLIT                           A:9168
SETPTR                           A:9045
SETTOP                           A:8C30
SFTPRG                           A:900F
SGN                              A:A228
SGNEXP                           A:9970
SGNRES                           E:10E8
ShadowCopy                       A:0080
SHRITE                           A:A0A7
SHRLP                            A:A0AA
SHRT1                            A:A0AE
Sign                             E:0007
SIGNON                           A:8C80
SignOnMsg                        A:8B6E
SIGNS                            A:A27F
SIN                              A:A60C
SIN1                             A:A63C
SINTAB                           A:A658
SIO_Init                         A:814B
SIO_PortA_Ctrl                   E:0002
SIO_PortA_Data                   E:0000
SIXDIG                           A:A3DB
SkipSpaces                       A:8B37
SkipSpacesEnd                    A:8B43
SkipSpacesLoop                   A:8B38
SMPVAR                           A:9D75
SMSER1                           A:A570
SN                               E:0002
SNERR                            A:8F76
SPCFST                           A:A3CC
SPCLP                            A:96C1
SQR                              A:A4B2
SRCHLN                           A:9062
SRCHLP                           A:9065
SSTSA                            A:9E3D
ST                               E:001E
STACK                            E:1066
StackPage                        A:FF00
StackPtr                         A:B0A8
STAKFP                           A:A24A
STALL                            A:9408
StartAddr                        E:0000
StartAddress                     A:B0AB
StartAddressAlt                  A:B0AF
StartGreaterEndErr               A:AD07
StartOfCode                      A:8000
STKTHS                           A:98A9
STLOOK                           E:115D
STOPP                            A:9419
STORED                           A:94E5
STPOOL                           A:9DB8
STR1                             A:9CA0
STRADD                           A:9DBB
STRBOT                           E:10C3
STRENT                           A:9779
STRR                             A:9C9A
STRSPC                           E:105A
STTLIN                           A:966C
SUBCDE                           A:9FD0
SUBPHL                           A:9FCA
SUMLP                            A:A579
SUMSER                           A:A561
SUPTLZ                           A:A45A
SVNAM2                           A:9A49
SVSTAD                           A:9CC8
SysInfo                          A:87ED
SysInfoMsg                       A:AB9A
TAN                              A:A66D
TestingBankNumberMsg             A:AE11
TestingHighRamMsg                A:AE24
TESTOS                           A:9D47
TESTR                            A:9D29
TM                               E:0018
TMERR                            A:8F88
TMPSTR                           E:10BF
TMSTPL                           E:10B3
TMSTPT                           E:10B1
TooManyDigits                    A:B03B
TooManyDigitsErr                 A:ACAE
TOPOOL                           A:9EAE
TOSTRA                           A:9E46
TRYAGN                           A:A435
TSALP                            A:9E47
TSTBIT                           A:A81F
TSTBRK                           A:93F9
TSTMEM                           A:8C1E
TSTNUM                           A:983A
TSTOPL                           A:9CF0
TSTRED                           A:99A8
TSTREM                           A:916B
TSTSGN                           A:A219
TSTSTR                           A:983B
TTYLIN                           A:91BB
TYPE                             E:10AD
UF                               E:0022
UFERR                            A:8F82
UL                               E:000E
ULERR                            A:953E
UNITY                            A:A0BC
UnrecognizedParamErr             A:ACEE
UPDATA                           A:93F4
UpperCase                        A:829F
UpperCaseEnd                     A:82A9
UserCodeSize                     A:B0B4
USR                              E:1003
VAL                              A:9F1C
VAL1                             A:9F3A
VAL2                             A:9F44
VAL3                             A:9F47
ValBiosOverlap                   A:8A9C
ValBiosRangeError                A:8B15
ValCheckBiosHi                   A:8A37
ValCheckBiosLow                  A:8A2C
ValCheckHigh                     A:8A45
ValCheckHighBios                 A:8A6B
ValCheckHighLimit                A:8A0F
ValCheckHighLimit2               A:8A20
ValCheckIfZeroDataHigh           A:8AC8
ValCheckIfZeroDataLow            A:8AB8
ValCheckInverted                 A:89E2
ValCheckLow                      A:8A79
ValCheckLowBios                  A:8A93
ValCheckLowLimit                 A:89F2
ValCheckLowLimit2                A:8A03
ValInvertedError                 A:8B21
ValPrintRange                    A:8AD8
ValPrintRange1                   A:8ADB
ValPrintRange2                   A:8AF5
ValPrintRangeEnd                 A:8B0F
ValRangeTooSmallError            A:8B1B
VAREND                           E:10D8
VectorCopy                       A:00A3
VectorEnd                        A:FE3F
VectorTable                      A:FD00
VectorTableStart                 A:FD02
VertTextRes                      E:0018
WAIT                             A:9F67
WAITLP                           A:9F7C
WARM                             A:8C68
WIDTH                            A:A6D6
WORDS                            A:8CF9
WORDTB                           A:8E1C
Write                            A:880A
WriteEnd                         A:8855
WriteFirstByte                   A:881D
WriteGetAddress                  A:8811
WriteNoParameter                 A:8852
WriteRemainingBytes              A:8831
WriteTooManyDigits               A:8847
WRKSPC                           E:1000
ZDATA                            E:0083
ZEND                             E:0080
ZEQUAL                           E:00B4
ZERARY                           A:9B8B
ZERBYT                           E:8F12
Zero                             E:0006
ZeroAllRam                       A:885A
ZeroEnd                          A:889A
ZeroHighRange                    A:8881
ZeroLowRange                     A:8860
ZEROLP                           A:9ACE
ZEROSUP                          A:A7B2
ZFN                              E:00A7
ZFOR                             E:0081
ZGOSUB                           E:008C
ZGOTO                            E:0088
ZGTR                             E:00B3
ZLEFT                            E:00CF
ZLTH                             E:00B5
ZMINUS                           E:00AD
ZNEW                             E:00A4
ZNOT                             E:00AA
ZONELP                           A:969C
ZOR                              E:00B2
ZPLUS                            E:00AC
ZPRINT                           E:009E
ZREM                             E:008E
ZSGN                             E:00B6
ZSPC                             E:00A8
ZSTEP                            E:00AB
ZTAB                             E:00A5
ZTHEN                            E:00A9
ZTO                              E:00A6

Symbols by value:
0000 RST00
0000 Carry
0000 SIO_PortA_Data
0000 NF
0000 StartAddr
0001 Negative
0001 ChecksumErr
0002 SIO_PortA_Ctrl
0002 Overflow
0002 SN
0003 CTRLC
0004 RG
0004 HalfCarry
0006 Zero
0006 OD
0007 LastRec
0007 Sign
0007 CTRLG
0008 BKSP
0008 ErrorPtrOffset
0008 RST08
0008 FC
000A LF
000A OV
000C OM
000D CR
000E UL
000F HELP
000F CTRLO
0010 RST10
0010 BS
0011 CTRLQ
0012 DD
0012 CTRLR
0013 CTRLS
0014 DZ
0015 CTRLU
0016 ID
0018 VertTextRes
0018 TM
0018 RST18
001A OS
001B ESC
001C LS
001E ST
0020 CN
0020 RST20
0020 DELIMITER
0022 UF
0024 MO
0026 HX
0028 RST28
0028 HorizTextRes
0028 BN
0030 RST30
0030 BankSelect
0038 RomDisable
0038 RST38
005E ERRORPTR
0066 NMI66
007F DEL
0080 ShadowCopy
0080 InterruptVectorEnd
0080 ZEND
0081 ZFOR
0083 BankCopyLoop
0083 ZDATA
0088 ZGOTO
008C ZGOSUB
008E ZREM
0098 ROMCopy
009E ZPRINT
00A3 VectorCopy
00A4 ZNEW
00A5 ZTAB
00A6 ZTO
00A7 ZFN
00A8 ZSPC
00A9 ZTHEN
00AA ZNOT
00AB ZSTEP
00AC ZPLUS
00AD ZMINUS
00B2 ZOR
00B3 ZGTR
00B4 ZEQUAL
00B5 ZLTH
00B6 ZSGN
00C3 JUMP
00CF ZLEFT
00FF EOT
1000 WRKSPC
1003 USR
1006 OUTSUB
1007 OTPORT
1009 DIVSUP
100A DIV1
100E DIV2
1012 DIV3
1015 DIV4
1017 SEED
103A LSTRND
103E INPSUB
103F INPORT
1041 NULLS
1042 LWIDTH
1043 COMMAN
1044 NULFLG
1045 CTLOFG
1046 LINESC
1048 LINESN
104A CHKSUM
104D BRKFLG
104E RINPUT
1051 POINT
1054 PSET
1057 RESET
105A STRSPC
105C LINEAT
105E BASTXT
1061 BUFFER
1066 STACK
10AB CURPOS
10AC LCRFLG
10AD TYPE
10AE DATFLG
10AF LSTRAM
10B1 TMSTPT
10B3 TMSTPL
10BF TMPSTR
10C3 STRBOT
10C5 CUROPR
10C7 LOOPST
10C9 DATLIN
10CB FORFLG
10CC LSTBIN
10CD READFG
10CE BRKLIN
10D0 NXTOPR
10D2 ERRLIN
10D4 CONTAD
10D6 PROGND
10D8 VAREND
10DA ARREND
10DC NXTDAT
10DE FNRGNM
10E0 FNARG
10E4 FPREG
10E7 FPEXP
10E8 SGNRES
10E9 PBUFF
10F6 MULVAL
10F9 PROGST
115D STLOOK
8000 StartOfCode
8044 Main
8058 PrintDec
8061 PrintByte
8074 PrintChar
8075 PrintCharTxWait
807F PrintCRLF
808C PrintLine
8093 PrintLineLoop
809E PrintNibble
80A9 PrintNibbleEnd
80AE PrintString
80AF PrintStringLoop
80BA PrintStringEnd
80BC PrintWord
80C7 ReadChar
80D0 ReadCharNoWait
80DB ReadByte
80EE ReadString
80F6 ReadStringChar
810D ReadStringSave
8119 ReadStringBS
8132 ReadStringESC
8133 ReadStringCR
813D ReadWord
814B SIO_Init
8169 Ascii2HexNibble
8169 Ascii2BcdDigit
817E Ascii2HexNibbleOK
8186 Ascii2HexNibbleEnd
818B Ascii2HexNibbleErr
818D Ascii2HexByte
81A9 Ascii2HexByteErr
81AC Ascii2HexWord
81BC Ascii2HexWordErr
81BF Dec2Hex
81C8 Dec2HexLoop
81F6 Dec2HexShuffleRegs
81FC Dec2HexOutOfRange
8202 Dec2HexInvalidDec
8209 Dec2HexEnd
820C Hex2Dec
8217 Hex2Dec10000
8219 Hex2Dec10000Loop
8229 Hex2Dec10000Set
8232 Hex2Dec1000
8234 Hex2Dec1000Loop
8246 Hex2Dec1000Set
824F Hex2Dec100
8251 Hex2Dec100Loop
8263 Hex2Dec100Set
826C Hex2Dec10
826E Hex2Dec10Loop
8280 Hex2Dec10Set
8289 Hex2Dec1
8296 Hex2DecEnd
829F UpperCase
82A9 UpperCaseEnd
82AA ClearScreen
82B3 CopyBlock
82BA CopySourceAddress
82C8 CopyDestinationAddress
82D6 CopyNumberOfBytes
8307 CopyNoOverlap
830B CopyNoParameter
8310 CopyNothing
8313 CopyEnd
8318 Diagnostics
8326 DiagnosticsBankLoop
8361 DiagnosticsTest
8364 DiagnosticsTestLoop
8395 DiagMemoryError
83AC DiagMemoryAddr
83CF DiagnosticsEnd
83DF DiagnosticsEnd2
83E8 FillMemory
83EF FillStartAddr
8405 FillEndAddr
8412 FillByte
8424 FillRange1
844C FillRange2
8476 FillNoParameter
847C FillPrintHelp
8482 FillMemoryEnd
8487 HexDump
849F HexLinesToRead
84B2 HexDefaultLines
84B4 HexDisplayContent
84B5 HexNextLine
84C5 HexNextByte
84D8 HexNextChar
84E3 HexReplaceDot
84E5 HexPrintChar
84F8 HexDumpPrintHelp
84FE HexDumpEnd
8503 IntelHex
8522 IntelHexStartCode
8530 IntelHexByteCount
8535 IntelHexAddress
854A IntelHexRecordType
855D IntelHexData
8568 IntelHexChecksum
8576 IntelHexCheckOk
8578 IntelHexPrintStatus
8583 IntelHexPrintEndMsg
8595 IntelHexPrintNotOk
85A8 IntelHexAbort
85B0 IntelHexUnsupported
85BE IntelHexParamError
85C6 IntelHexPrintHelp
85CC IntelHexEnd
85D3 ListCmd
85E2 PeekCmd
85E8 PeekAddress
85F4 PeekDefault
85F8 PeekRead
860D PeekEnd
8611 PokeCmd
8617 PokeAddress
8625 PokeByte
862F PokeWrite
8647 PokeNoParameter
864A PokeEnd
864E Registers
873C FlagSignClear
8748 FlagZeroClear
8754 FlagHalfClear
8760 FlagOverClear
876C FlagNegativeClear
8778 FlagCarryClear
8788 RunCode
8798 RunCallBC
879A RunEnd
879B SetAddress
87B1 SetAddressDefault
87B7 SetAddressEnd
87BC SetBank
87DC SetBankDefault
87E5 SetBankError
87E8 SetBankEnd
87ED SysInfo
880A Write
8811 WriteGetAddress
881D WriteFirstByte
8831 WriteRemainingBytes
8847 WriteTooManyDigits
8852 WriteNoParameter
8855 WriteEnd
885A ZeroAllRam
8860 ZeroLowRange
8881 ZeroHighRange
889A ZeroEnd
889F CommandPrompt
88BF DecErrorPointer
88C9 GetHexParameter
88CF GetParamCount
88E0 GetParamFetch
88E5 GetParamFetch0
88ED GetParamFetch1
88FD GetParamFetch2
890B GetParamFetch3
8921 GetParamFetch4
892C GetParameterEnd
892E GetParamHelp
8933 GetParamNumberError
8935 GetErrorPointerLoop
8942 GetParamHexError
8948 GetParamErrorEnd
894A IncErrorPointer
8954 Parser
896E ParseNextChar
8986 ParseNextCmd
8997 ParseValidate
89A0 ParseExecute
89AF ParseInvalid
89B5 ParseEnd
89BC PrintErrorPointer
89C2 PrintErrorLoop
89D4 RangeValidation
89E2 ValCheckInverted
89F2 ValCheckLowLimit
8A03 ValCheckLowLimit2
8A0F ValCheckHighLimit
8A20 ValCheckHighLimit2
8A2C ValCheckBiosLow
8A37 ValCheckBiosHi
8A45 ValCheckHigh
8A6B ValCheckHighBios
8A79 ValCheckLow
8A93 ValCheckLowBios
8A9C ValBiosOverlap
8AB8 ValCheckIfZeroDataLow
8AC8 ValCheckIfZeroDataHigh
8AD8 ValPrintRange
8ADB ValPrintRange1
8AF5 ValPrintRange2
8B0F ValPrintRangeEnd
8B15 ValBiosRangeError
8B1B ValRangeTooSmallError
8B21 ValInvertedError
8B27 RangeValidationError
8B2B RangeValidationEnd
8B2F ResetErrorPointer
8B37 SkipSpaces
8B38 SkipSpacesLoop
8B43 SkipSpacesEnd
8B45 BASIC
8B4E ColdOrWarm
8B54 CheckIfCold
8B61 CheckIfWarm
8B6E SignOnMsg
8BCA COLD
8BD5 CSTART
8BDC INIT
8BE4 COPYY
8BF9 MSIZE
8C0C MLOOP
8C1E TSTMEM
8C30 SETTOP
8C68 WARM
8C6B BRKRET
8C71 BFREE
8C80 SIGNON
8CB6 MEMMSG
8CC1 FNCTAB
8CF9 WORDS
8E1C WORDTB
8E68 PRITAB
8E7D ERRORS
8EA7 INITAB
8F07 ERRMSG
8F07 INITBE
8F0E INMSG
8F12 ZERBYT
8F13 OKMSG
8F19 BRKMSG
8F1F BAKSTK
8F23 LOKFOR
8F39 INDFND
8F42 MOVUP
8F45 MOVSTR
8F48 MOVLP
8F53 CHKSTK
8F5C ENFMEM
8F6B OMERR
8F70 DATSNR
8F76 SNERR
8F79 DZERR
8F7C NFERR
8F7F DDERR
8F82 UFERR
8F85 OVERR
8F88 TMERR
8F8A ERROR
8FAA ERRIN
8FC0 POPNOK
8FC1 PRNTOK
8FCE GETCMD
9007 LINFND
900F SFTPRG
901E INEWLN
903D MOVBUF
9045 SETPTR
904A PTRLP
9056 FNDEND
9062 SRCHLN
9065 SRCHLP
9082 NEW
9083 CLRPTR
908E RUNFST
9092 INTVAR
90A8 CLREG
90C1 DOAGN
90C5 PROMPT
90D2 CRUNCH
90DB CRNCLP
9105 FNDWRD
911E SEARCH
9120 GETNXT
9130 NXTBYT
9141 NOSPC
914A NOCHNG
9152 MATCH
9156 RETNAD
915A MOVDIR
9168 SETLIT
916B TSTREM
9171 NXTCHR
917A CPYLIT
9181 ENDBUF
918A DODEL
919E ECHDEL
91AA DELCHR
91B2 OTKLN
91B5 KILIN
91BB TTYLIN
91BB GETLIN
91C4 MORINP
91DD PROCES
921C PUTBUF
9221 PUTCTL
9230 OUTIT
9236 OUTNBS
923E CPDEHL
9244 CHKSYN
924F OUTC
926F INCLEN
9273 DINPOS
9279 CLOTST
928A LISTT
9296 LISTLP
92B6 LSTLP2
92B9 LSTLP3
92C8 FNDTOK
92D2 OUTWRD
92E0 SETLIN
92E9 COUNT
930C RSLNBK
9315 FOR
9329 FORSLP
9345 FORFND
9381 SAVSTP
938A PUTFID
938E RUNCNT
93AE EXCUTE
93B5 IFJMP
93B6 ONJMP
93CE GETCHR
93DE RESTOR
93F3 RESTNL
93F4 UPDATA
93F9 TSTBRK
9408 STALL
9414 BRK
9419 STOPP
941B PEND
9420 INPBRK
9423 ENDPRG
9436 NOLIN
9447 CONT
945A NULLL
9462 ACCSUM
946F CHKLTR
9477 FPSINT
947A POSINT
947D DEPINT
9483 DEINT
9498 FCERR
949D ATOH
949E GETLN
94A1 GTLNLP
94C2 CLEAR
94E5 STORED
9508 RUN
9514 GOSUB
9524 RUNLIN
9525 GOTO
953E ULERR
9543 RETURN
9562 RETLIN
9567 NXTDTA
9568 DATAA
956A REM
956E NXTSTL
9571 NXTSTT
957F LET
959A LETSTR
95C1 CRESTR
95C9 MVSTPT
95D2 LETNUM
95D9 ON
95E8 ONGO
95E9 ONGOLP
95F7 IFF
9605 IFGO
9617 MRPRNT
961B PRINTT
961E PRNTLP
9661 PRNTNB
9665 PRNTST
966C STTLIN
9674 ENDINP
967C DONULL
9683 NULLP
968E DOCOM
969C ZONELP
96A5 DOTAB
96B8 DOSPC
96BD ASPCS
96C1 SPCLP
96C8 NEXITM
96CF REDO
96E2 BADINP
96F3 INPUT
970D NOPMPT
9722 READ
9727 NXTITM
972F NEDMOR
9733 GTVLUS
975B ANTVLU
9776 ITMSEP
9779 STRENT
9785 INPBIN
9790 LTSTND
979C MORDT
97B7 EXTIG
97C8 FDTLP
97E1 FANDT
97EC NEXT
97EF NEXT1
9827 KILFOR
9837 GETNUM
983A TSTNUM
983B TSTSTR
983C CHKTYP
9845 OPNPAR
9849 EVAL
984C EVAL1
9855 EVAL2
9858 EVAL3
9865 RLTLP
9881 FOPRND
98A9 STKTHS
98C0 OPRND
98EB NOTAMP
990E EVLPAR
9916 MINUS
9922 RETNUM
9927 CONVAR
992A FRMEVL
9938 FNOFST
995F FNVAL
9967 GOFUNC
9970 SGNEXP
9980 POR
9981 PAND
99A3 POR1
99A8 TSTRED
99BA CMPLOG
99BC CMPLG1
99E6 CMPSTR
99FE CMPRES
9A08 EVNOT
9A1F DIMRET
9A28 DIM
9A2D GETVAR
9A32 GTFNAM
9A49 SVNAM2
9A4A ENDNAM
9A56 CHARTY
9A65 NOTSTR
9A75 NSCFOR
9A8F FNDVAR
9A9D FNTHR
9AA8 CFEVAL
9ACE ZEROLP
9ADC RETADR
9ADF RETNUL
9AEA SBSCPT
9AF0 SCPTLP
9B12 ARLDSV
9B18 FNDARY
9B2C NXTARY
9B45 BSERR
9B4A CREARY
9B65 CRARLP
9B6D DEFSIZ
9B8B ZERARY
9BA8 FINDEL
9BAD FNDELP
9BCC ENDDIM
9BD0 FRE
9BEC FRENUM
9BF1 ACPASS
9BF2 ABPASS
9BFE POS
9C01 PASSA
9C06 DEF
9C33 DOFN
9C7B IDTEST
9C89 CHEKFN
9C9A STRR
9CA0 STR1
9CAA SAVSTR
9CBF MKTMST
9CC2 CRTMST
9CC8 SVSTAD
9CCE CRTST
9CCF QTSTR
9CD2 DTSTR
9CD5 QTSTLP
9CE4 CRTSTE
9CF0 TSTOPL
9D0F PRNUMS
9D10 PRS
9D13 PRS1
9D1A PRSLP
9D29 TESTR
9D2B GRBDON
9D45 POPAF
9D47 TESTOS
9D53 GARBGE
9D56 GARBLP
9D64 GRBLP
9D75 SMPVAR
9D8A GNXARY
9D8B ARRLP
9DAA GRBARY
9DB8 STPOOL
9DBB STRADD
9DE1 SCNEND
9E06 CONCAT
9E3D SSTSA
9E46 TOSTRA
9E47 TSALP
9E50 GETSTR
9E53 GSTRCU
9E56 GSTRHL
9E57 GSTRDE
9E6F POPHL
9E71 BAKTMP
9E82 LEN
9E86 GETLEN
9E91 ASCC
9E95 GTFLNM
9EA2 CHR
9EAE TOPOOL
9EB2 LEFT
9EB6 RIGHT1
9EB8 MID1
9EC0 ALLFOL
9EE2 RIGHT
9EEC MID
9F05 RSTSTR
9F1C VAL
9F3A VAL1
9F44 VAL2
9F47 VAL3
9F4B LFRGNM
9F50 MIDNUM
9F55 INP
9F61 POUT
9F67 WAIT
9F7B NOXOR
9F7C WAITLP
9F85 SETIO
9F95 FNDNUM
9F98 GETINT
9F9B MAKINT
9FA9 PEEK
9FB0 POKE
9FC1 ROUND
9FC4 ADDPHL
9FCA SUBPHL
9FCE PSUB
9FD0 SUBCDE
9FD3 FPADD
9FED NOSWAP
A013 MINCDE
A021 CONPOS
A024 BNORM
A027 BNRMLP
A039 RESZER
A03A SAVEXP
A03E NORMAL
A046 PNORM
A059 RONDUP
A05A RONDB
A06B FPROND
A078 PLUCDE
A084 COMPL
A098 SCALE
A09A SCALLP
A0A7 SHRITE
A0AA SHRLP
A0AE SHRT1
A0BC UNITY
A0C0 LOGTAB
A0CD LOG
A105 MULLN2
A10C MULTT
A10E FPMULT
A130 MULT8
A139 MUL8LP
A14A NOMADD
A15A POPHRT
A15C BYTSFT
A161 DIV10
A16D DIV
A16F DVBCDE
A194 DIVLP
A1A7 RESDIV
A1D7 ADDEXP
A1F5 OVTST1
A1FA OVTST2
A1FB OVTST3
A202 MLSP10
A219 TSTSGN
A222 RETREL
A224 FLGDIF
A228 SGN
A22B FLGREL
A230 RETINT
A23E ABS
A242 INVSGN
A24A STAKFP
A257 PHLTFP
A25A FPBCDE
A265 BCDEFP
A268 LOADFP
A26F INCHL
A271 FPTHL
A274 DETHL4
A276 DETHLB
A27F SIGNS
A294 CMPNUM
A2AE CMPFP
A2C1 FPINT
A2E5 DCBCDE
A2EC INT
A305 MLDEBC
A30D MLDBLP
A31B NOMLAD
A320 ASCTFP
A32C CNVNUM
A334 MANLP
A34A EXPLP
A358 DPOINT
A35C CONEXP
A35F SCALMI
A36B ENDCON
A375 SCALPL
A376 MULTEN
A37D ADDIG
A394 RSCALE
A39A PADD
A39F EDIGIT
A3AB LINEIN
A3B3 PRNTHL
A3BE NUMASC
A3CC SPCFST
A3DB SIXDIG
A3F0 GTSIXD
A3F9 INRNG
A415 MAKNUM
A426 DIGTXT
A435 TRYAGN
A45A SUPTLZ
A466 DOEBIT
A476 OUTEXP
A478 EXPTEN
A482 JSTZER
A485 NOENED
A488 RNGTST
A497 HALF
A49B POWERS
A4AD NEGAFT
A4B2 SQR
A4BB POWER
A4CB POWER1
A4E8 POWER2
A500 EXPP
A540 EXPTAB
A561 SUMSER
A570 SMSER1
A579 SUMLP
A591 RND
A5CD RND1
A5E9 RND2
A5F2 RESEED
A5FA RNDTAB
A606 COS
A60C SIN
A63C SIN1
A650 HALFPI
A654 QUARTR
A658 SINTAB
A66D TAN
A682 ATN
A69F ATN1
A6A9 ATNTAB
A6CE ARET
A6CF GETINP
A6D3 CLS
A6D6 WIDTH
A6DE LINES
A6ED DEEK
A6F8 DOKE
A70F HEX
A728 HEX1
A72A HEX2
A738 HEX3
A73A HEX4
A747 BYT2ASC
A750 ADD30
A764 ADD301
A768 HEXTFP
A774 HEXLP
A779 HEXLP1
A781 GETHEX
A794 NOSUB7
A798 HEXIT
A7A1 HXERR
A7A6 BIN
A7AC BIN2
A7B2 ZEROSUP
A7C0 BITOUT
A7C4 BITOUT2
A7D8 BINTFP
A7E2 BINIT
A7F5 CHKBIN
A803 BINERR
A808 JJUMP1
A80F MONOUT
A812 MONITR
A815 INITST
A81D ARETN
A81F TSTBIT
A826 OUTNCR
A82C EXIT
A82F BootMsg
A8B8 CommandList
A932 ListOfCommands
AB87 FlagBits
AB8D ClearScreenSeq
AB9A SysInfoMsg
AC5F ParseInvalidErr
AC85 InvalidHexDigitErr
ACAE TooManyDigitsErr
ACD7 MissingParameterErr
ACEE UnrecognizedParamErr
AD07 StartGreaterEndErr
AD28 IntelHexUnsupportedErr
AD42 InvalidVectorRangeErr
AD5F ReservedBiosAreaErr
AD75 RangeTooSmallErr
AD92 InvalidBankNumberErr
ADB0 InvalidDecimalNumberErr
ADC9 NumberOutOfRangeErr
ADE2 BadMemory1Err
ADEC BadMemory2Err
ADFF NothingToCopyErr
AE11 TestingBankNumberMsg
AE24 TestingHighRamMsg
AE37 MemoryTestPassedMsg
AE4C RangeMsg
AE5B IntelHexFinishedMsg
AE6B IntelHexSuccessMsg
AE7A IntelHexLoadMsg
AEB7 IntelHexAbortedMsg
AED2 DownloadedBytesMsg
AEE6 FillHelp
AF51 HexDumpHelp
AFB6 IntelHexHelp
AFF9 Range
B002 InvalidVectorRange
B00B RangeTooSmall
B014 BiosRange
B01D RangeInverted
B026 NoParameter
B032 InvalidBank
B03B TooManyDigits
B044 InvalidHexDigit
B04D NumberOutOfRange
B056 InvalidDecimalNumber
B05F NothingToCopy
B06E CommandBuffer
B08C BufferPointer
B08E CmdErrorPointer
B08F CurrentBank
B090 CurrentAddress
B092 DigitString
B09B ParseSaveHL
B09D RegA
B09E RegBC
B0A0 RegDE
B0A2 RegHL
B0A4 RegIX
B0A6 RegIY
B0A8 StackPtr
B0AA FlagsReg
B0AB StartAddress
B0AD EndAddress
B0AF StartAddressAlt
B0B1 EndAddressAlt
B0B3 ByteTransfer
B0B4 UserCodeSize
B0B6 EndOfCode
CBCA BytesFree
FD00 VectorTable
FD00 IntVectorEnd
FD02 VectorTableStart
FD04 CodeStartAddr
FD06 CodeEndAddr
FE00 JumpTable
FE3F VectorEnd
FF00 StackPage
FFFF BiosEnd
