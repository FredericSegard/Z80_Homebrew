Sections:
00: "seg0" (0-8000)
01: "seg8000" (8000-FD00)
02: "segfd00" (FD00-FE00)
03: "segfe00" (FE00-FF00)
04: "segff00" (FF00-FFFF)


Source: "main.asm"
                        	     1: ; --------------------------------------------------------------------------------------------------------------
                        	     2: ;         :::::::::     ::::::::       :::::::            :::::::::     :::::::::::     ::::::::       :::::::: 
                        	     3: ;             :+:     :+:    :+:     :+:   :+:           :+:    :+:        :+:        :+:    :+:     :+:    :+: 
                        	     4: ;           +:+      +:+    +:+     +:+   +:+           +:+    +:+        +:+        +:+    +:+     +:+         
                        	     5: ;         +#+        +#++:++#      +#+   +:+           +#++:++#+         +#+        +#+    +:+     +#++:++#++   
                        	     6: ;       +#+        +#+    +#+     +#+   +#+           +#+    +#+        +#+        +#+    +#+            +#+    
                        	     7: ;     #+#         #+#    #+#     #+#   #+#           #+#    #+#        #+#        #+#    #+#     #+#    #+#     
                        	     8: ;   #########     ########       #######            #########     ###########     ########       ########       
                        	     9: ; ------------------------------------------------------------------------------------------------------
                        	    10: 
                        	    11: ; *********************************************************************************************************************
                        	    12: ; * Z80 Project by Frédéric Segard, a.k.a. MicroHobbyist
                        	    13: ; * https://www.youtube.com/@microhobbyist
                        	    14: ; * https://github.com/FredericSegard
                        	    15: ; *
                        	    16: ; * Copyright (C) 2023 Frédéric Segard
                        	    17: ; *
                        	    18: ; * This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
                        	    19: ; * Public License as published by the Free Software Foundation. You can use all or part of the code, regardless of
                        	    20: ; * the version. But there is no warrenty of any kind.
                        	    21: ; *
                        	    22: ; * Reference:	ASCII text: https://www.messletters.com/en/big-text/ (alligator, standard)
                        	    23: ; *				Editor tab-stops set to 4
                        	    24: ; *				Assembler: VASM  (BIN: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fbin -o %1.out -L %1.txt)
                        	    25: ; *								 (HEX: vasmz80_oldstyle -dotdir -chklabels -nocase %1.asm -Fihex)
                        	    26: ; * Version 0.7
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: 
                        	    30: ;   ____                         _                     _         
                        	    31: ;  / ___|   ___    _ __    ___  | |_    __ _   _ __   | |_   ___ 
                        	    32: ; | |      / _ \  | '_ \  / __| | __|  / _` | | '_ \  | __| / __|
                        	    33: ; | |___  | (_) | | | | | \__ \ | |_  | (_| | | | | | | |_  \__ \
                        	    34: ;  \____|  \___/  |_| |_| |___/  \__|  \__,_| |_| |_|  \__| |___/
                        	    35: ;
                        	    36: ; ---------------------------------------------------------------------------------------------------------------------
                        	    37: ; VARIOUS CONSTANTS AND ADDRESSES USED IN THE CODE
                        	    38: 
                        	    39: ; GENERAL EQUATES
                        	    40: NULL			= $00
                        	    41: CTRLC			= $03				; Control-C (Break)
                        	    42: CTRLG			= $07				; Control-G (Bell)
                        	    43: BKSP			= $08				; Backspace
                        	    44: TAB				= $09				; Horizontal tab
                        	    45: LF				= $0A				; Line-feed character
                        	    46: CS				= $0C				; Clear Screen
                        	    47: CR				= $0D				; Carriage-return character
                        	    48: CTRLO			= $0F				; Control "O"
                        	    49: CTRLQ			= $11				; Control "Q"
                        	    50: CTRLR			= $12				; Control "R"
                        	    51: CTRLS			= $13				; Control "S"
                        	    52: CTRLU			= $15				; Control "U"
                        	    53: ESC				= $1B				; Escape
                        	    54: SPACE			= $20				; Space character
                        	    55: DEL				= $7F				; Delete
                        	    56: 
                        	    57: DELIMITER		= " "				; Space delimiter between command line parameters
                        	    58: ERRORPTR		= "^"				; Error pointer symbol (used for pointing to the error position on command line)
                        	    59: QUOTE			= $22
                        	    60: JUMP			= $C3				; Delimiter for command list items (It's the actual jp command opcode)
                        	    61: HELP			= $0F
                        	    62: EOT				= $FF				; End of table
                        	    63: 
                        	    64: ;PARAMETERS
                        	    65: HorizTextRes	= 40				; Horizontal text resolution (40 or 80)
                        	    66: VertTextRes		= 24				; Vertical text resolution (typical 24 or 25)
                        	    67: ErrorPtrOffset	= 8					; Take into account the command prompt width
                        	    68: BytesFree		= (VectorTable-EndOfCode)+(StartOfCode-InterruptVectorEnd)	; Base free bytes
                        	    69: 
                        	    70: ; I/O ADDRESSES
                        	    71: SIO_PortA_Data	= $00				; SIO data port A
                        	    72: SIO_PortB_Data	= $01				; SIO data port B
                        	    73: SIO_PortA_Ctrl	= $02				; SIO control port A
                        	    74: SIO_PortB_Ctrl	= $03				; SIO control port B
                        	    75: ClockSelect		= $28				; Clock speed selection address (values $00 to $03)
                        	    76: BankSelect		= $30				; RAM bank select address (values ($00 to $0E)
                        	    77: RomDisable		= $38				; ROM dissable address (any value)
                        	    78: 
                        	    79: ; STATUS INDICATOR FLAGS (BIT NUMBER... 3 and 5 are not used
                        	    80: Carry			= 0					; (F) Carry flag
                        	    81: Negative		= 1					; (N) Add/substract flag
                        	    82: Parity			= 2					; (P) Parity flag (Same bit position as bellow, depends on the instruction)
                        	    83: Overflow		= 2					; (V) Overflow flag (Same bit position as above, depends on the instruction)
                        	    84: HalfCarry		= 4					; (H) Half-carry flag
                        	    85: Zero			= 6					; (Z) Zero flag
                        	    86: Sign			= 7					; (S) Sign flag
                        	    87: 
                        	    88: 
                        	    89: ;  ___           _                                          _    __     __                _                        
                        	    90: ; |_ _|  _ __   | |_    ___   _ __   _ __   _   _   _ __   | |_  \ \   / /   ___    ___  | |_    ___    _ __   ___ 
                        	    91: ;  | |  | '_ \  | __|  / _ \ | '__| | '__| | | | | | '_ \  | __|  \ \ / /   / _ \  / __| | __|  / _ \  | '__| / __|
                        	    92: ;  | |  | | | | | |_  |  __/ | |    | |    | |_| | | |_) | | |_    \ V /   |  __/ | (__  | |_  | (_) | | |    \__ \
                        	    93: ; |___| |_| |_|  \__|  \___| |_|    |_|     \__,_| | .__/   \__|    \_/     \___|  \___|  \__|  \___/  |_|    |___/
                        	    94: ;                                                  |_|                                                             
                        	    95: ; ---------------------------------------------------------------------------------------------------------------------
                        	    96: ; RESET AND INTERRUPT VECTORS (8-BYTE VECTORS EACH)
                        	    97: 
                        	    98: 	.org	$0000
                        	    99: 	
                        	   100: RST00:								; Reset vector 0: Standard boot up reset vector
00:0000 C38000          	   101: 	jp		ShadowCopy				; Shadow copy BIOS and vectors
00:0003 FF              	   102: 	ds		$0008-$,$FF
00:0004 *
                        	   103: 
                        	   104: RST08:								; Reset Vector 1
00:0008 76              	   105: 	halt
00:0009 FF              	   106: 	ds		$0010-$,$FF
00:000A *
                        	   107: 
                        	   108: RST10:								; Reset Vector 2
00:0010 76              	   109: 	halt
00:0011 FF              	   110: 	ds		$0018-$,$FF
00:0012 *
                        	   111: 	
                        	   112: RST18:								; Reset Vector 3
00:0018 76              	   113: 	halt
00:0019 FF              	   114: 	ds		$0020-$,$FF
00:001A *
                        	   115: 
                        	   116: RST20:								; Reset Vector 4
00:0020 76              	   117: 	halt
00:0021 FF              	   118: 	ds		$0028-$,$FF
00:0022 *
                        	   119: 
                        	   120: RST28:								; Reset Vector 5
00:0028 76              	   121: 	halt
00:0029 FF              	   122: 	ds		$0030-$,$FF
00:002A *
                        	   123: 
                        	   124: RST30:								; Reset Vector 6
00:0030 76              	   125: 	halt
00:0031 FF              	   126: 	ds		$0038-$,$FF
00:0032 *
                        	   127: 
                        	   128: RST38:								; Reset vector 7: Interrupt Mode 1
00:0038 76              	   129: 	halt
00:0039 FF              	   130: 	ds		$0066-$,$FF
00:003A *
                        	   131: 
                        	   132: NMI66:								; Non-masquable interreupt vector
00:0066 76              	   133: 	halt
00:0067 FF              	   134: 	ds		$0080-$,$FF
00:0068 *
                        	   135: 
                        	   136: InterruptVectorEnd:
                        	   137: 
                        	   138: 
                        	   139: ;  ____    _                   _                         ____                         
                        	   140: ; / ___|  | |__     __ _    __| |   ___   __      __    / ___|   ___    _ __    _   _ 
                        	   141: ; \___ \  | '_ \   / _` |  / _` |  / _ \  \ \ /\ / /   | |      / _ \  | '_ \  | | | |
                        	   142: ;  ___) | | | | | | (_| | | (_| | | (_) |  \ V  V /    | |___  | (_) | | |_) | | |_| |
                        	   143: ; |____/  |_| |_|  \__,_|  \__,_|  \___/    \_/\_/      \____|  \___/  | .__/   \__, |
                        	   144: ;                                                                      |_|      |___/ 
                        	   145: ; ---------------------------------------------------------------------------------------------------------------------
                        	   146: ; SHADOW COPY VECTORS AND BIOS FROM FLASH TO RAM
                        	   147: 
                        	   148: ShadowCopy:
00:0080 F3              	   149: 	di								; Disable interrupts
                        	   150: 	
                        	   151: ; COPY INTERRUPT VECTORS TO ALL BANKS
00:0081 3E0E            	   152: 	ld		A,$0E					; Starting bank number
                        	   153: BankCopyLoop:						; Loop to copy reset vectors to all banks
00:0083 D330            	   154: 	out		(BankSelect),A			; Sets bank number to value in accumulator
                        	   155: 	; Perform vector copy
00:0085 210000          	   156: 	ld      HL,$0000				; Set start at address $0000 (ROM)
00:0088 110000          	   157: 	ld      DE,$0000				; Set destination address (RAM)
00:008B 018000          	   158: 	ld      BC,InterruptVectorEnd	; Set counter to copy the interrupt vector table only
00:008E EDB0            	   159: 	ldir							; Copy, paste, and repeat, until the end of BC has been reached
                        	   160: 	; Check for next iteration
00:0090 3D              	   161: 	dec		A						; Decrement accumulator to move on to next bank
00:0091 FEFF            	   162: 	cp		$FF						; Has accumulator reached the end of the loop (past zero)?
00:0093 20EE            	   163: 	jr		nz,BankCopyLoop			; If not then do next bank the loop, else Bank 0 is already pre-selected
00:0095 3289B0          	   164: 	ld		(CurrentBank),A			; Save Current Bank
                        	   165: 
                        	   166: ; COPY THE BIOS TO RAM
                        	   167: ROMCopy:
00:0098 210080          	   168:     ld      HL,StartOfCode			; Source address
00:009B 110080          	   169:     ld      DE,StartOfCode			; Destination address
00:009E 01B230          	   170:     ld      BC,EndOfCode-StartOfCode; Bytes to copy
00:00A1 EDB0            	   171:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   172: 
                        	   173: ; COPY THE VECTORS AND BLANK STACK TO RAM
                        	   174: VectorCopy:
00:00A3 2100FD          	   175:     ld      HL,VectorTable			; Source address
00:00A6 1100FD          	   176:     ld      DE,VectorTable			; Destination address
00:00A9 01FF02          	   177:     ld      BC,$FFFF-VectorTable	; Bytes to copy
00:00AC EDB0            	   178:     ldir							; Copy, paste, and repeat, until the range has been reached
                        	   179: 
00:00AE C30080          	   180: 	jp		StartOfCode
                        	   181: 
00:00B1 FF              	   182: 	ds		StartOfCode-$,$FF		; Fill the rest of memory to start of code with $FF for fast FLASH programming
00:00B2 *
                        	   183: 
                        	   184: 
                        	   185: ;  ___           _   _     _           _   _              
                        	   186: ; |_ _|  _ __   (_) | |_  (_)   __ _  | | (_)  ____   ___ 
                        	   187: ;  | |  | '_ \  | | | __| | |  / _` | | | | | |_  /  / _ \
                        	   188: ;  | |  | | | | | | | |_  | | | (_| | | | | |  / /  |  __/
                        	   189: ; |___| |_| |_| |_|  \__| |_|  \__,_| |_| |_| /___|  \___|
                        	   190: ;
                        	   191: ; ---------------------------------------------------------------------------------------------------------------------
                        	   192: ; START OF CODE
                        	   193: 
                        	   194: 	.org	$8000					; Start of code at beginning of high memory
                        	   195: 
                        	   196: StartOfCode:
01:8000 D338            	   197: 	out		(RomDisable),A			; Disable the ROM
01:8002 31FFFF          	   198: 	ld      SP,$FFFF				; Set top of stack pointer to page FF
                        	   199: 	
01:8005 CD4B81          	   200: 	call	SIO_Init				; Initializes the SIO
                        	   201: 
                        	   202: 	; Print Boot message with bytes free
01:8008 CDAA82          	   203: 	call	ClearScreen				; Clear the terminal screen (with ANSI codes)
01:800B 2129A8          	   204: 	ld		HL,BootMsg
01:800E CDAE80          	   205: 	call	PrintString				; Print first line of boot message
01:8011 CD8C80          	   206: 	call	PrintLine				; Print a separator line
01:8014 CDAE80          	   207: 	call	PrintString				; Print second line of boot message
01:8017 E5              	   208: 	push	HL
01:8018 21CECB          	   209: 	ld		HL,BytesFree			; Load the amount of bytes free
01:801B CD5880          	   210: 	call	PrintDec
01:801E E1              	   211: 	pop		HL
01:801F CDAE80          	   212: 	call	PrintString
                        	   213: 
01:8022 210000          	   214: 	ld		HL,$0000				; Set default current address
01:8025 228AB0          	   215: 	ld		(CurrentAddress),HL		; Save in CurrentAddress variable
01:8028 3E00            	   216: 	ld		A,0
01:802A D330            	   217: 	out		(BankSelect),A			; Set the bank to number 0
01:802C 3289B0          	   218: 	ld		(CurrentBank),A			; Save the Current Bank
                        	   219: 
                        	   220: 	; Clear the registers
01:802F 3E00            	   221: 	ld		A,0
01:8031 010000          	   222: 	ld		BC,0
01:8034 110000          	   223: 	ld		DE,0
01:8037 210000          	   224: 	ld		HL,0
01:803A DD210000        	   225: 	ld		IX,0
01:803E FD210000        	   226: 	ld		IY,0
01:8042 C5              	   227: 	push	BC						; LSB to clear the flag
01:8043 F1              	   228: 	pop		AF						; Clear flag
                        	   229: 
                        	   230: ;	ei								; Enable interrupts
                        	   231: 
                        	   232: 
                        	   233: ;  __  __           _         
                        	   234: ; |  \/  |   __ _  (_)  _ __  
                        	   235: ; | |\/| |  / _` | | | | '_ \ 
                        	   236: ; | |  | | | (_| | | | | | | |
                        	   237: ; |_|  |_|  \__,_| |_| |_| |_|
                        	   238: ;
                        	   239: ; ----------------------------
                        	   240: ; MAIN LOOP
                        	   241: 
                        	   242: Main:
01:8044 CD9F88          	   243: 	call	CommandPrompt			; Print the command prompt (0000>)
                        	   244: 	
01:8047 C5              	   245: 	push	BC
01:8048 E5              	   246: 	push	HL
                        	   247: 	
01:8049 061E            	   248: 	ld		B,30					; Set the maximum number of bytes to read
01:804B 2168B0          	   249: 	ld		HL,CommandBuffer		; Set the memory area to read the string to
01:804E CDEE80          	   250: 	call	ReadString				; Read a string from console (HL is the address of buffer, BC is character count)
                        	   251: 	
01:8051 E1              	   252: 	pop		HL
01:8052 C1              	   253: 	pop		BC
                        	   254: 	
01:8053 CD5489          	   255: 	call	Parser					; Parse the entered command
                        	   256: 	
01:8056 18EC            	   257: 	jr		Main
                        	   258: 
                        	   259: 
                        	   260: ;  ____            _                              _     _                      
                        	   261: ; / ___|   _   _  | |__    _ __    ___    _   _  | |_  (_)  _ __     ___   ___ 
                        	   262: ; \___ \  | | | | | '_ \  | '__|  / _ \  | | | | | __| | | | '_ \   / _ \ / __|
                        	   263: ;  ___) | | |_| | | |_) | | |    | (_) | | |_| | | |_  | | | | | | |  __/ \__ \
                        	   264: ; |____/   \__,_| |_.__/  |_|     \___/   \__,_|  \__| |_| |_| |_|  \___| |___/
                        	   265: ;
                        	   266: ; ---------------------------------------------------------------------------------------------------------------------
                        	   267: ; ALL SUBROUTINES ARE EMBEDED IN VARIOUS INCLUDE FILES
                        	   268: 
                        	   269: 	.include	"io.asm"			; Input and output subroutines

Source: "io.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- PrintChar		[A ->]
                        	     4: ;	- PrintString	[HL ->]
                        	     5: ;	- PrintCRLF
                        	     6: ;	- PrintNibble	[A ->]
                        	     7: ;	- PrintByte		[A ->]
                        	     8: ;	- PrintWord		[HL ->]
                        	     9: ;	- ReadChar		[-> A]
                        	    10: ;	- ReadString	[HL ->]
                        	    11: ;	- ReadByte		[-> A]
                        	    12: ;	- ReadWord		[-> HL]
                        	    13: ;	- SIO_Init
                        	    14: 
                        	    15: 
                        	    16: ;  ____           _           _     ____                
                        	    17: ; |  _ \   _ __  (_)  _ __   | |_  |  _ \    ___    ___ 
                        	    18: ; | |_) | | '__| | | | '_ \  | __| | | | |  / _ \  / __|
                        	    19: ; |  __/  | |    | | | | | | | |_  | |_| | |  __/ | (__ 
                        	    20: ; |_|     |_|    |_| |_| |_|  \__| |____/   \___|  \___|
                        	    21: ;
                        	    22: ;
                        	    23: ; *********************************************************************************************************************
                        	    24: ; Prints a hex number to Decimal on the console
                        	    25: ;	- Input:	HL = 16-bit hex number
                        	    26: ;	- Ouput:	HL = Untouched 16-bit hex number
                        	    27: ; *********************************************************************************************************************
                        	    28: 
                        	    29: PrintDec:
01:8058 E5              	    30: 	push	HL
01:8059 CD0C82          	    31: 	call	Hex2Dec
01:805C CDAE80          	    32: 	call	PrintString
01:805F E1              	    33: 	pop		HL
01:8060 C9              	    34: 	ret
                        	    35: 
                        	    36: 
                        	    37: ;  ____           _           _     ____            _          
                        	    38: ; |  _ \   _ __  (_)  _ __   | |_  | __ )   _   _  | |_    ___ 
                        	    39: ; | |_) | | '__| | | | '_ \  | __| |  _ \  | | | | | __|  / _ \
                        	    40: ; |  __/  | |    | | | | | | | |_  | |_) | | |_| | | |_  |  __/
                        	    41: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__, |  \__|  \___|
                        	    42: ;                                           |___/              
                        	    43: ;
                        	    44: ; *********************************************************************************************************************
                        	    45: ; Prints a byte to the console
                        	    46: ;	- Input:	A (Byte to print)
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: PrintByte:
01:8061 F5              	    50: 	push	AF
01:8062 F5              	    51: 	push	AF
01:8063 CB3F            	    52: 	srl		A					; Push the uppermost nibble to the lower half
01:8065 CB3F            	    53: 	srl		A
01:8067 CB3F            	    54: 	srl		A
01:8069 CB3F            	    55: 	srl		A
01:806B CD9E80          	    56: 	call	PrintNibble			; Print the first nibble of the byte
01:806E F1              	    57: 	pop		AF
01:806F CD9E80          	    58: 	call	PrintNibble			; Print the second nibble of the byte
01:8072 F1              	    59: 	pop		AF
01:8073 C9              	    60: 	ret
                        	    61: 
                        	    62: 
                        	    63: ;  ____           _           _      ____   _                    
                        	    64: ; |  _ \   _ __  (_)  _ __   | |_   / ___| | |__     __ _   _ __ 
                        	    65: ; | |_) | | '__| | | | '_ \  | __| | |     | '_ \   / _` | | '__|
                        	    66: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | (_| | | |   
                        	    67: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| |_|  \__,_| |_|   
                        	    68: ;
                        	    69: 
                        	    70: ; *********************************************************************************************************************
                        	    71: ; Print a character to the console
                        	    72: ;	- Input: A (Character to transmit)
                        	    73: ; *********************************************************************************************************************
                        	    74: 
                        	    75: PrintChar:
01:8074 F5              	    76: 	push	AF
                        	    77: PrintCharTxWait:
01:8075 DB02            	    78: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in accumulator
01:8077 E604            	    79: 	and		%00000100				; Isolate bit 2: TX Buffer Empty
01:8079 28FA            	    80: 	jr		z,PrintCharTxWait		; If it's busy, then wait
01:807B F1              	    81: 	pop		AF
01:807C D300            	    82: 	out		(SIO_PortA_Data),A		; Transmit the character in accumulator
01:807E C9              	    83: 	ret
                        	    84: 
                        	    85: 
                        	    86: ;  ____           _           _      ____   ____    _       _____ 
                        	    87: ; |  _ \   _ __  (_)  _ __   | |_   / ___| |  _ \  | |     |  ___|
                        	    88: ; | |_) | | '__| | | | '_ \  | __| | |     | |_) | | |     | |_   
                        	    89: ; |  __/  | |    | | | | | | | |_  | |___  |  _ <  | |___  |  _|  
                        	    90: ; |_|     |_|    |_| |_| |_|  \__|  \____| |_| \_\ |_____| |_|    
                        	    91: 
                        	    92: 
                        	    93: ; *********************************************************************************************************************
                        	    94: ; Print a carriage-return and line-feed to serial port A
                        	    95: ; *********************************************************************************************************************
                        	    96: 
                        	    97: PrintCRLF:
01:807F F5              	    98: 	push	AF
01:8080 3E0D            	    99: 	ld		A,CR
01:8082 CD7480          	   100: 	call	PrintChar				; Print carriage-return
01:8085 3E0A            	   101: 	ld		A,LF
01:8087 CD7480          	   102: 	call	PrintChar				; Print line-feed
01:808A F1              	   103: 	pop		AF
01:808B C9              	   104: 	ret
                        	   105: 
                        	   106: 
                        	   107: ;  ____           _           _     _       _                
                        	   108: ; |  _ \   _ __  (_)  _ __   | |_  | |     (_)  _ __     ___ 
                        	   109: ; | |_) | | '__| | | | '_ \  | __| | |     | | | '_ \   / _ \
                        	   110: ; |  __/  | |    | | | | | | | |_  | |___  | | | | | | |  __/
                        	   111: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_| |_| |_|  \___|
                        	   112: 
                        	   113: 
                        	   114: ; *********************************************************************************************************************
                        	   115: ; Prints a line (the size of HorizTextRes)
                        	   116: ; *********************************************************************************************************************
                        	   117: 
                        	   118: PrintLine:
01:808C F5              	   119: 	push	AF
01:808D C5              	   120: 	push	BC
01:808E 3E28            	   121: 	ld		A,HorizTextRes			; Load the screen width constant
01:8090 47              	   122: 	ld		B,A						; Place it register B
01:8091 3E2D            	   123: 	ld		A,"-"					; Load the dash character
                        	   124: PrintLineLoop:
01:8093 CD7480          	   125: 	call	PrintChar				; Print the dash
01:8096 10FB            	   126: 	djnz	PrintLineLoop			; Decrement B, and loop until B is 0
01:8098 CD7F80          	   127: 	call	PrintCRLF				; Change line
01:809B C1              	   128: 	pop		BC
01:809C F1              	   129: 	pop		AF
01:809D C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____           _           _     _   _   _   _       _       _        
                        	   134: ; |  _ \   _ __  (_)  _ __   | |_  | \ | | (_) | |__   | |__   | |   ___ 
                        	   135: ; | |_) | | '__| | | | '_ \  | __| |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	   136: ; |  __/  | |    | | | | | | | |_  | |\  | | | | |_) | | |_) | | | |  __/
                        	   137: ; |_|     |_|    |_| |_| |_|  \__| |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	   138: 
                        	   139: 
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Prints a nibble to the console
                        	   142: ;	- Input:	A (LSB to print)
                        	   143: ; *********************************************************************************************************************
                        	   144: 
                        	   145: PrintNibble:
01:809E F5              	   146: 	push	AF
01:809F E60F            	   147: 	and		$0F						; Filter out MSB
01:80A1 C630            	   148: 	add     "0"						; Add ASCII character 0
01:80A3 FE3A            	   149: 	cp      "9"+1					; Is the value numeric values?
01:80A5 3802            	   150: 	jr		c,PrintNibbleEnd		; Yes, then exit with 0 through 9
01:80A7 C607            	   151: 	add     "A"-"9"-1				; No, then exit with A through F
                        	   152: PrintNibbleEnd:
01:80A9 CD7480          	   153: 	call	PrintChar				; Print the nibble
01:80AC F1              	   154: 	pop		AF
01:80AD C9              	   155: 	ret
                        	   156: 	
                        	   157: 	
                        	   158: ;  ____           _           _     ____    _            _                 
                        	   159: ; |  _ \   _ __  (_)  _ __   | |_  / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   160: ; | |_) | | '__| | | | '_ \  | __| \___ \  | __| | '__| | | | '_ \   / _` |
                        	   161: ; |  __/  | |    | | | | | | | |_   ___) | | |_  | |    | | | | | | | (_| |
                        	   162: ; |_|     |_|    |_| |_| |_|  \__| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   163: ;                                                                    |___/ 
                        	   164: ;
                        	   165: ; *********************************************************************************************************************
                        	   166: ; Prints a string to serial port A, until the null character is reached
                        	   167: ;	- Input:	HL = Address pointer of string to transmit
                        	   168: ;	- Output:	HL = Address pointer to the next character, past NULL (Practical for printing lines in between text)
                        	   169: ; *********************************************************************************************************************
                        	   170: 
                        	   171: PrintString:
01:80AE F5              	   172: 	push	AF
                        	   173: PrintStringLoop:
01:80AF 7E              	   174: 	ld		A,(HL)					; Load character to print in accumulator
01:80B0 23              	   175: 	inc		HL						; Increment HL to next character to print
01:80B1 FE00            	   176: 	cp		0					; Is it the end of the string?
01:80B3 2805            	   177: 	jr		z,PrintStringEnd		; Yes, then exit routine
01:80B5 CD7480          	   178: 	call	PrintChar				; Print the character
01:80B8 18F5            	   179: 	jr		PrintStringLoop			; Repeat the loop until null character is reached
                        	   180: PrintStringEnd:
01:80BA F1              	   181: 	pop		AF
01:80BB C9              	   182: 	ret
                        	   183: 
                        	   184: 
                        	   185: ;  ____           _           _    __        __                     _ 
                        	   186: ; |  _ \   _ __  (_)  _ __   | |_  \ \      / /   ___    _ __    __| |
                        	   187: ; | |_) | | '__| | | | '_ \  | __|  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   188: ; |  __/  | |    | | | | | | | |_    \ V  V /   | (_) | | |    | (_| |
                        	   189: ; |_|     |_|    |_| |_| |_|  \__|    \_/\_/     \___/  |_|     \__,_|
                        	   190: 
                        	   191: 
                        	   192: ; *********************************************************************************************************************
                        	   193: ; Prints a 16-bit word (double-byte) to the console
                        	   194: ;	- Input: HL (Word to print)
                        	   195: ; *********************************************************************************************************************
                        	   196: 
                        	   197: PrintWord:
01:80BC F5              	   198: 	push	AF
01:80BD 7C              	   199: 	ld		A,H						; Get the first byte in accumulator
01:80BE CD6180          	   200: 	call	PrintByte				; Print first byte
01:80C1 7D              	   201: 	ld		A,L						; Get the second byte in accumulator
01:80C2 CD6180          	   202: 	call	PrintByte				; Print second byte
01:80C5 F1              	   203: 	pop		AF
01:80C6 C9              	   204: 	ret
                        	   205: 
                        	   206: 
                        	   207: ;  ____                       _    ____   _                    
                        	   208: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __ 
                        	   209: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__|
                        	   210: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |   
                        	   211: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|   
                        	   212: 
                        	   213: 
                        	   214: ; *********************************************************************************************************************
                        	   215: ; Read a character from the console (waiting)
                        	   216: ;	- Output:	Character received in A
                        	   217: ; *********************************************************************************************************************
                        	   218: 
                        	   219: ReadChar:
01:80C7 DB02            	   220: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80C9 E601            	   221: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80CB 28FA            	   222: 	jr		z,ReadChar				; If there's no character in buffer, loop until one is present
01:80CD DB00            	   223: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80CF C9              	   224: 	ret
                        	   225: 
                        	   226: 
                        	   227: ;  ____                       _    ____   _                      _   _          __        __          _   _   
                        	   228: ; |  _ \    ___    __ _    __| |  / ___| | |__     __ _   _ __  | \ | |   ___   \ \      / /   __ _  (_) | |_ 
                        	   229: ; | |_) |  / _ \  / _` |  / _` | | |     | '_ \   / _` | | '__| |  \| |  / _ \   \ \ /\ / /   / _` | | | | __|
                        	   230: ; |  _ <  |  __/ | (_| | | (_| | | |___  | | | | | (_| | | |    | |\  | | (_) |   \ V  V /   | (_| | | | | |_ 
                        	   231: ; |_| \_\  \___|  \__,_|  \__,_|  \____| |_| |_|  \__,_| |_|    |_| \_|  \___/     \_/\_/     \__,_| |_|  \__|
                        	   232: ;
                        	   233: ;
                        	   234: ; *********************************************************************************************************************
                        	   235: ; Read a character from the console if present (non-waiting)
                        	   236: ;	- Output:	Character in A if received.
                        	   237: ;				A = 0 if no character received.
                        	   238: ;				Z = not ready, NZ = has character
                        	   239: ; *********************************************************************************************************************
                        	   240: 
                        	   241: ReadCharNoWait:
01:80D0 DB02            	   242: 	in		A,(SIO_PortA_Ctrl)		; Read RR0 and place it in the accumulator
01:80D2 E601            	   243: 	and		%00000001				; Isolate bit 1: RX Character Available
01:80D4 3E00            	   244: 	ld		A,$00					; Put nothing in A
01:80D6 C8              	   245: 	ret		z						; Return if not ready
01:80D7 DB00            	   246: 	in		A,(SIO_PortA_Data)		; Read the character and place it in the accumulator
01:80D9 B7              	   247: 	or		A						; Resets the carry flag (and zero)
01:80DA C9              	   248: 	ret
                        	   249: 
                        	   250: 
                        	   251: ;  ____                       _   ____            _          
                        	   252: ; |  _ \    ___    __ _    __| | | __ )   _   _  | |_    ___ 
                        	   253: ; | |_) |  / _ \  / _` |  / _` | |  _ \  | | | | | __|  / _ \
                        	   254: ; |  _ <  |  __/ | (_| | | (_| | | |_) | | |_| | | |_  |  __/
                        	   255: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__, |  \__|  \___|
                        	   256: ;                                         |___/              
                        	   257: ;
                        	   258: ; *********************************************************************************************************************
                        	   259: ; Read a byte (2 ASCII Hex characters) from the console (waiting)
                        	   260: ;	- Output: Byte received in A
                        	   261: ; *********************************************************************************************************************
                        	   262: 
                        	   263: ReadByte:
01:80DB E5              	   264: 	push	HL
01:80DC 218CB0          	   265: 	ld		HL,DigitString			; Point to staging area to convert ASCII Characters to a byte
01:80DF CDC780          	   266: 	call	ReadChar				; Read first character
01:80E2 77              	   267: 	ld		(HL),A					; Store it
01:80E3 23              	   268: 	inc		HL						; Point to the next cell
01:80E4 CDC780          	   269: 	call	ReadChar				; Read second character
01:80E7 77              	   270: 	ld		(HL),A					; Store it
01:80E8 2B              	   271: 	dec		HL						; Point back to the beginning
01:80E9 CD8D81          	   272: 	call	Ascii2HexByte
01:80EC E1              	   273: 	pop		HL
01:80ED C9              	   274: 	ret
                        	   275: 
                        	   276: 
                        	   277: ;  ____                       _   ____    _            _                 
                        	   278: ; |  _ \    ___    __ _    __| | / ___|  | |_   _ __  (_)  _ __     __ _ 
                        	   279: ; | |_) |  / _ \  / _` |  / _` | \___ \  | __| | '__| | | | '_ \   / _` |
                        	   280: ; |  _ <  |  __/ | (_| | | (_| |  ___) | | |_  | |    | | | | | | | (_| |
                        	   281: ; |_| \_\  \___|  \__,_|  \__,_| |____/   \__| |_|    |_| |_| |_|  \__, |
                        	   282: ;                                                                  |___/ 
                        	   283: 
                        	   284: ; *********************************************************************************************************************
                        	   285: ; Read a string from console
                        	   286: ;	- Input:	HL = Points to the memory area to store string
                        	   287: ;				B = Bytes to count
                        	   288: ;	- Output:	HL = Points to the start of string
                        	   289: ; *********************************************************************************************************************
                        	   290: 
                        	   291: ReadString:
01:80EE F5              	   292: 	push	AF
01:80EF C5              	   293: 	push	BC
01:80F0 D5              	   294: 	push	DE
01:80F1 E5              	   295: 	push	HL						; Store the start position
                        	   296: 
01:80F2 0E00            	   297: 	ld		C,0						; Character counter initialized to zero
01:80F4 E5              	   298: 	push	HL						; Save HL's start position...
01:80F5 D1              	   299: 	pop		DE						; in DE for later use
                        	   300: ;	ld		HL,CommandBuffer		; Load CommandBuffer location in HL
                        	   301: 
                        	   302: ; READ A CHARACTER AND VALIDATE
                        	   303: ReadStringChar:	
01:80F6 CDC780          	   304: 	call	ReadChar				; Read a character from console
01:80F9 FE08            	   305: 	cp		BKSP					; Is it the backspace?
01:80FB 281C            	   306: 	jr		z,ReadStringBS			; If it is, then erase last character
01:80FD FE1B            	   307: 	cp		ESC						; Is it the escape key?
01:80FF 2831            	   308: 	jr		z,ReadStringESC			; If it is, then ignore whatever has been entered
01:8101 FE0D            	   309: 	cp		CR						; Is it the carriage return?
01:8103 282E            	   310: 	jr		z,ReadStringCR			; If it is, then end the routine
01:8105 FE80            	   311: 	cp		$80						; Is it a character above or equal to the ASCII value $80?
01:8107 30ED            	   312: 	jr		nc,ReadStringChar		; Loop to get a valid ASCII character
01:8109 FE20            	   313: 	cp		$20						; Is it any other non-printable character?
01:810B 38E9            	   314: 	jr		c,ReadStringChar		; Loop to get a valid ASCII character
                        	   315: 
                        	   316: ; STORE THE CHARACTER IN THE BUFFER
                        	   317: ReadStringSave:
01:810D CD7480          	   318: 	call	PrintChar				; Echo typed character on screen
                        	   319: ;	call	UpperCase				; *** (Optional) *****************************
01:8110 77              	   320: 	ld		(HL),A					; Store character in memory
01:8111 23              	   321: 	inc		HL						; Increment buffer to next spot
01:8112 0C              	   322: 	inc		C						; Increment bytes counter
01:8113 78              	   323: 	ld		A,B						; Load total bytes to read in accumulator
01:8114 B9              	   324: 	cp		C						; Has the total number of characters been read?
01:8115 3802            	   325: 	jr		c,ReadStringBS			; If it was one too many characters, backspace
01:8117 18DD            	   326: 	jr		ReadStringChar			; Else, loop to get the next character
                        	   327: 
                        	   328: ReadStringBS:
01:8119 79              	   329: 	ld		A,C						; Load characther counter in accumulator
01:811A FE00            	   330: 	cp		0						; Are there any characters to erase?
01:811C CAF680          	   331: 	jp		z,ReadStringChar		; No, then go read another character
01:811F 0D              	   332: 	dec		C						; Else, decrement character counter by one
01:8120 2B              	   333: 	dec		HL						; And decrement buffer to previous spot
01:8121 3E08            	   334: 	ld		A,BKSP					; Erace character on screen...
01:8123 CD7480          	   335: 	call	PrintChar				; Go back one previous character
01:8126 3E20            	   336: 	ld		A," "					;
01:8128 CD7480          	   337: 	call	PrintChar				; Overwrite the character with a space
01:812B 3E08            	   338: 	ld		A,BKSP					;
01:812D CD7480          	   339: 	call	PrintChar				; Then go back one character again
01:8130 18C4            	   340: 	jr		ReadStringChar			; Get the next character
                        	   341: 	
                        	   342: ReadStringESC:
01:8132 EB              	   343: 	ex		DE,HL					; Restore start position of HL
                        	   344: ;	ld		HL,CommandBuffer		; Point CommandBuffer to start
                        	   345: 
                        	   346: ReadStringCR:
01:8133 3600            	   347: 	ld		(HL),0					; Write NULL character in buffer to indicate end of string
01:8135 CD7F80          	   348: 	call	PrintCRLF				; Change line
                        	   349: 	
01:8138 E1              	   350: 	pop		HL						; Points to the start of the string
01:8139 D1              	   351: 	pop		DE
01:813A C1              	   352: 	pop		BC
01:813B F1              	   353: 	pop		AF
01:813C C9              	   354: 	ret
                        	   355: 
                        	   356: 
                        	   357: ;  ____                       _  __        __                     _ 
                        	   358: ; |  _ \    ___    __ _    __| | \ \      / /   ___    _ __    __| |
                        	   359: ; | |_) |  / _ \  / _` |  / _` |  \ \ /\ / /   / _ \  | '__|  / _` |
                        	   360: ; |  _ <  |  __/ | (_| | | (_| |   \ V  V /   | (_) | | |    | (_| |
                        	   361: ; |_| \_\  \___|  \__,_|  \__,_|    \_/\_/     \___/  |_|     \__,_|
                        	   362: 
                        	   363: 
                        	   364: ; *********************************************************************************************************************
                        	   365: ; Read a word (4 ASCII Hex characters) from the console (waiting)
                        	   366: ;	- Output: Word received in HL
                        	   367: ; *********************************************************************************************************************
                        	   368: 
                        	   369: ReadWord:
01:813D F5              	   370: 	push	AF
01:813E CDDB80          	   371: 	call	ReadByte			; Read first byte (first and second ASCII character)
01:8141 67              	   372: 	ld		H,A					; Store the MSB
01:8142 CDDB80          	   373: 	call	ReadByte			; Read second byte (third and fourth ASCII character)
01:8145 6F              	   374: 	ld		L,A					; Store the LSB
01:8146 CDAC81          	   375: 	call	Ascii2HexWord		; Convert the ASCII characters to a word, result in BC
01:8149 F1              	   376: 	pop		AF
01:814A C9              	   377: 	ret
                        	   378: 
                        	   379: 	
                        	   380: ;  ____    ___    ___            ___           _   _   
                        	   381: ; / ___|  |_ _|  / _ \          |_ _|  _ __   (_) | |_ 
                        	   382: ; \___ \   | |  | | | |          | |  | '_ \  | | | __|
                        	   383: ;  ___) |  | |  | |_| |          | |  | | | | | | | |_ 
                        	   384: ; |____/  |___|  \___/   _____  |___| |_| |_| |_|  \__|
                        	   385: ;                       |_____|                        
                        	   386: 
                        	   387: ; *********************************************************************************************************************
                        	   388: ; Initializes SIO port A
                        	   389: ;   - Destroys: AF, HL, BC (There's usually no need to save registers in the init stage)
                        	   390: ; *********************************************************************************************************************
                        	   391: 
                        	   392: SIO_Init:
01:814B 3E18            	   393: 	ld		A,%00011000				; Perform channel reset
01:814D D302            	   394: 	out		(SIO_PortA_Ctrl),A		; Requires four extra clock cycles for the SIO reset time
01:814F 00              	   395: 	nop
01:8150 3E04            	   396: 	ld		A,%00000100				; WR0: select register 4
01:8152 D302            	   397: 	out		(SIO_PortA_Ctrl),A
01:8154 3E44            	   398: 	ld		A,%01000100				; WR4: 1/16 (115200 @ 1.8432MHZ), 8-bit sync, 1 stop bit, no parity
01:8156 D302            	   399: 	out		(SIO_PortA_Ctrl),A
01:8158 3E03            	   400: 	ld		A,%00000011				; WR0: select register 3
01:815A D302            	   401: 	out		(SIO_PortA_Ctrl),A
01:815C 3EC1            	   402: 	ld		A,%11000001				; WR3: 8-bits/char, RX enabled
01:815E D302            	   403: 	out		(SIO_PortA_Ctrl),A
01:8160 3E05            	   404: 	ld		A,%00000101				; WR0: select register 5
01:8162 D302            	   405: 	out		(SIO_PortA_Ctrl),A
01:8164 3E68            	   406: 	ld		A,%01101000				; WR5: DTR=0, 8-bits/char, TX enabled
01:8166 D302            	   407: 	out		(SIO_PortA_Ctrl),A
01:8168 C9              	   408: 	ret
                        	   409: 

Source: "main.asm"
                        	   270: 	.include	"convert.asm"		; Convert and process data subroutines

Source: "convert.asm"
                        	     1: ; Routines in this include file:
                        	     2: ; ------------------------------
                        	     3: ;	- Ascii2HexNibble	[A -> A]
                        	     4: ;	- Ascii2HexByte		[HL -> A]
                        	     5: ;	- Ascii2HexWord		[HL -> BC]
                        	     6: ;	- UpperCase			[A -> A]
                        	     7: 
                        	     8: ; *********************************************************************************************************************
                        	     9: ; Converts a single decimal digit to BCD
                        	    10: ;	- Input:	A = Contains the ASCII character to convert to BCD
                        	    11: ;	- Output:	A = Contains the 4-bit BCD value in LSB
                        	    12: ;				Carry set if valid; Carry clear if error
                        	    13: ; *********************************************************************************************************************
                        	    14: 
                        	    15: Ascii2BcdDigit:
                        	    16: 
                        	    17: ;     _                   _   _   ____    _   _                 _   _   _   _       _       _        
                        	    18: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | \ | | (_) | |__   | |__   | |   ___ 
                        	    19: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  \| | | | | '_ \  | '_ \  | |  / _ \
                        	    20: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |\  | | | | |_) | | |_) | | | |  __/
                        	    21: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |_| \_| |_| |_.__/  |_.__/  |_|  \___|
                        	    22: ;
                        	    23: 
                        	    24: ; *********************************************************************************************************************
                        	    25: ; Converts a single ASCII hex character to a nibble, and validate if it's ok
                        	    26: ;	- Input:	A = Contains the ASCII character to convert to hex value
                        	    27: ;	- Output:	A = Converted 4-bit value in LSB
                        	    28: ;				Carry set if valid; Carry clear if error
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: Ascii2HexNibble:
01:8169 CD9F82          	    32: 	call	UpperCase				; Convert a-f to uppercase
01:816C FE30            	    33: 	cp		"0"						; If it's anything bellow 0
01:816E 381B            	    34: 	jr		c,Ascii2HexNibbleErr	; Then indicate an error
01:8170 FE47            	    35: 	cp		"F"+1					; If it's anything above F
01:8172 3017            	    36: 	jr		nc,Ascii2HexNibbleErr	; Then indicate an error
01:8174 FE3A            	    37: 	cp		"9"+1					; Check if it's less then 9
01:8176 3806            	    38: 	jr		c,Ascii2HexNibbleOK		; Then it's a valid 0-9 digit
01:8178 FE41            	    39: 	cp		"A"						; Check if it's above A
01:817A 3002            	    40: 	jr		nc,Ascii2HexNibbleOK	; Then it's a valid A-F hex digit
01:817C 180D            	    41: 	jr		Ascii2HexNibbleErr		; Else, anything in between is an error
                        	    42: 
                        	    43: Ascii2HexNibbleOK:
01:817E D630            	    44: 	sub		$30						; Substract $30 to transform character 0-9 into a number
01:8180 FE0A            	    45: 	cp		9+1						; Is it a decimal 0-9 digit?
01:8182 3802            	    46: 	jr		c,Ascii2HexNibbleEnd	; If it's then return value it as is
01:8184 D607            	    47: 	sub		$07						; If not, then substract the alpha offset to get A-F
                        	    48: 
                        	    49: Ascii2HexNibbleEnd:
01:8186 CD4A89          	    50: 	call	IncErrorPointer			; Increment command line error pointer
01:8189 37              	    51: 	scf								; Set carry flag
01:818A C9              	    52: 	ret
                        	    53: 
                        	    54: Ascii2HexNibbleErr:
01:818B B7              	    55: 	or		A						; Clear carry flag
01:818C C9              	    56: 	ret
                        	    57: 
                        	    58: 
                        	    59: ;     _                   _   _   ____    _   _                 ____            _          
                        	    60: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	    61: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	    62: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	    63: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	    64: ;                                                                       |___/              
                        	    65: ;
                        	    66: ; *********************************************************************************************************************
                        	    67: ; Converts a pair of ASCII hex characters to a byte and validate if it's ok
                        	    68: ;	- Input:	HL = Points to the two characters to convert
                        	    69: ;	- Output:	A = Converted 8-bit byte
                        	    70: ;				HL = points to the next position
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: Ascii2HexByte:
01:818D C5              	    75: 	push	BC
01:818E 7E              	    76: 	ld		A,(HL)
01:818F 23              	    77: 	inc		HL
01:8190 CD6981          	    78: 	call	Ascii2HexNibble			; Convert the first character (MSB)
01:8193 3014            	    79: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:8195 CB27            	    80: 	sla		A						; Place result to the MSB position...
01:8197 CB27            	    81: 	sla		A						;	by shifting it 4 times to the left...
01:8199 CB27            	    82: 	sla		A						;	and zeroing out the LSB in the process
01:819B CB27            	    83: 	sla		A						;
01:819D 47              	    84: 	ld		B,A						; Save resulting MSB
01:819E 7E              	    85: 	ld		A,(HL)
01:819F 23              	    86: 	inc		HL
01:81A0 CD6981          	    87: 	call	Ascii2HexNibble			; Convert the second character (LSB)
01:81A3 3004            	    88: 	jr		nc,Ascii2HexByteErr		; Was there an error? If Yes, then exit with error code
01:81A5 B0              	    89: 	or		B						; Merge MSB with LSB, result in A
01:81A6 C1              	    90: 	pop		BC
01:81A7 37              	    91: 	scf								; Set carry flag
01:81A8 C9              	    92: 	ret
                        	    93: 
                        	    94: Ascii2HexByteErr:
01:81A9 C1              	    95: 	pop		BC
01:81AA B7              	    96: 	or		A						; Clear carry flag
01:81AB C9              	    97: 	ret
                        	    98: 
                        	    99: 
                        	   100: ;     _                   _   _   ____    _   _                 ____            _          
                        	   101: ;    / \     ___    ___  (_) (_) |___ \  | | | |   ___  __  __ | __ )   _   _  | |_    ___ 
                        	   102: ;   / _ \   / __|  / __| | | | |   __) | | |_| |  / _ \ \ \/ / |  _ \  | | | | | __|  / _ \
                        	   103: ;  / ___ \  \__ \ | (__  | | | |  / __/  |  _  | |  __/  >  <  | |_) | | |_| | | |_  |  __/
                        	   104: ; /_/   \_\ |___/  \___| |_| |_| |_____| |_| |_|  \___| /_/\_\ |____/   \__, |  \__|  \___|
                        	   105: ;                                                                       |___/              
                        	   106: ;
                        	   107: ; *********************************************************************************************************************
                        	   108: ; Converts four ASCII hex characters to a 16-bit word and validate if it's ok
                        	   109: ;	- Input:	HL = Points to the 4 characters to be converted
                        	   110: ;	- Output:	BC = Contains the 16-bit value
                        	   111: ;				HL = points to the next position
                        	   112: ;				Carry set if valid; Carry clear if error
                        	   113: ; *********************************************************************************************************************
                        	   114: 
                        	   115: Ascii2HexWord:
01:81AC F5              	   116: 	push	AF
01:81AD CD8D81          	   117: 	call	Ascii2HexByte			; Convert the upper 2 characters (MSB)
01:81B0 300A            	   118: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B2 47              	   119: 	ld		B,A						; Save the MSB result to B
01:81B3 CD8D81          	   120: 	call	Ascii2HexByte			; Convert the lower 2 characters (LSB)
01:81B6 3004            	   121: 	jr		nc,Ascii2HexWordErr		; Was there an error? If Yes, then exit with error code
01:81B8 4F              	   122: 	ld		C,A						; Save the the LSB
01:81B9 F1              	   123: 	pop		AF
01:81BA 37              	   124: 	scf								; Set carry flag
01:81BB C9              	   125: 	ret
                        	   126: 	
                        	   127: Ascii2HexWordErr:
01:81BC F1              	   128: 	pop		AF
01:81BD B7              	   129: 	or		A						; Clear carry flag
01:81BE C9              	   130: 	ret
                        	   131: 
                        	   132: 
                        	   133: ;  ____                  ____    _   _               
                        	   134: ; |  _ \    ___    ___  |___ \  | | | |   ___  __  __
                        	   135: ; | | | |  / _ \  / __|   __) | | |_| |  / _ \ \ \/ /
                        	   136: ; | |_| | |  __/ | (__   / __/  |  _  | |  __/  >  < 
                        	   137: ; |____/   \___|  \___| |_____| |_| |_|  \___| /_/\_\
                        	   138: ;
                        	   139: ;
                        	   140: ; *********************************************************************************************************************
                        	   141: ; Convert decimal digits in a string to a hex number
                        	   142: ;	- Input:	HL = Points to the string the decimal characters are
                        	   143: ;	- Output:	BC = 16-bit hex value
                        	   144: ;				HL = Points to the next position after the last decimal number
                        	   145: ; *********************************************************************************************************************
                        	   146: 
                        	   147: Dec2Hex:
01:81BF F5              	   148: 	push	AF
01:81C0 D5              	   149: 	push	DE
                        	   150: 	
01:81C1 CD378B          	   151: 	call	SkipSpaces
01:81C4 EB              	   152: 	ex		DE,HL					; HL is normally processed for strings, but ADD requires HL in this routine
01:81C5 210000          	   153: 	ld		HL,0
                        	   154: Dec2HexLoop:		
01:81C8 1A              	   155: 	ld		A,(DE)					; HL is required for add, so DE is used to grab the string instead of HL
01:81C9 FE00            	   156: 	cp		0
01:81CB 2829            	   157: 	jr		z,Dec2HexShuffleRegs
01:81CD FE20            	   158: 	cp		DELIMITER
01:81CF 2825            	   159: 	jr		z,Dec2HexShuffleRegs
                        	   160: 	
01:81D1 FE30            	   161: 	cp		"0"						; If it's anything bellow 0
01:81D3 382D            	   162: 	jr		c,Dec2HexInvalidDec		; Then indicate an error
01:81D5 FE3A            	   163: 	cp		"9"+1					; Check if it's less then 9
01:81D7 3029            	   164: 	jr		nc,Dec2HexInvalidDec	; Then indicate an error
                        	   165: 
01:81D9 D630            	   166: 	sub		$30						; Convert ASCII decimal to BCD
01:81DB 13              	   167: 	inc		DE						; Increment buffer pointer
01:81DC CD4A89          	   168: 	call	IncErrorPointer
                        	   169: 
01:81DF E5              	   170: 	push	HL
01:81E0 C1              	   171: 	pop		BC
                        	   172: 
01:81E1 29              	   173: 	add		HL,HL
01:81E2 3818            	   174: 	jr		c,Dec2HexOutOfRange
01:81E4 29              	   175: 	add		HL,HL	
01:81E5 3815            	   176: 	jr		c,Dec2HexOutOfRange
01:81E7 09              	   177: 	add		HL,BC	
01:81E8 3812            	   178: 	jr		c,Dec2HexOutOfRange
01:81EA 29              	   179: 	add		HL,HL
01:81EB 380F            	   180: 	jr		c,Dec2HexOutOfRange
                        	   181: 	
01:81ED 85              	   182: 	add		L	
01:81EE 6F              	   183: 	ld		L,A	
01:81EF 30D7            	   184: 	jr		nc,Dec2HexLoop
01:81F1 24              	   185: 	inc		H
01:81F2 3808            	   186: 	jr		c,Dec2HexOutOfRange
01:81F4 18D2            	   187: 	jr		Dec2HexLoop
                        	   188: 
                        	   189: Dec2HexShuffleRegs:
01:81F6 E5              	   190: 	push	HL						; Push result in BC
01:81F7 C1              	   191: 	pop		BC						;
01:81F8 EB              	   192: 	ex		DE,HL					; Place buffer pointer in HL
01:81F9 37              	   193: 	scf								; Set Carry
01:81FA 180D            	   194: 	jr		Dec2HexEnd
                        	   195: 
                        	   196: Dec2HexOutOfRange:
01:81FC CD47B0          	   197: 	call	NumberOutOfRange
01:81FF B7              	   198: 	or		A
01:8200 1807            	   199: 	jr		Dec2HexEnd
                        	   200: 	
                        	   201: Dec2HexInvalidDec:
01:8202 CDBC89          	   202: 	call	PrintErrorPointer
01:8205 CD50B0          	   203: 	call	InvalidDecimalNumber
01:8208 B7              	   204: 	or		A
                        	   205: 	
                        	   206: Dec2HexEnd:
01:8209 D1              	   207: 	pop		DE
01:820A F1              	   208: 	pop		AF
01:820B C9              	   209: 	ret
                        	   210: 
                        	   211: 
                        	   212: ;  _   _                 ____    ____                
                        	   213: ; | | | |   ___  __  __ |___ \  |  _ \    ___    ___ 
                        	   214: ; | |_| |  / _ \ \ \/ /   __) | | | | |  / _ \  / __|
                        	   215: ; |  _  | |  __/  >  <   / __/  | |_| | |  __/ | (__ 
                        	   216: ; |_| |_|  \___| /_/\_\ |_____| |____/   \___|  \___|
                        	   217: ;
                        	   218: ;
                        	   219: ; *********************************************************************************************************************
                        	   220: ; Convert a 16-bit a hex binary data to a decimal string
                        	   221: ;	- Input:	HL = 16-bit hex number
                        	   222: ;	- Output:	HL = Start of string pointer (DigitString variable) - Ends with null
                        	   223: ; *********************************************************************************************************************
                        	   224: ; B is the first non-zero flag, so as not to print leading zero's
                        	   225: 
                        	   226: Hex2Dec:
01:820C F5              	   227: 	push	AF
01:820D C5              	   228: 	push	BC
01:820E D5              	   229: 	push	DE
01:820F DDE5            	   230: 	push	IX
                        	   231: 
01:8211 0600            	   232: 	ld		B,0
01:8213 DD218CB0        	   233: 	ld		IX,DigitString
                        	   234: Hex2Dec10000:
                        	   235: 	; CALCULATE THE 10,000's
01:8217 3EFF            	   236: 	ld		A,-1					; Start at -1
                        	   237: Hex2Dec10000Loop:
01:8219 3C              	   238: 	inc		A						; Add 1
01:821A B7              	   239: 	or		A						; Clear carry
01:821B 111027          	   240: 	ld		DE,10000
01:821E ED52            	   241: 	sbc		HL,DE					; Substract 10,000
01:8220 30F7            	   242: 	jr		nc,Hex2Dec10000Loop		; Continue if not reached negative
01:8222 19              	   243: 	add		HL,DE					; Add 10,000 back to make it positive
01:8223 FE00            	   244: 	cp		0
01:8225 2002            	   245: 	jr		nz,Hex2Dec10000Set
01:8227 1809            	   246: 	jr		Hex2Dec1000				; If it's not set
                        	   247: Hex2Dec10000Set
01:8229 CBC0            	   248: 	set		0,B
01:822B C630            	   249: 	add		$30
01:822D DD7700          	   250: 	ld		(IX),A
01:8230 DD23            	   251: 	inc		IX
                        	   252: 
                        	   253: 	; CALCULATE THE 1,000's
                        	   254: Hex2Dec1000:
01:8232 3EFF            	   255: 	ld		A,-1					; Start at -1
                        	   256: Hex2Dec1000Loop:
01:8234 3C              	   257: 	inc		A						; Add 1
01:8235 B7              	   258: 	or		A						; Clear carry
01:8236 11E803          	   259: 	ld		DE,1000
01:8239 ED52            	   260: 	sbc		HL,DE					; Substract 1,000
01:823B 30F7            	   261: 	jr		nc,Hex2Dec1000Loop		; Continue if not reached negative
01:823D 19              	   262: 	add		HL,DE					; Add 1,000 back to make it positive
01:823E FE00            	   263: 	cp		0
01:8240 2004            	   264: 	jr		nz,Hex2Dec1000Set
01:8242 CB40            	   265: 	bit		0,B						; Check the flag
01:8244 2809            	   266: 	jr		z,Hex2Dec100			; If it's not set
                        	   267: Hex2Dec1000Set
01:8246 CBC0            	   268: 	set		0,B						
01:8248 C630            	   269: 	add		$30
01:824A DD7700          	   270: 	ld		(IX),A
01:824D DD23            	   271: 	inc		IX
                        	   272: 
                        	   273: 	; CALCULATE THE 100's
                        	   274: Hex2Dec100:
01:824F 3EFF            	   275: 	ld		A,-1					; Start at -1
                        	   276: Hex2Dec100Loop:
01:8251 3C              	   277: 	inc		A						; Add 1
01:8252 B7              	   278: 	or		A						; Clear carry
01:8253 116400          	   279: 	ld		DE,100
01:8256 ED52            	   280: 	sbc		HL,DE					; Substract 100
01:8258 30F7            	   281: 	jr		nc,Hex2Dec100Loop		; Continue if not reached negative
01:825A 19              	   282: 	add		HL,DE					; Add 100 back to make it positive
01:825B FE00            	   283: 	cp		0
01:825D 2004            	   284: 	jr		nz,Hex2Dec100Set
01:825F CB40            	   285: 	bit		0,B						; Check the flag
01:8261 2809            	   286: 	jr		z,Hex2Dec10				; If it's not set
                        	   287: Hex2Dec100Set
01:8263 CBC0            	   288: 	set		0,B						
01:8265 C630            	   289: 	add		$30
01:8267 DD7700          	   290: 	ld		(IX),A
01:826A DD23            	   291: 	inc		IX
                        	   292: 
                        	   293: 
                        	   294: 	; CALCULATE THE 10's
                        	   295: Hex2Dec10:
01:826C 3EFF            	   296: 	ld		A,-1					; Start at -1
                        	   297: Hex2Dec10Loop:
01:826E 3C              	   298: 	inc		A						; Add 1
01:826F B7              	   299: 	or		A						; Clear carry
01:8270 110A00          	   300: 	ld		DE,10
01:8273 ED52            	   301: 	sbc		HL,DE					; Substract 10
01:8275 30F7            	   302: 	jr		nc,Hex2Dec10Loop		; Continue if not reached negative
01:8277 19              	   303: 	add		HL,DE					; Add 10 back to make it positive
01:8278 FE00            	   304: 	cp		0
01:827A 2004            	   305: 	jr		nz,Hex2Dec10Set
01:827C CB40            	   306: 	bit		0,B						; Check the flag
01:827E 2809            	   307: 	jr		z,Hex2Dec1				; If it's not set
                        	   308: Hex2Dec10Set
01:8280 CBC0            	   309: 	set		0,B						
01:8282 C630            	   310: 	add		$30
01:8284 DD7700          	   311: 	ld		(IX),A
01:8287 DD23            	   312: 	inc		IX
                        	   313: 
                        	   314: 	; STORE THE 1's
                        	   315: Hex2Dec1:
01:8289 7D              	   316: 	ld		A,L
01:828A C630            	   317: 	add		$30
01:828C DD7700          	   318: 	ld		(IX),A
01:828F DD23            	   319: 	inc		IX
01:8291 3E00            	   320: 	ld		A,0
01:8293 DD7700          	   321: 	ld		(IX),A					; End string with null character
                        	   322: 	
                        	   323: Hex2DecEnd:
01:8296 218CB0          	   324: 	ld		HL,DigitString			; Point to decimal string to output
                        	   325: 	
01:8299 DDE1            	   326: 	pop		IX
01:829B D1              	   327: 	pop		DE
01:829C C1              	   328: 	pop		BC
01:829D F1              	   329: 	pop		AF
01:829E C9              	   330: 	ret
                        	   331: 
                        	   332: 
                        	   333: ;  _   _                                  ____                      
                        	   334: ; | | | |  _ __    _ __     ___   _ __   / ___|   __ _   ___    ___ 
                        	   335: ; | | | | | '_ \  | '_ \   / _ \ | '__| | |      / _` | / __|  / _ \
                        	   336: ; | |_| | | |_) | | |_) | |  __/ | |    | |___  | (_| | \__ \ |  __/
                        	   337: ;  \___/  | .__/  | .__/   \___| |_|     \____|  \__,_| |___/  \___|
                        	   338: ;         |_|     |_|                                               
                        	   339: ;
                        	   340: ; *********************************************************************************************************************
                        	   341: ; Converts a character to uppercase
                        	   342: ;	- INPUT:	A = Character to uppercase
                        	   343: ;	- OUTPUT:	A = Uppercased character
                        	   344: ; *********************************************************************************************************************
                        	   345: 
                        	   346: UpperCase:
01:829F FE61            	   347: 	cp		"a"						; Is the value less then lowercase a?
01:82A1 3806            	   348: 	jr		c,UpperCaseEnd			; If so, then end routine
01:82A3 FE7B            	   349: 	cp		"z"+1					; Is the value more then lowercase z?
01:82A5 3002            	   350: 	jr		nc,UpperCaseEnd			; If so, then end routine
01:82A7 D620            	   351: 	sub		32						; Substract the ASCII difference
                        	   352: UpperCaseEnd:
01:82A9 C9              	   353: 	ret
                        	   354: 	

Source: "main.asm"
                        	   271: 	.include	"monitor.asm"		; Monitor command subroutines

Source: "monitor.asm"
                        	     1: ; Command routines in this include file:
                        	     2: ; --------------------------------------
                        	     3: ;	- ClearScreen					; {}
                        	     4: ;	- Diagnostics					; {}
                        	     5: ;	- Fill							; {SSSS EEEE BB}
                        	     6: ;	- HexDump 						; {AAAA LL}
                        	     7: ;	- IntelHex  					; {}
                        	     8: ;	- List  						; {}
                        	     9: ;	- Peek							; [AAAA]
                        	    10: ;	- Poke							; AAAA BB
                        	    11: ;	- Registers  					; {}
                        	    12: ;	- Run  							; {AAAA}
                        	    13: ;	- SetAddress					; [AAAA]
                        	    14: ;	- SetBank						; [N]
                        	    15: ;	- SysInfo 						; {}
                        	    16: ;	- Write							; AAAA BB [BB] [BB] [BB] [BB] [BB]
                        	    17: ;	- Zero							; {}
                        	    18: 
                        	    19: 
                        	    20: ;   ____   _                         ____                                      
                        	    21: ;  / ___| | |   ___    __ _   _ __  / ___|    ___   _ __    ___    ___   _ __  
                        	    22: ; | |     | |  / _ \  / _` | | '__| \___ \   / __| | '__|  / _ \  / _ \ | '_ \ 
                        	    23: ; | |___  | | |  __/ | (_| | | |     ___) | | (__  | |    |  __/ |  __/ | | | |
                        	    24: ;  \____| |_|  \___|  \__,_| |_|    |____/   \___| |_|     \___|  \___| |_| |_|
                        	    25: ;
                        	    26: 
                        	    27: ; *********************************************************************************************************************
                        	    28: ; ClearScreen: Clears the VT terminal screen
                        	    29: ; *********************************************************************************************************************
                        	    30: 
                        	    31: ClearScreen:
01:82AA E5              	    32: 	push	HL
01:82AB 2187AB          	    33: 	ld		HL,ClearScreenSeq
01:82AE CDAE80          	    34: 	call	PrintString
01:82B1 E1              	    35: 	pop		HL
01:82B2 C9              	    36: 	ret
                        	    37: 
                        	    38: 
                        	    39: ;   ____                           ____    _                  _    
                        	    40: ;  / ___|   ___    _ __    _   _  | __ )  | |   ___     ___  | | __
                        	    41: ; | |      / _ \  | '_ \  | | | | |  _ \  | |  / _ \   / __| | |/ /
                        	    42: ; | |___  | (_) | | |_) | | |_| | | |_) | | | | (_) | | (__  |   < 
                        	    43: ;  \____|  \___/  | .__/   \__, | |____/  |_|  \___/   \___| |_|\_\
                        	    44: ;                 |_|      |___/
                        	    45: ;
                        	    46: ; *********************************************************************************************************************
                        	    47: ; Copy data from source to destination
                        	    48: ; - Input:	HL = Source address
                        	    49: ;			DE = Destination address
                        	    50: ;			BC = Number of bytes to move
                        	    51: ; *********************************************************************************************************************
                        	    52: 
                        	    53: CopyBlock:
01:82B3 F5              	    54: 	push	AF
01:82B4 C5              	    55: 	push	BC
01:82B5 D5              	    56: 	push	DE
01:82B6 E5              	    57: 	push	HL
                        	    58: 
01:82B7 2A86B0          	    59: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	    60: 	
                        	    61: CopySourceAddress:
01:82BA CDC988          	    62: 	call	GetHexParameter			; Get the first parameter, start address
01:82BD D21383          	    63: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82C0 FE00            	    64: 	cp		0						; Is there a first parameter?
01:82C2 2847            	    65: 	jr		z,CopyNoParameter		; No, then print error message
01:82C4 ED43A5B0        	    66: 	ld		(StartAddress),BC		; Save source address
                        	    67: 
                        	    68: CopyDestinationAddress:
01:82C8 CDC988          	    69: 	call	GetHexParameter			; Get the first parameter, start address
01:82CB D21383          	    70: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82CE FE00            	    71: 	cp		0						; Is there a first parameter?
01:82D0 2839            	    72: 	jr		z,CopyNoParameter		; No, then print error message
01:82D2 ED43A7B0        	    73: 	ld		(EndAddress),BC			; Save destination address
                        	    74: 
                        	    75: CopyNumberOfBytes:
01:82D6 CDC988          	    76: 	call	GetHexParameter			; Get the first parameter, start address
01:82D9 D21383          	    77: 	jp		nc,CopyEnd				; Exit routine if there was an error in the parameter
01:82DC FE00            	    78: 	cp		0						; Is there a first parameter?
01:82DE 282B            	    79: 	jr		z,CopyNoParameter		; No, then print error message
                        	    80: 
                        	    81: 	; Check if the number of bytes is zero
01:82E0 78              	    82: 	ld		A,B
01:82E1 B1              	    83: 	or		C
01:82E2 282C            	    84: 	jr		z,CopyNothing
                        	    85: 
01:82E4 2AA5B0          	    86: 	ld		HL,(StartAddress)		; Restore HL
                        	    87: 	
                        	    88: 	; Does destination area overlap source area?
01:82E7 ED5BA5B0        	    89: 	ld		DE,(StartAddress)
01:82EB 2AA7B0          	    90: 	ld		HL,(EndAddress)
01:82EE B7              	    91: 	or		A						; Clear carry
01:82EF ED52            	    92: 	sbc		HL,DE
01:82F1 B7              	    93: 	or		A						; Clear carry
01:82F2 ED42            	    94: 	sbc		HL,BC
01:82F4 2AA5B0          	    95: 	ld		HL,(StartAddress)
01:82F7 ED5BA7B0        	    96: 	ld		DE,(EndAddress)
01:82FB 300A            	    97: 	jr		nc,CopyNoOverlap
                        	    98: 	
                        	    99: 	; Destination overlaps, copy from highest address to avoid destroying data
01:82FD 09              	   100: 	add		HL,BC
01:82FE 2B              	   101: 	dec		HL
01:82FF EB              	   102: 	ex		DE,HL
01:8300 09              	   103: 	add		HL,BC
01:8301 2B              	   104: 	dec		HL
01:8302 EB              	   105: 	ex		DE,HL
01:8303 EDB8            	   106: 	lddr
01:8305 180C            	   107: 	jr		CopyEnd
                        	   108: 
                        	   109: CopyNoOverlap:
01:8307 EDB0            	   110: 	ldir
01:8309 1808            	   111: 	jr		CopyEnd
                        	   112: 
                        	   113: CopyNoParameter:
01:830B CD20B0          	   114: 	call	NoParameter
01:830E 1803            	   115: 	jr		CopyEnd
                        	   116: 
                        	   117: CopyNothing:
01:8310 CD59B0          	   118: 	call	NothingToCopy
                        	   119: 
                        	   120: CopyEnd:	
01:8313 E1              	   121: 	pop		HL
01:8314 D1              	   122: 	pop		DE
01:8315 C1              	   123: 	pop		BC
01:8316 F1              	   124: 	pop		AF
01:8317 C9              	   125: 	ret
                        	   126: 
                        	   127: 
                        	   128: ;  ____    _                                         _     _              
                        	   129: ; |  _ \  (_)   __ _    __ _   _ __     ___    ___  | |_  (_)   ___   ___ 
                        	   130: ; | | | | | |  / _` |  / _` | | '_ \   / _ \  / __| | __| | |  / __| / __|
                        	   131: ; | |_| | | | | (_| | | (_| | | | | | | (_) | \__ \ | |_  | | | (__  \__ \
                        	   132: ; |____/  |_|  \__,_|  \__, | |_| |_|  \___/  |___/  \__| |_|  \___| |___/
                        	   133: ;                      |___/                                              
                        	   134: ;
                        	   135: ;
                        	   136: ; *********************************************************************************************************************
                        	   137: ; Test system RAM, except the range of this routine
                        	   138: ; *********************************************************************************************************************
                        	   139: 
                        	   140: Diagnostics:
01:8318 F5              	   141: 	push	AF
01:8319 C5              	   142: 	push	BC
01:831A D5              	   143: 	push	DE
01:831B E5              	   144: 	push	HL
01:831C DDE5            	   145: 	push	IX
01:831E FDE5            	   146: 	push	IY
                        	   147: 	
                        	   148: ; TEST BANK MEMORY
                        	   149: ; ----------------
01:8320 3E00            	   150: 	ld		A,0						; Set Bank number to 0
01:8322 FD210000        	   151: 	ld		IY,0
                        	   152: DiagnosticsBankLoop:
01:8326 210BAE          	   153: 	ld		HL,TestingBankNumberMsg
01:8329 CDAE80          	   154: 	call	PrintString
01:832C CD9E80          	   155: 	call	PrintNibble
01:832F CD7F80          	   156: 	call	PrintCRLF
01:8332 DD210000        	   157: 	ld		IX,$0000				; Set start address
01:8336 21FF7F          	   158: 	ld		HL,$7FFF				; Set end address
01:8339 D330            	   159: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:833B CD6183          	   160: 	call	DiagnosticsTest
01:833E 3C              	   161: 	inc		A
01:833F FD6F            	   162: 	ld		IYL,A					; Save the bank number for error printing
01:8341 FE0F            	   163: 	cp		$F
01:8343 20E1            	   164: 	jr		nz,DiagnosticsBankLoop
                        	   165: 
                        	   166: ; TEST HIGH MEMORY (BETWEEN START OF BIOS AND START OF DIAG CODE)
                        	   167: ; ---------------------------------------------------------------
01:8345 211EAE          	   168: 	ld		HL,TestingHighRamMsg
01:8348 CDAE80          	   169: 	call	PrintString
01:834B DD210080        	   170: 	ld		IX,$8000				; Set start address
01:834F 216183          	   171: 	ld		HL,DiagnosticsTest		; Set end address
01:8352 CD6183          	   172: 	call	DiagnosticsTest
                        	   173: 
                        	   174: ; TEST HIGH MEMORY (AFTER DIAG CODE TILL THE END)
                        	   175: ; -----------------------------------------------
01:8355 DD21CF83        	   176: 	ld		IX,DiagnosticsEnd		; Set start address
01:8359 21FFFF          	   177: 	ld		HL,$FFFF				; Set end address
01:835C CD6183          	   178: 	call	DiagnosticsTest
                        	   179: 
01:835F 186E            	   180: 	jr		DiagnosticsEnd
                        	   181: 
                        	   182: ; ACTUAL MEMORY TEST SUBROUTINE WITHN THE SUBROUTINE
                        	   183: ; --------------------------------------------------
                        	   184: DiagnosticsTest:	
01:8361 F5              	   185: 	push	AF
                        	   186: 	
01:8362 DD2B            	   187: 	dec		IX						; Start with one less, since the increment starts at the start of the loop
                        	   188: DiagnosticsTestLoop:
01:8364 DD23            	   189: 	inc		IX						; Increment address pointer
01:8366 DD4600          	   190: 	ld		B,(IX)					; Save the original byte in B
                        	   191: 	
                        	   192: 	; Write pattern 55
01:8369 3E55            	   193: 	ld		A,$55					; Use $55 as the first pattern value
01:836B DD7700          	   194: 	ld		(IX),A					; Write it to the memory location
01:836E 4F              	   195: 	ld		C,A						; Save expected byte for error messages
01:836F DD7E00          	   196: 	ld		A,(IX)					; Read from same memory location
01:8372 FE55            	   197: 	cp		$55						; Compare if the it's the same
01:8374 C49583          	   198: 	call	nz,DiagMemoryError
                        	   199: 
                        	   200: 	; Write pattern AA
01:8377 3EAA            	   201: 	ld		A,$AA					; Use $55 as the first pattern value
01:8379 DD7700          	   202: 	ld		(IX),A					; Write it to the memory location
01:837C 4F              	   203: 	ld		C,A						; Save expected byte for error messages
01:837D DD7E00          	   204: 	ld		A,(IX)					; Read from same memory location
01:8380 FEAA            	   205: 	cp		$AA						; Compare if the it's the same
01:8382 C49583          	   206: 	call	nz,DiagMemoryError
                        	   207: 
01:8385 DD7000          	   208: 	ld		(IX),B					; Attempt to save the original value back in it's original place
                        	   209: 	
                        	   210: 	; Check for end of range
01:8388 DDE5            	   211: 	push	IX
01:838A D1              	   212: 	pop		DE
01:838B B7              	   213: 	or		A						; Clear carry flag
01:838C E5              	   214: 	push	HL
01:838D ED52            	   215: 	sbc		HL,DE					; HL = HL - DE
01:838F E1              	   216: 	pop		HL
01:8390 C26483          	   217: 	jp		nz,DiagnosticsTestLoop	; If reached the end of range, exit
                        	   218: 
01:8393 F1              	   219: 	pop		AF
01:8394 C9              	   220: 	ret
                        	   221: 
                        	   222: ; PRINT ERROR MESSAGE IF MEMORY IS BAD
                        	   223: ; ------------------------------------
                        	   224: DiagMemoryError:
01:8395 F5              	   225: 	push	AF
01:8396 E5              	   226: 	push	HL
                        	   227: 
                        	   228: 	; Print "Error at"
01:8397 21DCAD          	   229: 	ld		HL,BadMemory1Err
01:839A CDAE80          	   230: 	call	PrintString
                        	   231: 	
                        	   232: 	; Print bank number it it's in low memory
01:839D F5              	   233: 	push	AF
01:839E FD7D            	   234: 	ld		A,IYL
01:83A0 FE0F            	   235: 	cp		$0F
01:83A2 3008            	   236: 	jr		nc,DiagMemoryAddr
01:83A4 CD9E80          	   237: 	call	PrintNibble
01:83A7 3E3A            	   238: 	ld		A,":"
01:83A9 CD7480          	   239: 	call	PrintChar
                        	   240: 	
                        	   241: 	; Print address of error
                        	   242: DiagMemoryAddr
01:83AC F1              	   243: 	pop		AF
01:83AD DDE5            	   244: 	push	IX
01:83AF E1              	   245: 	pop		HL
01:83B0 CDBC80          	   246: 	call	PrintWord
                        	   247: 	
                        	   248: 	; Print "got"
01:83B3 21E6AD          	   249: 	ld		HL,BadMemory2Err
01:83B6 CDAE80          	   250: 	call	PrintString
                        	   251: 	
                        	   252: 	; Print the read back data
01:83B9 F5              	   253: 	push	AF
01:83BA 78              	   254: 	ld		A,B
01:83BB CD6180          	   255: 	call	PrintByte
01:83BE F1              	   256: 	pop		AF
                        	   257: 	
                        	   258: 	; Print "expected"
01:83BF CDAE80          	   259: 	call	PrintString
                        	   260: 	
                        	   261: 	; Print the pattern that was written
01:83C2 79              	   262: 	ld		A,C
01:83C3 CD6180          	   263: 	call	PrintByte
01:83C6 CD7F80          	   264: 	call	PrintCRLF
                        	   265: 	
01:83C9 FD2601          	   266: 	ld		IYH,1					; Indicate an error has occured
01:83CC E1              	   267: 	pop		HL
01:83CD F1              	   268: 	pop		AF
01:83CE C9              	   269: 	ret
                        	   270: 
                        	   271: DiagnosticsEnd:
01:83CF 3E00            	   272: 	ld		A,$0
01:83D1 D330            	   273: 	out		(BankSelect),A			; Sets bank number to 0
                        	   274: 	
01:83D3 FD7C            	   275: 	ld		A,IYH
01:83D5 FE01            	   276: 	cp		1
01:83D7 2806            	   277: 	jr		z,DiagnosticsEnd2		; If memory test failed, exit, as there was warning errors
01:83D9 2131AE          	   278: 	ld		HL,MemoryTestPassedMsg	; Else print test passed
01:83DC CDAE80          	   279: 	call	PrintString
                        	   280: 
                        	   281: DiagnosticsEnd2:
01:83DF FDE1            	   282: 	pop		IY
01:83E1 DDE1            	   283: 	pop		IX
01:83E3 E1              	   284: 	pop		HL
01:83E4 D1              	   285: 	pop		DE
01:83E5 C1              	   286: 	pop		BC
01:83E6 F1              	   287: 	pop		AF
01:83E7 C9              	   288: 	ret
                        	   289: 
                        	   290: 
                        	   291: ;  _____   _   _   _   __  __                                           
                        	   292: ; |  ___| (_) | | | | |  \/  |   ___   _ __ ___     ___    _ __   _   _ 
                        	   293: ; | |_    | | | | | | | |\/| |  / _ \ | '_ ` _ \   / _ \  | '__| | | | |
                        	   294: ; |  _|   | | | | | | | |  | | |  __/ | | | | | | | (_) | | |    | |_| |
                        	   295: ; |_|     |_| |_| |_| |_|  |_|  \___| |_| |_| |_|  \___/  |_|     \__, |
                        	   296: ;                                                                 |___/ 
                        	   297: 
                        	   298: ; *********************************************************************************************************************
                        	   299: ; Fill a memory address range with a byte. Does not fill all banks, only the current one. It will exclude
                        	   300: ; shadow ROM (otherwise it will corrupt the BIOS), as well as vector pages.
                        	   301: ;		- Parameter 1 = Start address
                        	   302: ;		- Parameter 2 = End address
                        	   303: ;		- Parameter 3 = The byte to write
                        	   304: ; *********************************************************************************************************************
                        	   305: ; 	Wishlist:
                        	   306: ;		- Verify after write
                        	   307: ;		- Add: Filled xxxx bytes in decimal
                        	   308: 
                        	   309: FillMemory:
01:83E8 F5              	   310: 	push	AF
01:83E9 C5              	   311: 	push	BC
01:83EA D5              	   312: 	push	DE
01:83EB E5              	   313: 	push	HL
                        	   314: 	
01:83EC 2A86B0          	   315: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   316: 	
                        	   317: ; GET ALL THE PARAMETERS AND STORE THEM IN MEMORY
                        	   318: FillStartAddr:
01:83EF CDC988          	   319: 	call	GetHexParameter			; Get the first parameter, start address
01:83F2 D28284          	   320: 	jp		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:83F5 FE00            	   321: 	cp		0						; Is there a first parameter?
01:83F7 287D            	   322: 	jr		z,FillNoParameter		; No, then print error message
01:83F9 FE0F            	   323: 	cp		HELP
01:83FB 287F            	   324: 	jr		z,FillPrintHelp
01:83FD ED43A5B0        	   325: 	ld		(StartAddress),BC		; Store start address
01:8401 ED43A9B0        	   326: 	ld		(StartAddressAlt),BC	; Store start address
                        	   327: 	
                        	   328: FillEndAddr:
01:8405 CDC988          	   329: 	call	GetHexParameter			; Get the second parameter, end address
01:8408 3078            	   330: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:840A FE00            	   331: 	cp		0						; Is there a second parameter?
01:840C 2868            	   332: 	jr		z,FillNoParameter		; No, then print error message
01:840E ED43A7B0        	   333: 	ld		(EndAddress),BC			; Store end address
                        	   334: 
                        	   335: FillByte:
01:8412 CDC988          	   336: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8415 306B            	   337: 	jr		nc,FillMemoryEnd		; Exit routine if there was an error in the parameter
01:8417 FE00            	   338: 	cp		0						; Is there a third parameter?
01:8419 285B            	   339: 	jr		z,FillNoParameter		; No, then print error message
01:841B 79              	   340: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:841C 32ADB0          	   341: 	ld		(ByteTransfer),A		; Store the byte to write
                        	   342: 	
01:841F CDD489          	   343: 	call	RangeValidation			; Check if Fill can write to a valid range of RAM space (excluse BIOS and Vectors)
01:8422 385E            	   344: 	jr		c,FillMemoryEnd
                        	   345: 	
                        	   346: FillRange1:
                        	   347: 	; Detect amout of bytes to copy in high range
01:8424 C5              	   348: 	push	BC
01:8425 CB49            	   349: 	bit		1,C
01:8427 2823            	   350: 	jr		z,FillRange2
01:8429 2AABB0          	   351: 	ld		HL,(EndAddressAlt)		; Load end address
01:842C ED5BA9B0        	   352: 	ld		DE,(StartAddressAlt)	; Load start
01:8430 B7              	   353: 	or		A						; Clear carry flag
01:8431 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:8433 E5              	   355: 	push	HL						; Put result of byte count
01:8434 C1              	   356: 	pop		BC						; Into the byte count register
01:8435 2AA9B0          	   357: 	ld		HL,(StartAddressAlt)	; Set source address
01:8438 3AADB0          	   358: 	ld		A,(ByteTransfer)		; Grab byte to write
01:843B 77              	   359: 	ld		(HL),A					; Save it at the source address
01:843C ED5BA9B0        	   360: 	ld		DE,(StartAddressAlt)	; Place destination address
01:8440 13              	   361: 	inc		DE						; Destination address +1
01:8441 EDB0            	   362: 	ldir
01:8443 ED4BA9B0        	   363: 	ld		BC,(StartAddressAlt)	; Set CurrentAddress to start of available RAM
01:8447 ED438AB0        	   364: 	ld		(CurrentAddress),BC
01:844B 37              	   365: 	scf								; Set carry
                        	   366: 
                        	   367: FillRange2:
                        	   368: 	; Detect amout of bytes to copy in low range
01:844C C1              	   369: 	pop		BC
01:844D CB41            	   370: 	bit		0,C
01:844F 2831            	   371: 	jr		z,FillMemoryEnd
01:8451 2AA7B0          	   372: 	ld		HL,(EndAddress)			; Load end address
01:8454 ED5BA5B0        	   373: 	ld		DE,(StartAddress)		; Load start
01:8458 B7              	   374: 	or		A						; Clear carry flag
01:8459 ED52            	   375: 	sbc		HL,DE					; HL = HL - DE
01:845B E5              	   376: 	push	HL						; Put result of byte count
01:845C C1              	   377: 	pop		BC						; Into the byte count register
01:845D 2AA5B0          	   378: 	ld		HL,(StartAddress)		; Set source address
01:8460 3AADB0          	   379: 	ld		A,(ByteTransfer)		; Grab byte to write
01:8463 77              	   380: 	ld		(HL),A					; Save it at the source address
01:8464 ED5BA5B0        	   381: 	ld		DE,(StartAddress)		; Place destination address
01:8468 13              	   382: 	inc		DE						; Destination address +1
01:8469 EDB0            	   383: 	ldir
01:846B ED4BA5B0        	   384: 	ld		BC,(StartAddress)		; Set CurrentAddress to start of available RAM
01:846F ED438AB0        	   385: 	ld		(CurrentAddress),BC
01:8473 37              	   386: 	scf								; Set Carry, indicates no error to calling program
01:8474 180C            	   387: 	jr		FillMemoryEnd
                        	   388: 
                        	   389: FillNoParameter:
01:8476 CD20B0          	   390: 	call	NoParameter
01:8479 B7              	   391: 	or		A						; Clear Carry, indicates error to calling program
01:847A 1806            	   392: 	jr		FillMemoryEnd
                        	   393: 
                        	   394: FillPrintHelp:
01:847C 21E0AE          	   395: 	ld		HL,FillHelp
01:847F CDAE80          	   396: 	call	PrintString
                        	   397: 
                        	   398: FillMemoryEnd:
01:8482 E1              	   399: 	pop		HL
01:8483 D1              	   400: 	pop		DE
01:8484 C1              	   401: 	pop		BC
01:8485 F1              	   402: 	pop		AF
01:8486 C9              	   403: 	ret
                        	   404: 
                        	   405: 
                        	   406: ;  _   _                 ____                              
                        	   407: ; | | | |   ___  __  __ |  _ \   _   _   _ __ ___    _ __  
                        	   408: ; | |_| |  / _ \ \ \/ / | | | | | | | | | '_ ` _ \  | '_ \ 
                        	   409: ; |  _  | |  __/  >  <  | |_| | | |_| | | | | | | | | |_) |
                        	   410: ; |_| |_|  \___| /_/\_\ |____/   \__,_| |_| |_| |_| | .__/ 
                        	   411: ;                                                   |_|    
                        	   412: ;
                        	   413: ; *********************************************************************************************************************
                        	   414: ; Prints the content of memory to serial port A
                        	   415: ; Parameters:	[AAAA], [LL] (where AAAA is the address to start displaying, and LL is the number of lines to display)
                        	   416: ; *********************************************************************************************************************
                        	   417: ;
                        	   418: ; Registers and variables used:
                        	   419: ;	- B is the number of bytes/characters per line
                        	   420: ;	- C is the line counter per page
                        	   421: ;	- DE is the number of lines to print
                        	   422: ;	- HL is the address to display
                        	   423: 
                        	   424: ; Wish list:
                        	   425: ;	- End at $FFFF
                        	   426: ;	- When more then a page long, pause every page and wait for ENTER to continues, or ESC to quit
                        	   427: 
                        	   428: HexDump:
01:8487 F5              	   429: 	push	AF
01:8488 C5              	   430: 	push	BC
01:8489 D5              	   431: 	push	DE
01:848A E5              	   432: 	push	HL
                        	   433: 	
01:848B 2A86B0          	   434: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:848E CDC988          	   435: 	call	GetHexParameter			; Get the first parameter: the address to display
01:8491 306B            	   436: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:8493 FE0F            	   437: 	cp		HELP
01:8495 2861            	   438: 	jr		z,HexDumpPrintHelp
01:8497 FE00            	   439: 	cp		0						; Is there a parameter?
01:8499 2004            	   440: 	jr		nz,HexLinesToRead		; If There's a parameter, go check second parameter
01:849B ED4B8AB0        	   441: 	ld		BC,(CurrentAddress)		; Since it's no parameter, then place CurrentAddress as default address
                        	   442: 
                        	   443: HexLinesToRead:
01:849F C5              	   444: 	push	BC						; Save the first parameter's address...
01:84A0 D1              	   445: 	pop		DE						;    to be later recovered as HL
01:84A1 CDC988          	   446: 	call	GetHexParameter			; Get the secode parameter: the number of lines to display
01:84A4 3058            	   447: 	jr		nc,HexDumpEnd			; Exit routine if there was an error in the parameter
01:84A6 FE00            	   448: 	cp		0						; Is there a parameter?
01:84A8 2808            	   449: 	jr		z,HexDefaultLines		; There is no parameter, so go load the default line number
01:84AA FE01            	   450: 	cp		1						; Is it a one byte parameter
01:84AC 2806            	   451: 	jr		z,HexDisplayContent		; If it is, C already contains the number of lines, so start printing content
01:84AE 0EFF            	   452: 	ld		C,$FF					; Else, if it's a 2 byte or more parameter, set maximum lines to $FF
01:84B0 1802            	   453: 	jr		HexDisplayContent		; Start printing hex dump
                        	   454: HexDefaultLines:
01:84B2 0E15            	   455: 	ld		C,VertTextRes-3			; Get number of vertical lines
                        	   456: 
                        	   457: HexDisplayContent:
01:84B4 EB              	   458: 	ex		DE,HL					; Restore address from first parameter read
                        	   459: 	
                        	   460: ; PRINT ADDRESS AT BEGINNING
                        	   461: HexNextLine:
01:84B5 E5              	   462: 	push	HL						; Save HL for later use (character portion of memory dump)
01:84B6 CDBC80          	   463: 	call	PrintWord				; Print address
01:84B9 0608            	   464: 	ld		B,8						; Setup byte counter per line
01:84BB 3E3A            	   465: 	ld		A,":"
01:84BD CD7480          	   466: 	call	PrintChar				; Print colon
01:84C0 3E20            	   467: 	ld		A," "
01:84C2 CD7480          	   468: 	call	PrintChar				; Print space
                        	   469: 
                        	   470: ; PRINT EIGHT BYTES
                        	   471: HexNextByte:
01:84C5 7E              	   472: 	ld		A,(HL)
01:84C6 CD6180          	   473: 	call	PrintByte				; Print byte contained in address HL
01:84C9 3E20            	   474: 	ld		A," "
01:84CB CD7480          	   475: 	call	PrintChar				; Print space
01:84CE 23              	   476: 	inc		HL						; Increment HL for next byte
01:84CF 05              	   477: 	dec		B						; Decrement byte counter
01:84D0 20F3            	   478: 	jr		nz,HexNextByte			; If the 8 bytes have not all been printed, then loop again
                        	   479: 
                        	   480: ; PRINT EIGHT CHARACTERS
01:84D2 CD7480          	   481: 	call	PrintChar				; Print an extra space (to space out bytes from character printout)
01:84D5 0608            	   482: 	ld		B,8						; Reset the counter to count characters instead
01:84D7 E1              	   483: 	pop		HL						; Reset HL so we can print the characters instead of the bytes at the end of the line
                        	   484: HexNextChar:
01:84D8 7E              	   485: 	ld		A,(HL)
01:84D9 FE20            	   486: 	cp		$20						; Compare A with first displayable character
01:84DB 3806            	   487: 	jr		c,HexReplaceDot			; If it's lower, then replace with a period
01:84DD FE7F            	   488: 	cp		$7F						; Is it higher or equal to the DEL character?
01:84DF 3002            	   489: 	jr		nc,HexReplaceDot		; Then replace that with a period
01:84E1 1802            	   490: 	jr		HexPrintChar
                        	   491: HexReplaceDot:
01:84E3 3E2E            	   492: 	ld		A,"."					; No, then replace it with a period
                        	   493: HexPrintChar:
01:84E5 CD7480          	   494: 	call	PrintChar				; Print the character representation of the byte
01:84E8 23              	   495: 	inc		HL						; Increment HL for next character
01:84E9 05              	   496: 	dec		B						; Decrement character counter
01:84EA 20EC            	   497: 	jr		nz,HexNextChar			; If the 8 characters have not all been printed, then loop again
01:84EC CD7F80          	   498: 	call	PrintCRLF				; Change line
01:84EF 0D              	   499: 	dec		C						; 
01:84F0 C2B584          	   500: 	jp		nz,HexNextLine
01:84F3 228AB0          	   501: 	ld		(CurrentAddress),HL		; Save Current Address to where Hex left off
01:84F6 1806            	   502: 	jr		HexDumpEnd
                        	   503: 	
                        	   504: HexDumpPrintHelp:
01:84F8 214BAF          	   505: 	ld		HL,HexDumpHelp
01:84FB CDAE80          	   506: 	call	PrintString
                        	   507: 	
                        	   508: HexDumpEnd:
01:84FE E1              	   509: 	pop		HL
01:84FF D1              	   510: 	pop		DE
01:8500 C1              	   511: 	pop		BC
01:8501 F1              	   512: 	pop		AF
01:8502 C9              	   513: 	ret
                        	   514: 
                        	   515: 
                        	   516: ;  ___           _            _   _   _               
                        	   517: ; |_ _|  _ __   | |_    ___  | | | | | |   ___  __  __
                        	   518: ;  | |  | '_ \  | __|  / _ \ | | | |_| |  / _ \ \ \/ /
                        	   519: ;  | |  | | | | | |_  |  __/ | | |  _  | |  __/  >  < 
                        	   520: ; |___| |_| |_|  \__|  \___| |_| |_| |_|  \___| /_/\_\
                        	   521: ;
                        	   522: 
                        	   523: ; *********************************************************************************************************************
                        	   524: ; Transfer programs via Intel Hex (i8HEX) - Press ESC to exit
                        	   525: ; - Input:	Upload an i8Hex file from a terminal program on your computer (Transfer File)
                        	   526: ; - Output:	Sets (CurrentAddress) variable to the start address declared in the IntelHex file
                        	   527: 
                        	   528: ; File Format:	SBBAAAARRDDDDDDCC termintated by (CR) and/or (LF)
                        	   529: ;				:0300300002337A1E
                        	   530: ;					S = : is the start code
                        	   531: ;					BB = it the data byte count ($20 is the typical)
                        	   532: ;					AAAA = The 16-bit beginning memory address offset of the data
                        	   533: ;					RR = Record type, 00 = Data, 01 = End of File
                        	   534: ;					DD = Data
                        	   535: ;					CC = Checksum from BB to the last DD (Two's complement)
                        	   536: ; *********************************************************************************************************************
                        	   537: ;	- B = Byte couter
                        	   538: ;	- C = Checksum
                        	   539: ;	- D = Flags (Start address, Checksum error, Last record)
                        	   540: ;	- HL = Address offset pointer
                        	   541: 
                        	   542: StartAddr	= 0						; Start address flag bit
                        	   543: ChecksumErr	= 1						; Checksum error flag bit
                        	   544: LastRec		= 7						; Last record flag bit
                        	   545: 
                        	   546: IntelHex:
01:8503 F5              	   547: 	push	AF
01:8504 C5              	   548: 	push	BC
01:8505 D5              	   549: 	push	DE
01:8506 E5              	   550: 	push	HL
01:8507 DDE5            	   551: 	push	IX
                        	   552: 	
01:8509 CD378B          	   553: 	call	SkipSpaces
01:850C 7E              	   554: 	ld		A,(HL)					; Read a character form the CommandBuffer	
01:850D FE0F            	   555: 	cp		HELP
01:850F CAC685          	   556: 	jp		z,IntelHexPrintHelp
                        	   557: 
01:8512 2174AE          	   558: 	ld		HL,IntelHexLoadMsg		; Print load message, or ESC to exit
01:8515 CDAE80          	   559: 	call	PrintString				;
01:8518 1600            	   560: 	ld		D,0						; Clear the flags register
01:851A DD210000        	   561: 	ld		IX,0					; Clear byte counter
01:851E DD22AEB0        	   562: 	ld		(UserCodeSize),IX		; Clear user code byte counter
                        	   563: 	
                        	   564: ; *** START CODE
                        	   565: IntelHexStartCode:
01:8522 CDC780          	   566: 	call	ReadChar				; Read a character form the console
01:8525 FE1B            	   567: 	cp		ESC						; Did the user press ESCAPE?
01:8527 CAA885          	   568: 	jp		z,IntelHexAbort			; Yes, then exit
01:852A FE3A            	   569: 	cp		":"						; Is it the start code
01:852C 2802            	   570: 	jr		z,IntelHexByteCount		; Yes, then read byte count
01:852E 18F2            	   571: 	jr		IntelHexStartCode		; No, then read a new character until ":" is present
                        	   572: 	
                        	   573: ; *** BYTE COUNT
                        	   574: IntelHexByteCount:
01:8530 CDDB80          	   575: 	call	ReadByte				; Read the byte count
01:8533 47              	   576: 	ld		B,A						; Store byte counter in B
01:8534 4F              	   577: 	ld		C,A						; copy value of accumulator in checksum register
                        	   578: 
                        	   579: ; *** ADDRESS
                        	   580: IntelHexAddress:
01:8535 CDDB80          	   581: 	call	ReadByte				; Read the MSB characters and convert it to a byte
01:8538 67              	   582: 	ld		H,A						; Store the address's MSB
01:8539 81              	   583: 	add		C						; Add checksum
01:853A 4F              	   584: 	ld		C,A						; Store back result in checksum accumulator
01:853B CDDB80          	   585: 	call	ReadByte				; Read the LSB characters and convert it to a byte
01:853E 6F              	   586: 	ld		L,A						; Store the address's LSB
01:853F 81              	   587: 	add		C						; Add checksum
01:8540 4F              	   588: 	ld		C,A						; Store back result in checksum accumulator
01:8541 CB42            	   589: 	bit		StartAddr,D				; Check if it's the first time the address has been read...
01:8543 2005            	   590: 	jr		nz,IntelHexRecordType	;	If it's not the first line, then go get record type
01:8545 228AB0          	   591: 	ld		(CurrentAddress),HL		; Else store the starting address
01:8548 CBC2            	   592: 	set		StartAddr,D				; Set first line start address flag
                        	   593: ;	ld		E,1						; Set first pass flag
                        	   594: 
                        	   595: ; *** RECORD TYPE
                        	   596: IntelHexRecordType:
01:854A CDDB80          	   597: 	call	ReadByte				; Read the record type byte
01:854D F5              	   598: 	push	AF
01:854E 81              	   599: 	add		C						; Add checksum
01:854F 4F              	   600: 	ld		C,A						; Store back result in checksum accumulator
01:8550 F1              	   601: 	pop		AF
01:8551 FE00            	   602: 	cp		00						; Is it data?
01:8553 2808            	   603: 	jr		z,IntelHexData
01:8555 FE01            	   604: 	cp		01						; Is it the end of file record type
01:8557 2057            	   605: 	jr		nz,IntelHexUnsupported		
01:8559 CBFA            	   606: 	set		LastRec,D	
01:855B 180B            	   607: 	jr		IntelHexChecksum		; Get checksum
                        	   608: 
                        	   609: ; *** DATA
                        	   610: IntelHexData:
01:855D CDDB80          	   611: 	call	ReadByte				; Get data byte
01:8560 77              	   612: 	ld		(HL),A					; Store data byte in memory
01:8561 23              	   613: 	inc		HL						; Point to the next address
01:8562 DD23            	   614: 	inc		IX						; Count the total number of bytes
01:8564 81              	   615: 	add		C						; Add checksum
01:8565 4F              	   616: 	ld		C,A						; Store back result in checksum accumulator
01:8566 10F5            	   617: 	djnz	IntelHexData			; Decrement count, and go to next data if not finished
                        	   618: 
                        	   619: ; *** CHECKSUM
                        	   620: IntelHexChecksum:
01:8568 CDDB80          	   621: 	call	ReadByte				; Read the checksum for that record
01:856B ED44            	   622: 	neg								; Do a 2s compliment on A (saves instructions if I swapped C with A)
01:856D B9              	   623: 	cp		C						; Compare the transmited checksum with the calculated checksum
01:856E 2806            	   624: 	jr		z,IntelHexCheckOk		; Is it the same?
01:8570 3E78            	   625: 	ld		A,"x"					; Display an "x" if checksum do not match
01:8572 CBCA            	   626: 	set		ChecksumErr,D			; Indicate an error in checksum flag
01:8574 1802            	   627: 	jr		IntelHexPrintStatus		;
                        	   628: IntelHexCheckOk:
01:8576 3E2E            	   629: 	ld		A,"."					; Display a "." if checksum is a match
                        	   630: IntelHexPrintStatus:
01:8578 CD7480          	   631: 	call	PrintChar				; Print the checksum validity character
01:857B CB7A            	   632: 	bit		LastRec,D				; Check if it's the last record
01:857D CA2285          	   633: 	jp		z,IntelHexStartCode		; No, then continue reading more lines
01:8580 CDC780          	   634: 	call	ReadChar				; Flush CR
                        	   635: 
                        	   636: IntelHexPrintEndMsg:
01:8583 CD7F80          	   637: 	call	PrintCRLF
01:8586 2155AE          	   638: 	ld		HL,IntelHexFinishedMsg	; Print the end message
01:8589 CDAE80          	   639: 	call	PrintString
01:858C 2165AE          	   640: 	ld		HL,IntelHexSuccessMsg	; Point to "unsuccessful"
01:858F CB4A            	   641: 	bit		ChecksumErr,D			; Cneck if there was an error that was flagged
01:8591 2002            	   642: 	jr		nz,IntelHexPrintNotOk	; If the ChecksumErr flag was set, then print unsuccessful
01:8593 23              	   643: 	inc		HL						; Push pointer to letters..
01:8594 23              	   644: 	inc		HL						;   so it becomes "successful"
                        	   645: IntelHexPrintNotOk:
01:8595 CDAE80          	   646: 	call	PrintString				; Print the sucess level
01:8598 E5              	   647: 	push	HL
01:8599 DDE5            	   648: 	push	IX						; Copy byte counter
01:859B E1              	   649: 	pop		HL						; To HL to be printed
01:859C CD5880          	   650: 	call	PrintDec				; Print the decimal number
01:859F 21CCAE          	   651: 	ld		HL,DownloadedBytesMsg	; 
01:85A2 CDAE80          	   652: 	call	PrintString				; Print bytes loaded text
01:85A5 E1              	   653: 	pop		HL
01:85A6 1824            	   654: 	jr		IntelHexEnd				; And end load
                        	   655: 
                        	   656: IntelHexAbort:
01:85A8 21B1AE          	   657: 	ld		HL,IntelHexAbortedMsg	; Abort message
01:85AB CDAE80          	   658: 	call	PrintString				;
01:85AE 181C            	   659: 	jr		IntelHexEnd
                        	   660: 
                        	   661: IntelHexUnsupported:
01:85B0 2122AD          	   662: 	ld		HL,IntelHexUnsupportedErr	; Unsupported record type message
01:85B3 CDAE80          	   663: 	call	PrintString				;
01:85B6 CD6180          	   664: 	call	PrintByte				; Print the record number
01:85B9 CD7F80          	   665: 	call	PrintCRLF
01:85BC 180E            	   666: 	jr		IntelHexEnd
                        	   667: 
                        	   668: IntelHexParamError:
01:85BE 21E8AC          	   669: 	ld		HL,UnrecognizedParamErr
01:85C1 CDAE80          	   670: 	call	PrintString
01:85C4 1806            	   671: 	jr		IntelHexEnd
                        	   672: 
                        	   673: IntelHexPrintHelp:
01:85C6 21B0AF          	   674: 	ld		HL,IntelHexHelp
01:85C9 CDAE80          	   675: 	call	PrintString
                        	   676: 	
                        	   677: IntelHexEnd:
01:85CC DDE1            	   678: 	pop		IX
01:85CE E1              	   679: 	pop		HL
01:85CF D1              	   680: 	pop		DE
01:85D0 C1              	   681: 	pop		BC
01:85D1 F1              	   682: 	pop		AF
01:85D2 C9              	   683: 	ret
                        	   684: 
                        	   685: 
                        	   686: ;  _       _         _   
                        	   687: ; | |     (_)  ___  | |_ 
                        	   688: ; | |     | | / __| | __|
                        	   689: ; | |___  | | \__ \ | |_ 
                        	   690: ; |_____| |_| |___/  \__|
                        	   691: 
                        	   692: 
                        	   693: ; *********************************************************************************************************************
                        	   694: ; Prints a list of available commands
                        	   695: ; *********************************************************************************************************************
                        	   696: 
                        	   697: ListCmd:
01:85D3 E5              	   698: 	push	HL
01:85D4 212CA9          	   699: 	ld		HL,ListOfCommands
01:85D7 CDAE80          	   700: 	call	PrintString				; Print first line
01:85DA CD8C80          	   701: 	call	PrintLine				; Print a line
01:85DD CDAE80          	   702: 	call	PrintString				; Print the rest
01:85E0 E1              	   703: 	pop		HL
01:85E1 C9              	   704: 	ret
                        	   705: 
                        	   706: 
                        	   707: ;  ____                  _    
                        	   708: ; |  _ \    ___    ___  | | __
                        	   709: ; | |_) |  / _ \  / _ \ | |/ /
                        	   710: ; |  __/  |  __/ |  __/ |   < 
                        	   711: ; |_|      \___|  \___| |_|\_\
                        	   712: 
                        	   713: 
                        	   714: ; *********************************************************************************************************************
                        	   715: ; Read a byte of memory
                        	   716: ; *********************************************************************************************************************
                        	   717: 
                        	   718: PeekCmd:
01:85E2 F5              	   719: 	push	AF
01:85E3 C5              	   720: 	push	BC
01:85E4 E5              	   721: 	push	HL
                        	   722: 	
01:85E5 2A86B0          	   723: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   724: 	
                        	   725: PeekAddress:
01:85E8 CDC988          	   726: 	call	GetHexParameter			; Get the first parameter, start address
01:85EB D20D86          	   727: 	jp		nc,PeekEnd				; Exit routine if there was an error in the parameter
01:85EE FE00            	   728: 	cp		0						; Is there a first parameter?
01:85F0 2802            	   729: 	jr		z,PeekDefault			; No, then print error message
01:85F2 1804            	   730: 	jr		PeekRead
                        	   731: 
                        	   732: PeekDefault
01:85F4 ED4B8AB0        	   733: 	ld		BC,(CurrentAddress)
                        	   734: 
                        	   735: PeekRead:
01:85F8 C5              	   736: 	push	BC
01:85F9 E1              	   737: 	pop		HL
01:85FA CDBC80          	   738: 	call	PrintWord
01:85FD 3E3A            	   739: 	ld		A,":"
01:85FF CD7480          	   740: 	call	PrintChar
01:8602 0A              	   741: 	ld		A,(BC)
01:8603 CD6180          	   742: 	call	PrintByte
01:8606 CD7F80          	   743: 	call	PrintCRLF
01:8609 ED438AB0        	   744: 	ld		(CurrentAddress),BC
                        	   745: 
                        	   746: PeekEnd
01:860D E1              	   747: 	pop		HL
01:860E C1              	   748: 	pop		BC
01:860F F1              	   749: 	pop		AF
01:8610 C9              	   750: 	ret
                        	   751: 
                        	   752: 
                        	   753: ;  ____            _           
                        	   754: ; |  _ \    ___   | | __   ___ 
                        	   755: ; | |_) |  / _ \  | |/ /  / _ \
                        	   756: ; |  __/  | (_) | |   <  |  __/
                        	   757: ; |_|      \___/  |_|\_\  \___|
                        	   758: 
                        	   759: 
                        	   760: ; *********************************************************************************************************************
                        	   761: ; Write a byte to a specific memory address
                        	   762: ;	- Input:	Parameters: Address & Byte
                        	   763: ; *********************************************************************************************************************
                        	   764: 
                        	   765: PokeCmd:
01:8611 F5              	   766: 	push 	AF
01:8612 C5              	   767: 	push	BC
01:8613 E5              	   768: 	push	HL
                        	   769: 	
01:8614 2A86B0          	   770: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	   771: 	
                        	   772: PokeAddress:
01:8617 CDC988          	   773: 	call	GetHexParameter			; Get the first parameter, start address
01:861A D24A86          	   774: 	jp		nc,PokeEnd				; Exit routine if there was an error in the parameter
01:861D FE00            	   775: 	cp		0						; Is there a first parameter?
01:861F 2826            	   776: 	jr		z,PokeNoParameter		; No, then print error message
01:8621 ED43A5B0        	   777: 	ld		(StartAddress),BC		; Store start address
                        	   778: 	
                        	   779: PokeByte:
01:8625 CDC988          	   780: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8628 3020            	   781: 	jr		nc,PokeEnd				; Exit routine if there was an error in the parameter
01:862A FE00            	   782: 	cp		0						; Is there a third parameter?
01:862C 2819            	   783: 	jr		z,PokeNoParameter		; No, then print error message
01:862E 79              	   784: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
                        	   785: 
                        	   786: PokeWrite:
01:862F 2AA5B0          	   787: 	ld		HL,(StartAddress)
01:8632 77              	   788: 	ld		(HL),A
01:8633 CDBC80          	   789: 	call	PrintWord
01:8636 3E3A            	   790: 	ld		A,":"
01:8638 CD7480          	   791: 	call	PrintChar
01:863B 79              	   792: 	ld		A,C
01:863C CD6180          	   793: 	call	PrintByte
01:863F CD7F80          	   794: 	call	PrintCRLF
01:8642 228AB0          	   795: 	ld		(CurrentAddress),HL
01:8645 1803            	   796: 	jr		PokeEnd
                        	   797: 
                        	   798: PokeNoParameter:
01:8647 CD20B0          	   799: 	call	NoParameter
                        	   800: 	
                        	   801: PokeEnd
01:864A E1              	   802: 	pop		HL
01:864B C1              	   803: 	pop		BC
01:864C F1              	   804: 	pop		AF
01:864D C9              	   805: 	ret
                        	   806: 
                        	   807: 
                        	   808: ;  ____                   _         _                       
                        	   809: ; |  _ \    ___    __ _  (_)  ___  | |_    ___   _ __   ___ 
                        	   810: ; | |_) |  / _ \  / _` | | | / __| | __|  / _ \ | '__| / __|
                        	   811: ; |  _ <  |  __/ | (_| | | | \__ \ | |_  |  __/ | |    \__ \
                        	   812: ; |_| \_\  \___|  \__, | |_| |___/  \__|  \___| |_|    |___/
                        	   813: ;                 |___/                                     
                        	   814: 
                        	   815: ; *********************************************************************************************************************
                        	   816: ; Prints the contents of the registers on the console
                        	   817: ; *********************************************************************************************************************
                        	   818: ;
                        	   819: ; Wish list:
                        	   820: ;	- Modify individual registers
                        	   821: 
                        	   822: Registers:
01:864E ED73A2B0        	   823: 	ld		(StackPtr),SP			; Save the stack pointer
01:8652 F5              	   824: 	push	AF
01:8653 C5              	   825: 	push	BC
01:8654 D5              	   826: 	push	DE
01:8655 E5              	   827: 	push	HL
01:8656 DDE5            	   828: 	push	IX
01:8658 FDE5            	   829: 	push	IY
                        	   830: 	
01:865A F5              	   831: 	push	AF						; Save the flags (to be restored in C later)
01:865B 3297B0          	   832: 	ld		(RegA),A				; Save A
01:865E ED4398B0        	   833: 	ld		(RegBC),BC				; Save BC
01:8662 ED539AB0        	   834: 	ld		(RegDE),DE				; Save DE
01:8666 229CB0          	   835: 	ld		(RegHL),HL				; Save HL
01:8669 DD229EB0        	   836: 	ld		(RegIX),IX				; Save IX
01:866D FD22A0B0        	   837: 	ld		(RegIY),IY				; Save IY
01:8671 C1              	   838: 	pop		BC						; Restore AF in BC to get the flags
01:8672 79              	   839: 	ld		A,C
01:8673 32A4B0          	   840: 	ld		(FlagsReg),A			; Save the flags register
                        	   841: 	
                        	   842: 	; PRINT THE ACCUMULATOR
01:8676 3E41            	   843: 	ld		A,"A"
01:8678 CD7480          	   844: 	call	PrintChar
01:867B 3E3A            	   845: 	ld		A,":"
01:867D CD7480          	   846: 	call	PrintChar
01:8680 3A97B0          	   847: 	ld		A,(RegA)
01:8683 CD6180          	   848: 	call	PrintByte
01:8686 3E20            	   849: 	ld		A," "
01:8688 CD7480          	   850: 	call	PrintChar
                        	   851: 
                        	   852: 	; PRINT BC REGISTER PAIR
01:868B 3E42            	   853: 	ld		A,"B"
01:868D CD7480          	   854: 	call	PrintChar
01:8690 3E43            	   855: 	ld		A,"C"
01:8692 CD7480          	   856: 	call	PrintChar
01:8695 3E3A            	   857: 	ld		A,":"
01:8697 CD7480          	   858: 	call	PrintChar
01:869A 2A98B0          	   859: 	ld		HL,(RegBC)
01:869D CDBC80          	   860: 	call	PrintWord
01:86A0 3E20            	   861: 	ld		A," "
01:86A2 CD7480          	   862: 	call	PrintChar
                        	   863: 
                        	   864: 	; PRINT DE REGISTER PAIR
01:86A5 3E44            	   865: 	ld		A,"D"
01:86A7 CD7480          	   866: 	call	PrintChar
01:86AA 3E45            	   867: 	ld		A,"E"
01:86AC CD7480          	   868: 	call	PrintChar
01:86AF 3E3A            	   869: 	ld		A,":"
01:86B1 CD7480          	   870: 	call	PrintChar
01:86B4 2A9AB0          	   871: 	ld		HL,(RegDE)
01:86B7 CDBC80          	   872: 	call	PrintWord
01:86BA 3E20            	   873: 	ld		A," "
01:86BC CD7480          	   874: 	call	PrintChar
                        	   875: 
                        	   876: 	; PRINT HL REGISTER PAIR
01:86BF 3E48            	   877: 	ld		A,"H"
01:86C1 CD7480          	   878: 	call	PrintChar
01:86C4 3E4C            	   879: 	ld		A,"L"
01:86C6 CD7480          	   880: 	call	PrintChar
01:86C9 3E3A            	   881: 	ld		A,":"
01:86CB CD7480          	   882: 	call	PrintChar
01:86CE 2A9CB0          	   883: 	ld		HL,(RegHL)
01:86D1 CDBC80          	   884: 	call	PrintWord
01:86D4 CD7F80          	   885: 	call	PrintCRLF
                        	   886: 
                        	   887: 	; PRINT IX INDEX REGISTER
01:86D7 3E49            	   888: 	ld		A,"I"
01:86D9 CD7480          	   889: 	call	PrintChar
01:86DC 3E58            	   890: 	ld		A,"X"
01:86DE CD7480          	   891: 	call	PrintChar
01:86E1 3E3A            	   892: 	ld		A,":"
01:86E3 CD7480          	   893: 	call	PrintChar
01:86E6 2A9EB0          	   894: 	ld		HL,(RegIX)
01:86E9 CDBC80          	   895: 	call	PrintWord
01:86EC 3E20            	   896: 	ld		A," "
01:86EE CD7480          	   897: 	call	PrintChar
                        	   898: 
                        	   899: 	; PRINT IY INDEX REGISTER
01:86F1 3E49            	   900: 	ld		A,"I"
01:86F3 CD7480          	   901: 	call	PrintChar
01:86F6 3E59            	   902: 	ld		A,"Y"
01:86F8 CD7480          	   903: 	call	PrintChar
01:86FB 3E3A            	   904: 	ld		A,":"
01:86FD CD7480          	   905: 	call	PrintChar
01:8700 2AA0B0          	   906: 	ld		HL,(RegIY)
01:8703 CDBC80          	   907: 	call	PrintWord
01:8706 3E20            	   908: 	ld		A," "
01:8708 CD7480          	   909: 	call	PrintChar
                        	   910: 
                        	   911: 	; PRINT THE STACK POINTER
01:870B 3E53            	   912: 	ld		A,"S"
01:870D CD7480          	   913: 	call	PrintChar
01:8710 3E50            	   914: 	ld		A,"P"
01:8712 CD7480          	   915: 	call	PrintChar
01:8715 3E3A            	   916: 	ld		A,":"
01:8717 CD7480          	   917: 	call	PrintChar
01:871A 2AA2B0          	   918: 	ld		HL,(StackPtr)
01:871D 23              	   919: 	inc		HL						; Offset stack by 2 to compensate for...
01:871E 23              	   920: 	inc		HL						;	this routine's call
01:871F CDBC80          	   921: 	call	PrintWord
01:8722 3E20            	   922: 	ld		A," "
01:8724 CD7480          	   923: 	call	PrintChar
                        	   924: 
                        	   925: 	; PRINT THE FLAGS
01:8727 3E46            	   926: 	ld		A,"F"
01:8729 CD7480          	   927: 	call	PrintChar
01:872C 3E3A            	   928: 	ld		A,":"
01:872E CD7480          	   929: 	call	PrintChar
01:8731 2181AB          	   930: 	ld		HL,FlagBits
                        	   931: 
                        	   932: 	; Sign
01:8734 7E              	   933: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8735 CB79            	   934: 	bit		Sign,C					; Check to the associated bit is set or not
01:8737 2803            	   935: 	jr		z,FlagSignClear			; If it's Set, then print lower case
01:8739 CD9F82          	   936: 	call	UpperCase				; Else, print upper case
                        	   937: FlagSignClear:
01:873C CD7480          	   938: 	call	PrintChar				; Print the flag symbol
01:873F 23              	   939: 	inc		HL						; Point to the next symbol
                        	   940: 	
                        	   941: 	; Zero
01:8740 7E              	   942: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8741 CB71            	   943: 	bit		Zero,C					; Check to the associated bit is set or not
01:8743 2803            	   944: 	jr		z,FlagZeroClear			; If it's Set, then print lower case
01:8745 CD9F82          	   945: 	call	UpperCase				; Else, print upper case
                        	   946: FlagZeroClear:
01:8748 CD7480          	   947: 	call	PrintChar				; Print the flag symbol
01:874B 23              	   948: 	inc		HL						; Point to the next symbol
                        	   949: 	
                        	   950: 	; Half-Carry
01:874C 7E              	   951: 	ld		A,(HL)					; Load the lowercase flag symbol
01:874D CB61            	   952: 	bit		HalfCarry,C				; Check to the associated bit is set or not
01:874F 2803            	   953: 	jr		z,FlagHalfClear			; If it's Set, then print lower case
01:8751 CD9F82          	   954: 	call	UpperCase				; Else, print upper case
                        	   955: FlagHalfClear:
01:8754 CD7480          	   956: 	call	PrintChar				; Print the flag symbol
01:8757 23              	   957: 	inc		HL						; Point to the next symbol
                        	   958: 	
                        	   959: 	; Overflow/Parity
01:8758 7E              	   960: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8759 CB51            	   961: 	bit		Overflow,C				; Check to the associated bit is set or not
01:875B 2803            	   962: 	jr		z,FlagOverClear			; If it's Set, then print lower case
01:875D CD9F82          	   963: 	call	UpperCase				; Else, print upper case
                        	   964: FlagOverClear:
01:8760 CD7480          	   965: 	call	PrintChar				; Print the flag symbol
01:8763 23              	   966: 	inc		HL						; Point to the next symbol
                        	   967: 	
                        	   968: 	; Add/Substract
01:8764 7E              	   969: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8765 CB49            	   970: 	bit		Negative,C				; Check to the associated bit is set or not
01:8767 2803            	   971: 	jr		z,FlagNegativeClear		; If it's Set, then print lower case
01:8769 CD9F82          	   972: 	call	UpperCase				; Else, print upper case
                        	   973: FlagNegativeClear:
01:876C CD7480          	   974: 	call	PrintChar				; Print the flag symbol
01:876F 23              	   975: 	inc		HL						; Point to the next symbol
                        	   976: 	
                        	   977: 	; Carry
01:8770 7E              	   978: 	ld		A,(HL)					; Load the lowercase flag symbol
01:8771 CB41            	   979: 	bit		Carry,C					; Check to the associated bit is set or not
01:8773 2803            	   980: 	jr		z,FlagCarryClear		; If it's Set, then print lower case
01:8775 CD9F82          	   981: 	call	UpperCase				; Else, print upper case
                        	   982: FlagCarryClear:
01:8778 CD7480          	   983: 	call	PrintChar				; Print the flag symbol
01:877B 23              	   984: 	inc		HL						; Point to the next symbol
                        	   985: 
01:877C CD7F80          	   986: 	call	PrintCRLF
                        	   987: 
01:877F FDE1            	   988: 	pop		IY
01:8781 DDE1            	   989: 	pop		IX
01:8783 E1              	   990: 	pop		HL
01:8784 D1              	   991: 	pop		DE
01:8785 C1              	   992: 	pop		BC
01:8786 F1              	   993: 	pop		AF
01:8787 C9              	   994: 	ret
                        	   995: 
                        	   996: 
                        	   997: ;  ____                  
                        	   998: ; |  _ \   _   _   _ __  
                        	   999: ; | |_) | | | | | | '_ \ 
                        	  1000: ; |  _ <  | |_| | | | | |
                        	  1001: ; |_| \_\  \__,_| |_| |_|
                        	  1002: 
                        	  1003: 
                        	  1004: ; *********************************************************************************************************************
                        	  1005: ; Executes code at a specific address, clearing the registers at the beginning
                        	  1006: ; Parameter:	[AAAA], where AAAA is an optional address to execute from. Defaults to CurrentAddress
                        	  1007: ; *********************************************************************************************************************
                        	  1008: 
                        	  1009: RunCode:
01:8788 2A86B0          	  1010: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
01:878B CDC988          	  1011: 	call	GetHexParameter			; Get the parameter
01:878E 300A            	  1012: 	jr		nc,RunEnd				; If there's an error in getting the parameter, then exit
01:8790 FE00            	  1013: 	cp		0						; Is there a parameter?
01:8792 2004            	  1014: 	jr		nz,RunCallBC			; There's a valid parameter, then execute user code
01:8794 ED4B8AB0        	  1015: 	ld		BC,(CurrentAddress)		; Load the CurrentAddress in BC
                        	  1016: 
                        	  1017: RunCallBC:
01:8798 C5              	  1018: 	push	BC						; Put execution address in the stack, see bellow "ret" acting as a "call (BC)"
01:8799 C9              	  1019: 	ret								; Above "push BC" without "pop", "ret" acts as an indirect "call (BC)"
                        	  1020: 
                        	  1021: RunEnd:
01:879A C9              	  1022: 	ret
                        	  1023: 
                        	  1024: 
                        	  1025: ;  ____           _        _          _       _                           
                        	  1026: ; / ___|    ___  | |_     / \      __| |   __| |  _ __    ___   ___   ___ 
                        	  1027: ; \___ \   / _ \ | __|   / _ \    / _` |  / _` | | '__|  / _ \ / __| / __|
                        	  1028: ;  ___) | |  __/ | |_   / ___ \  | (_| | | (_| | | |    |  __/ \__ \ \__ \
                        	  1029: ; |____/   \___|  \__| /_/   \_\  \__,_|  \__,_| |_|     \___| |___/ |___/
                        	  1030: 
                        	  1031: 
                        	  1032: ; *********************************************************************************************************************
                        	  1033: ; Set current address from the command prompt
                        	  1034: ;	- Input:	An optional address parameter, defaults to $0000
                        	  1035: ; *********************************************************************************************************************
                        	  1036: 
                        	  1037: SetAddress:
01:879B F5              	  1038: 	push	AF
01:879C C5              	  1039: 	push	BC
01:879D D5              	  1040: 	push	DE
01:879E E5              	  1041: 	push	HL
                        	  1042: 	
01:879F 2A86B0          	  1043: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87A2 CDC988          	  1044: 	call	GetHexParameter			; Get a parameter
01:87A5 3010            	  1045: 	jr		nc,SetAddressEnd		; Exit routine if there was an error in the parameter
01:87A7 FE00            	  1046: 	cp		0						; Is there a parameter returned?
01:87A9 2806            	  1047: 	jr		z,SetAddressDefault		; If there is none, select default address
01:87AB ED438AB0        	  1048: 	ld		(CurrentAddress),BC		; Save address in parameter (BC or C) in CurrentAddress global variable
01:87AF 1806            	  1049: 	jr		SetAddressEnd
                        	  1050: 
                        	  1051: SetAddressDefault:
01:87B1 210000          	  1052: 	ld		HL,0					; Default address is $0000
01:87B4 228AB0          	  1053: 	ld		(CurrentAddress),HL		; Save it in CurrentAddress global variable
                        	  1054: 
                        	  1055: SetAddressEnd:
01:87B7 E1              	  1056: 	pop		HL
01:87B8 D1              	  1057: 	pop		DE
01:87B9 C1              	  1058: 	pop		BC
01:87BA F1              	  1059: 	pop		AF
                        	  1060: 	
01:87BB C9              	  1061: 	ret
                        	  1062: 	
                        	  1063: 
                        	  1064: ;  ____           _     ____                    _    
                        	  1065: ; / ___|    ___  | |_  | __ )    __ _   _ __   | | __
                        	  1066: ; \___ \   / _ \ | __| |  _ \   / _` | | '_ \  | |/ /
                        	  1067: ;  ___) | |  __/ | |_  | |_) | | (_| | | | | | |   < 
                        	  1068: ; |____/   \___|  \__| |____/   \__,_| |_| |_| |_|\_\
                        	  1069: 
                        	  1070: 
                        	  1071: ; *********************************************************************************************************************
                        	  1072: ; Set current bank from the command prompt
                        	  1073: ;	- Input:	An optional byte parameter, defaults to 0
                        	  1074: ; *********************************************************************************************************************
                        	  1075: ; Wishlist:
                        	  1076: ;	- Validation, only a nibble, and only 0-E
                        	  1077: ;	- Choice of BCD?
                        	  1078: 
                        	  1079: SetBank:
01:87BC F5              	  1080: 	push	AF
01:87BD C5              	  1081: 	push	BC
01:87BE D5              	  1082: 	push	DE
01:87BF E5              	  1083: 	push	HL
                        	  1084: 	
01:87C0 2A86B0          	  1085: 	ld		HL,(BufferPointer)		; Restore current buffer pointer ito HL
01:87C3 CDC988          	  1086: 	call	GetHexParameter			; Get a parameter
01:87C6 3020            	  1087: 	jr		nc,SetBankEnd			; Exit routine if there was an error in the parameter
01:87C8 FE00            	  1088: 	cp		0						; Is there a parameter returned?
01:87CA 2810            	  1089: 	jr		z,SetBankDefault		; If there is none, select default bank
01:87CC FE02            	  1090: 	cp		2
01:87CE 2815            	  1091: 	jr		z,SetBankError
                        	  1092: 	
01:87D0 79              	  1093: 	ld		A,C
01:87D1 FE0F            	  1094: 	cp		$0F
01:87D3 3010            	  1095: 	jr		nc,SetBankError
01:87D5 3289B0          	  1096: 	ld		(CurrentBank),A			; Save nibble in parameter (C) in CurrentBank global variable
01:87D8 D330            	  1097: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87DA 180C            	  1098: 	jr		SetBankEnd
                        	  1099: 
                        	  1100: SetBankDefault:
01:87DC 3E00            	  1101: 	ld		A,0						; Default bank is 0
01:87DE 3289B0          	  1102: 	ld		(CurrentBank),A			; Save it in CurrentBank global variable
01:87E1 D330            	  1103: 	out		(BankSelect),A			; Sets bank number to value in accumulator
01:87E3 1803            	  1104: 	jr		SetBankEnd
                        	  1105: 
                        	  1106: SetBankError:
01:87E5 CD2CB0          	  1107: 	call	InvalidBank
                        	  1108: 	
                        	  1109: SetBankEnd:
01:87E8 E1              	  1110: 	pop		HL
01:87E9 D1              	  1111: 	pop		DE
01:87EA C1              	  1112: 	pop		BC
01:87EB F1              	  1113: 	pop		AF
                        	  1114: 	
01:87EC C9              	  1115: 	ret
                        	  1116: 	
                        	  1117: 	
                        	  1118: ;  ____                  ___            __         
                        	  1119: ; / ___|   _   _   ___  |_ _|  _ __    / _|   ___  
                        	  1120: ; \___ \  | | | | / __|  | |  | '_ \  | |_   / _ \ 
                        	  1121: ;  ___) | | |_| | \__ \  | |  | | | | |  _| | (_) |
                        	  1122: ; |____/   \__, | |___/ |___| |_| |_| |_|    \___/ 
                        	  1123: ;          |___/                                   
                        	  1124: 
                        	  1125: ; *********************************************************************************************************************
                        	  1126: ; Prints information about the ZedEighty (WiP)
                        	  1127: ; *********************************************************************************************************************
                        	  1128: 
                        	  1129: SysInfo:
01:87ED E5              	  1130: 	push	HL
01:87EE 2194AB          	  1131: 	ld		HL,SysInfoMsg			; Point the the text message
01:87F1 CDAE80          	  1132: 	call	PrintString				; Print first line
01:87F4 CD8C80          	  1133: 	call	PrintLine				; Print a line
01:87F7 CDAE80          	  1134: 	call	PrintString				; Print the rest
                        	  1135: 	
                        	  1136: 	; Speed in MHz
01:87FA CDAE80          	  1137: 	call	PrintString
                        	  1138: 	
                        	  1139: 	; Free RAM
01:87FD E5              	  1140: 	push	HL
01:87FE 21CECB          	  1141: 	ld		HL,BytesFree			; Load the amount of bytes free
01:8801 CD5880          	  1142: 	call	PrintDec				; Print decimal value
01:8804 E1              	  1143: 	pop		HL
01:8805 CDAE80          	  1144: 	call	PrintString
                        	  1145: 	
01:8808 E1              	  1146: 	pop		HL
01:8809 C9              	  1147: 	ret
                        	  1148: 
                        	  1149: 
                        	  1150: ; __        __         _   _          
                        	  1151: ; \ \      / /  _ __  (_) | |_    ___ 
                        	  1152: ;  \ \ /\ / /  | '__| | | | __|  / _ \
                        	  1153: ;   \ V  V /   | |    | | | |_  |  __/
                        	  1154: ;    \_/\_/    |_|    |_|  \__|  \___|
                        	  1155: ;
                        	  1156: ; *********************************************************************************************************************
                        	  1157: ; Write up to 8 bytes into memory
                        	  1158: ; *********************************************************************************************************************
                        	  1159: 
                        	  1160: Write:
01:880A F5              	  1161: 	push 	AF
01:880B C5              	  1162: 	push	BC
01:880C D5              	  1163: 	push	DE
01:880D E5              	  1164: 	push	HL
                        	  1165: 	
01:880E 2A86B0          	  1166: 	ld		HL,(BufferPointer)		; Restore current buffer pointer in HL
                        	  1167: 	
                        	  1168: WriteGetAddress:
01:8811 CDC988          	  1169: 	call	GetHexParameter			; Get the first parameter, start address
01:8814 D25588          	  1170: 	jp		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8817 FE00            	  1171: 	cp		0						; Is there a first parameter?
01:8819 2837            	  1172: 	jr		z,WriteNoParameter		; No, then print error message
01:881B C5              	  1173: 	push	BC						; Store start address that's in BC
01:881C D1              	  1174: 	pop		DE						; Into DE
                        	  1175: 
                        	  1176: WriteFirstByte:
01:881D CDC988          	  1177: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8820 3033            	  1178: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8822 FE00            	  1179: 	cp		0						; Is there a second parameter?
01:8824 282C            	  1180: 	jr		z,WriteNoParameter		; No, then print error message
01:8826 FE02            	  1181: 	cp		2						; Is it bigger then a byte?
01:8828 301D            	  1182: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:882A 79              	  1183: 	ld		A,C						; Transfer byte in A
01:882B 12              	  1184: 	ld		(DE),A					; Save the byte
01:882C 13              	  1185: 	inc		DE						; Point to the next location
01:882D ED538AB0        	  1186: 	ld		(CurrentAddress),DE		; Set CurrentAddress
                        	  1187: 
                        	  1188: WriteRemainingBytes:
01:8831 CDC988          	  1189: 	call	GetHexParameter			; Get the second parameter, byte to write
01:8834 301F            	  1190: 	jr		nc,WriteEnd				; Exit routine if there was an error in the parameter
01:8836 FE00            	  1191: 	cp		0						; Is there another parameter?
01:8838 281B            	  1192: 	jr		z,WriteEnd				; No, then exit
01:883A FE02            	  1193: 	cp		2						; Is it bigger then a byte?
01:883C 3009            	  1194: 	jr		nc,WriteTooManyDigits	; Yes, then print error
01:883E 79              	  1195: 	ld		A,C						; Transfer C in accumulator to transfer in it in RAM
01:883F 12              	  1196: 	ld		(DE),A					; Save the byte
01:8840 13              	  1197: 	inc		DE						; Point to the next location
01:8841 ED538AB0        	  1198: 	ld		(CurrentAddress),DE		; Set CurrentAddress
01:8845 18EA            	  1199: 	jr		WriteRemainingBytes		; See if there are other bytes
                        	  1200: 
                        	  1201: WriteTooManyDigits:
01:8847 CDBF88          	  1202: 	call	DecErrorPointer			; Back up pointer one
01:884A CDBC89          	  1203: 	call	PrintErrorPointer		; Print's pointer to actual error in command line
01:884D CD35B0          	  1204: 	call	TooManyDigits			; Print invalid number of digits message	
01:8850 1803            	  1205: 	jr		WriteEnd
                        	  1206: 	
                        	  1207: WriteNoParameter:
01:8852 CD20B0          	  1208: 	call	NoParameter
                        	  1209: 	
                        	  1210: WriteEnd:
01:8855 E1              	  1211: 	pop		HL
01:8856 D1              	  1212: 	pop		DE
01:8857 C1              	  1213: 	pop		BC
01:8858 F1              	  1214: 	pop		AF
01:8859 C9              	  1215: 	ret
                        	  1216: 
                        	  1217: 
                        	  1218: ;  _____                           _      _   _   ____                      
                        	  1219: ; |__  /   ___   _ __    ___      / \    | | | | |  _ \    __ _   _ __ ___  
                        	  1220: ;   / /   / _ \ | '__|  / _ \    / _ \   | | | | | |_) |  / _` | | '_ ` _ \ 
                        	  1221: ;  / /_  |  __/ | |    | (_) |  / ___ \  | | | | |  _ <  | (_| | | | | | | |
                        	  1222: ; /____|  \___| |_|     \___/  /_/   \_\ |_| |_| |_| \_\  \__,_| |_| |_| |_|
                        	  1223: 
                        	  1224: 
                        	  1225: ; *********************************************************************************************************************
                        	  1226: ; Zero all the RAM, including all the RAM. Excludes shadow ROM (otherwise it will corrupt the BIOS), as well as
                        	  1227: ; vector pages.
                        	  1228: ; *********************************************************************************************************************
                        	  1229: 
                        	  1230: ZeroAllRam:
01:885A F5              	  1231: 	push	AF
01:885B C5              	  1232: 	push	BC
01:885C D5              	  1233: 	push	DE
01:885D E5              	  1234: 	push	HL
                        	  1235: 	
01:885E 3E0E            	  1236: 	ld		A,$E
                        	  1237: ZeroLowRange:
01:8860 D330            	  1238: 	out		(BankSelect),A
01:8862 210080          	  1239: 	ld		HL,StartOfCode			; Load end address
01:8865 2B              	  1240: 	dec		HL
01:8866 118000          	  1241: 	ld		DE,InterruptVectorEnd	; Load start
01:8869 B7              	  1242: 	or		A						; Clear carry flag
01:886A ED52            	  1243: 	sbc		HL,DE					; HL = HL - DE
01:886C E5              	  1244: 	push	HL						; Put result of byte count
01:886D C1              	  1245: 	pop		BC						; Into the byte count register
01:886E 218000          	  1246: 	ld		HL,InterruptVectorEnd	; Set source address
01:8871 F5              	  1247: 	push	AF
01:8872 3E00            	  1248: 	ld		A,0						; Grab byte to write
01:8874 77              	  1249: 	ld		(HL),A					; Save it at the source address
01:8875 F1              	  1250: 	pop		AF
01:8876 118000          	  1251: 	ld		DE,InterruptVectorEnd	; Place destination address
01:8879 13              	  1252: 	inc		DE
01:887A EDB0            	  1253: 	ldir
01:887C 3D              	  1254: 	dec		A
01:887D FEFF            	  1255: 	cp		$FF
01:887F 20DF            	  1256: 	jr		nz,ZeroLowRange
                        	  1257: 
                        	  1258: ZeroHighRange:
01:8881 2100FD          	  1259: 	ld		HL,VectorTable			; Load end address
01:8884 2B              	  1260: 	dec		HL
01:8885 11B2B0          	  1261: 	ld		DE,EndOfCode			; Load start
01:8888 B7              	  1262: 	or		A						; Clear carry flag
01:8889 ED52            	  1263: 	sbc		HL,DE					; HL = HL - DE
01:888B E5              	  1264: 	push	HL						; Put result of byte count
01:888C C1              	  1265: 	pop		BC						; Into the byte count register
01:888D 21B2B0          	  1266: 	ld		HL,EndOfCode			; Set source address
01:8890 3E00            	  1267: 	ld		A,0						; Grab byte to write
01:8892 77              	  1268: 	ld		(HL),A					; Save it at the source address
01:8893 11B2B0          	  1269: 	ld		DE,EndOfCode			; Place destination address
01:8896 13              	  1270: 	inc		DE
01:8897 EDB0            	  1271: 	ldir
                        	  1272: 
01:8899 37              	  1273: 	scf								; Set Carry, indicates no error to calling program
                        	  1274: 
                        	  1275: ZeroEnd:
01:889A E1              	  1276: 	pop		HL
01:889B D1              	  1277: 	pop		DE
01:889C C1              	  1278: 	pop		BC
01:889D F1              	  1279: 	pop		AF
01:889E C9              	  1280: 	ret
                        	  1281: 
                        	  1282: 

Source: "main.asm"
                        	   272: 	.include	"ancillary.asm"		; Anscillary subroutines for monitor commands

Source: "ancillary.asm"
                        	     1: ; Ancillary monitor routines in this include file:
                        	     2: ; ------------------------------------------------
                        	     3: ;	- CommandPrompt					; {}
                        	     4: ;	- GetHexParameter				; [(HL) -> BC,A,(HL)]
                        	     5: ;	- Parse							; (HL)
                        	     6: ;	- SkipSpaces					; [HL -> HL]
                        	     7: 
                        	     8: 
                        	     9: ;   ____                                                       _   ____                                       _   
                        	    10: ;  / ___|   ___    _ __ ___    _ __ ___     __ _   _ __     __| | |  _ \   _ __    ___    _ __ ___    _ __   | |_ 
                        	    11: ; | |      / _ \  | '_ ` _ \  | '_ ` _ \   / _` | | '_ \   / _` | | |_) | | '__|  / _ \  | '_ ` _ \  | '_ \  | __|
                        	    12: ; | |___  | (_) | | | | | | | | | | | | | | (_| | | | | | | (_| | |  __/  | |    | (_) | | | | | | | | |_) | | |_ 
                        	    13: ;  \____|  \___/  |_| |_| |_| |_| |_| |_|  \__,_| |_| |_|  \__,_| |_|     |_|     \___/  |_| |_| |_| | .__/   \__|
                        	    14: ;                                                                                                    |_|          
                        	    15: 
                        	    16: ; *********************************************************************************************************************
                        	    17: ; Prints the prompt to console
                        	    18: ; *********************************************************************************************************************
                        	    19: 
                        	    20: CommandPrompt:
01:889F F5              	    21: 	push	AF
01:88A0 E5              	    22: 	push	HL
01:88A1 3A89B0          	    23: 	ld		A,(CurrentBank)			; Get Current Bank number
01:88A4 CD9E80          	    24: 	call	PrintNibble				; Print it
01:88A7 3E3A            	    25: 	ld		A,":"					; 
01:88A9 CD7480          	    26: 	call	PrintChar				; Print colon symbol
01:88AC 2A8AB0          	    27: 	ld		HL,(CurrentAddress)
01:88AF CDBC80          	    28: 	call	PrintWord				; Print current address poointer
01:88B2 3E3E            	    29: 	ld		A,">"					; 
01:88B4 CD7480          	    30: 	call	PrintChar				; Print prompt symbol
01:88B7 3E20            	    31: 	ld		A," "					; 
01:88B9 CD7480          	    32: 	call	PrintChar				; Print a space
01:88BC E1              	    33: 	pop		HL
01:88BD F1              	    34: 	pop		AF
01:88BE C9              	    35: 	ret
                        	    36: 
                        	    37: 
                        	    38: ;  ____                  _____                                ____            _           _                 
                        	    39: ; |  _ \    ___    ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	    40: ; | | | |  / _ \  / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	    41: ; | |_| | |  __/ | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	    42: ; |____/   \___|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	    43: ;
                        	    44: ;
                        	    45: ; *********************************************************************************************************************
                        	    46: ; Decrement error pointer by one
                        	    47: ; *********************************************************************************************************************
                        	    48: 
                        	    49: DecErrorPointer:
01:88BF F5              	    50: 	push	AF
01:88C0 3A88B0          	    51: 	ld		A,(CmdErrorPointer)
01:88C3 3D              	    52: 	dec		A
01:88C4 3288B0          	    53: 	ld		(CmdErrorPointer),A
01:88C7 F1              	    54: 	pop		AF
01:88C8 C9              	    55: 	ret
                        	    56: 
                        	    57: 
                        	    58: ;   ____          _     _   _                 ____                                              _                 
                        	    59: ;  / ___|   ___  | |_  | | | |   ___  __  __ |  _ \    __ _   _ __    __ _   _ __ ___     ___  | |_    ___   _ __ 
                        	    60: ; | |  _   / _ \ | __| | |_| |  / _ \ \ \/ / | |_) |  / _` | | '__|  / _` | | '_ ` _ \   / _ \ | __|  / _ \ | '__|
                        	    61: ; | |_| | |  __/ | |_  |  _  | |  __/  >  <  |  __/  | (_| | | |    | (_| | | | | | | | |  __/ | |_  |  __/ | |   
                        	    62: ;  \____|  \___|  \__| |_| |_|  \___| /_/\_\ |_|      \__,_| |_|     \__,_| |_| |_| |_|  \___|  \__|  \___| |_|   
                        	    63: ;
                        	    64: ;
                        	    65: ; *********************************************************************************************************************
                        	    66: ; Read a hexadecimal parameter from the CommandBuffer
                        	    67: ;	- Input:	HL = Buffer pointer of command buffer, points to parameter
                        	    68: ;	- Output:	BC = contains the converted Hex number (if it's a byte B is 0, C is the converted byte) 
                        	    69: ;				A = 0 is no parameter, 1 is a byte, 2 is a word
                        	    70: ;				HL = New position of pointer
                        	    71: ;				Carry set if valid; Carry clear if error
                        	    72: ; *********************************************************************************************************************
                        	    73: 
                        	    74: GetHexParameter:
01:88C9 CD378B          	    75: 	call	SkipSpaces				; Skip any spaces if any
01:88CC E5              	    76: 	push	HL						; Save it, restoring it after character count
01:88CD 0E00            	    77: 	ld		C,$00					; Character count set to zero
                        	    78: 	
                        	    79: GetParamCount:
01:88CF 7E              	    80: 	ld		A,(HL)					; Read a character form the CommandBuffer
01:88D0 FE00            	    81: 	cp		0						; Is it the end of the CommandBuffer?
01:88D2 280C            	    82: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88D4 FE20            	    83: 	cp		DELIMITER				; If it's the delimiter for the next parameter
01:88D6 2808            	    84: 	jr		z,GetParamFetch			; Yes, then stop counting
01:88D8 FE3F            	    85: 	cp		"?"
01:88DA 2852            	    86: 	jr		z,GetParamHelp
01:88DC 23              	    87: 	inc		HL						; Increment buffer pointer to next character in parameter
01:88DD 0C              	    88: 	inc		C						; Add one, to the count of characters
01:88DE 18EF            	    89: 	jr		GetParamCount			; Loop if delimiter has not been reached
                        	    90: 
                        	    91: GetParamFetch:
01:88E0 79              	    92: 	ld		A,C						; Load counted characters into accumulator
01:88E1 E1              	    93: 	pop		HL						; Restore pointer back to it's original position
01:88E2 010000          	    94: 	ld		BC,$0000				; Clear the results register to store a nibble, byte or nibble+byte
                        	    95: 
                        	    96: GetParamFetch0;
01:88E5 FE00            	    97: 	cp		0						; Was a parameter specified?
01:88E7 2004            	    98: 	jr		nz,GetParamFetch1		; No then check for 1 
01:88E9 3E00            	    99: 	ld		A,0						; Returns 0 to indicate no parameters
01:88EB 183F            	   100: 	jr		GetParameterEnd			; End routine
                        	   101: 	
                        	   102: GetParamFetch1:
01:88ED FE01            	   103: 	cp		1						; Was it only one digit?
01:88EF 200C            	   104: 	jr		nz,GetParamFetch2		; No then check for 2
01:88F1 7E              	   105: 	ld		A,(HL)
01:88F2 23              	   106: 	inc		HL
01:88F3 CD6981          	   107: 	call	Ascii2HexNibble			; Convert an ASCII char in HL to a 4-bit hex value
01:88F6 304A            	   108: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:88F8 4F              	   109: 	ld		C,A						; Save value in LSB of C
01:88F9 3E01            	   110: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:88FB 182F            	   111: 	jr		GetParameterEnd			; End routine
                        	   112: 
                        	   113: GetParamFetch2:
01:88FD FE02            	   114: 	cp		2						; Was it two digits?
01:88FF 200A            	   115: 	jr		nz,GetParamFetch3		; No then check for 3
01:8901 CD8D81          	   116: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:8904 303C            	   117: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8906 4F              	   118: 	ld		C,A						; Save value in C
01:8907 3E01            	   119: 	ld		A,1						; Return 1 to indicate it's a 1-byte result
01:8909 1821            	   120: 	jr		GetParameterEnd			; End routine
                        	   121: 
                        	   122: GetParamFetch3:
01:890B FE03            	   123: 	cp		3						; Was three digits?
01:890D 2012            	   124: 	jr		nz,GetParamFetch4		; No then check for 4
01:890F 7E              	   125: 	ld		A,(HL)
01:8910 23              	   126: 	inc		HL
01:8911 CD6981          	   127: 	call	Ascii2HexNibble			; Convert the first ASCII char in HL to a hex value
01:8914 302C            	   128: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:8916 47              	   129: 	ld		B,A						; Save result in D
01:8917 CD8D81          	   130: 	call	Ascii2HexByte			; Convert a hex digit to a hex value
01:891A 3026            	   131: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:891C 4F              	   132: 	ld		C,A						; Store resulting byte in C (LSB)
01:891D 3E02            	   133: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
01:891F 180B            	   134: 	jr		GetParameterEnd			; End routine
                        	   135: 
                        	   136: GetParamFetch4:
01:8921 FE04            	   137: 	cp		4						; Was four digits?
01:8923 200E            	   138: 	jr		nz,GetParamNumberError	; Print error message
01:8925 CDAC81          	   139: 	call	Ascii2HexWord			; Convert a 4-character hex digit pointed by HL to a hex value
01:8928 3018            	   140: 	jr		nc,GetParamHexError		; If there was an error in the digit, print it and exit
01:892A 3E02            	   141: 	ld		A,2						; Return 2 to indicate it's a 2-byte result
                        	   142: 
                        	   143: GetParameterEnd:
01:892C 37              	   144: 	scf								; Set carry to indicate all is ok
01:892D C9              	   145: 	ret
                        	   146: 
                        	   147: GetParamHelp:
01:892E F1              	   148: 	pop		AF						; Dummy pop from stack as there was a push before
01:892F 3E0F            	   149: 	ld		A,HELP
01:8931 37              	   150: 	scf
01:8932 C9              	   151: 	ret
                        	   152: 
                        	   153: GetParamNumberError:
01:8933 0604            	   154: 	ld		B,4						;
                        	   155: GetErrorPointerLoop:
01:8935 CD4A89          	   156: 	call	IncErrorPointer			;
01:8938 10FB            	   157: 	djnz	GetErrorPointerLoop		;
01:893A CDBC89          	   158: 	call	PrintErrorPointer
01:893D CD35B0          	   159: 	call	TooManyDigits			; Print invalid number of digits message	
01:8940 1806            	   160: 	jr		GetParamErrorEnd		; End Error handling
                        	   161: 
                        	   162: GetParamHexError:
01:8942 CDBC89          	   163: 	call	PrintErrorPointer
01:8945 CD3EB0          	   164: 	call	InvalidHexDigit			;Print invalid hex character message
                        	   165: 
                        	   166: GetParamErrorEnd:
01:8948 B7              	   167: 	or		A						; Clear carry
01:8949 C9              	   168: 	ret
                        	   169: 
                        	   170: 
                        	   171: ;  ___                  _____                                ____            _           _                 
                        	   172: ; |_ _|  _ __     ___  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   173: ;  | |  | '_ \   / __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   174: ;  | |  | | | | | (__  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   175: ; |___| |_| |_|  \___| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   176: ;
                        	   177: ;
                        	   178: ; *********************************************************************************************************************
                        	   179: ; Increment error pointer by one
                        	   180: ; *********************************************************************************************************************
                        	   181: 
                        	   182: IncErrorPointer:
01:894A F5              	   183: 	push	AF
01:894B 3A88B0          	   184: 	ld		A,(CmdErrorPointer)
01:894E 3C              	   185: 	inc		A
01:894F 3288B0          	   186: 	ld		(CmdErrorPointer),A
01:8952 F1              	   187: 	pop		AF
01:8953 C9              	   188: 	ret
                        	   189: 
                        	   190: 
                        	   191: ;  ____                                     
                        	   192: ; |  _ \    __ _   _ __   ___    ___   _ __ 
                        	   193: ; | |_) |  / _` | | '__| / __|  / _ \ | '__|
                        	   194: ; |  __/  | (_| | | |    \__ \ |  __/ | |   
                        	   195: ; |_|      \__,_| |_|    |___/  \___| |_|   
                        	   196: ;
                        	   197: ;
                        	   198: ; *********************************************************************************************************************
                        	   199: ; Parse the string and compare the commands list and the command prompt, then execute if found
                        	   200: ;	- Output:	BufferPointer points to parameter, if any
                        	   201: ; *********************************************************************************************************************
                        	   202: ;	- A = Command buffer character
                        	   203: ;	- B	= Command list character
                        	   204: ;	- DE = Command list pointer
                        	   205: ;	- HL = Command buffer pointer
                        	   206: 
                        	   207: Parser:
01:8954 F5              	   208: 	push	AF
01:8955 C5              	   209: 	push	BC
01:8956 D5              	   210: 	push	DE
01:8957 2295B0          	   211: 	ld		(ParseSaveHL),HL		; Saves HL register, because it's not possible to push it due to routine call
                        	   212: 
01:895A CD2F8B          	   213: 	call	ResetErrorPointer		; Reset error pointer to start position
01:895D 11B2A8          	   214: 	ld		DE,CommandList			; Commands list pointer
01:8960 2168B0          	   215: 	ld		HL,CommandBuffer		; Command buffer pointer
01:8963 CD378B          	   216: 	call	SkipSpaces				; Removes any leading spaces in command buffer
01:8966 2286B0          	   217: 	ld		(BufferPointer),HL		; Save the position of the first character for later
01:8969 7E              	   218: 	ld		A,(HL)					; Read first character or delimiter of the command in command buffer
01:896A FE00            	   219: 	cp		0						; Is it the end of the string already?
01:896C 2847            	   220: 	jr		z,ParseEnd				; If so, then exit parser routine
                        	   221: 
                        	   222: ParseNextChar:
01:896E 7E              	   223: 	ld		A,(HL)					; Read a character from the command buffer
01:896F CD9F82          	   224: 	call	UpperCase				; Change the case to uppercase, as the command list is in uppercase
01:8972 47              	   225: 	ld		B,A						; Put the uppercase character read from string in B
01:8973 1A              	   226: 	ld		A,(DE)					; Load a command list character in accumulator
01:8974 FEFF            	   227: 	cp		EOT						; Has the end of the command list been reached?
01:8976 2837            	   228: 	jr		z,ParseInvalid			; Teache the End Of Table, no matching commands has been found
01:8978 FEC3            	   229: 	cp		JUMP					; Is it a command delimiter? (Which is actualy a jp opcode)
01:897A 281B            	   230: 	jr		z,ParseValidate			; Yes, then execute command
01:897C B8              	   231: 	cp		B						; Is the letter from the list matching the buffer?
01:897D 2007            	   232: 	jr		nz,ParseNextCmd			; If not the same, go to next command in the list
01:897F CD4A89          	   233: 	call	IncErrorPointer			; Increment command line error pointer
01:8982 13              	   234: 	inc		DE						; Increment command list pointer to the next character
01:8983 23              	   235: 	inc		HL						; Increment command buffer pointer to tne next character
01:8984 18E8            	   236: 	jr		ParseNextChar			; Get the next character from command list
                        	   237: 
                        	   238: ParseNextCmd:
01:8986 13              	   239: 	inc		DE						; Increment command list pointer to eventually go to next command
01:8987 1A              	   240: 	ld		A,(DE)					; Load from command list
01:8988 FEC3            	   241: 	cp		JUMP					; Is it the End Of Command delimiter?
01:898A 20FA            	   242: 	jr		nz,ParseNextCmd			; No, then repeat until found
01:898C 13              	   243: 	inc		DE						; It is then bypass jump address
01:898D 13              	   244: 	inc		DE						; Point to the first character of following command
01:898E 13              	   245: 	inc		DE						;
01:898F 2A86B0          	   246: 	ld		HL,(BufferPointer)		; Restore location of first valid command buffer character
01:8992 CD2F8B          	   247: 	call	ResetErrorPointer		; Reset error pointer to start position
01:8995 18D7            	   248: 	jr		ParseNextChar			; Loop back to read next character in list
                        	   249: 
                        	   250: ParseValidate:
01:8997 7E              	   251: 	ld		A,(HL)					; Check for extra unwanted characters by enforcing space delimiter
01:8998 FE00            	   252: 	cp		0						; Check if it's the end of the buffer
01:899A 2804            	   253: 	jr		z,ParseExecute			; It's the end of the buffer, execute command
01:899C FE20            	   254: 	cp		DELIMITER				; Is the space delimiter present in the command buffer?
01:899E 200F            	   255: 	jr		nz,ParseInvalid			; No, then it's not valid
                        	   256: 
                        	   257: ParseExecute:
01:89A0 2286B0          	   258: 	ld		(BufferPointer),HL		; Save current command buffer pointer for jump command parameters, if applicable
01:89A3 EB              	   259: 	ex		DE,HL					; Exchange DE with HL registers to be able to use HL for jumping
                        	   260: ;	jp		(HL)					; Execute command at address in DE (now HL)
                        	   261: 
01:89A4 D1              	   262: 	pop		DE
01:89A5 C1              	   263: 	pop		BC
01:89A6 F1              	   264: 	pop		AF
01:89A7 E5              	   265: 	push	HL						; Save call address
01:89A8 2A95B0          	   266: 	ld		HL,(ParseSaveHL)		; Restore HL
01:89AB C9              	   267: 	ret								; Perform indirect call (HL)
01:89AC C34480          	   268: 	jp		Main					; Go to main
                        	   269: 	
                        	   270: ParseInvalid:
01:89AF 2159AC          	   271: 	ld		HL,ParseInvalidErr
01:89B2 CDAE80          	   272: 	call	PrintString
                        	   273: 
                        	   274: ParseEnd:
01:89B5 2A95B0          	   275: 	ld		HL,(ParseSaveHL)
01:89B8 D1              	   276: 	pop		DE
01:89B9 C1              	   277: 	pop		BC
01:89BA F1              	   278: 	pop		AF
                        	   279: 	
01:89BB C9              	   280: 	ret
                        	   281: 
                        	   282: 
                        	   283: ;  ____           _           _     _____                                ____            _           _                 
                        	   284: ; |  _ \   _ __  (_)  _ __   | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __ 
                        	   285: ; | |_) | | '__| | | | '_ \  | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__|
                        	   286: ; |  __/  | |    | | | | | | | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |   
                        	   287: ; |_|     |_|    |_| |_| |_|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|   
                        	   288: ;
                        	   289: ;
                        	   290: ; *********************************************************************************************************************
                        	   291: ; Print error pointer character under the command line, pointing to the culprit
                        	   292: ; *********************************************************************************************************************
                        	   293: 
                        	   294: PrintErrorPointer:
01:89BC F5              	   295: 	push	AF
01:89BD C5              	   296: 	push	BC
                        	   297: 	
01:89BE 3A88B0          	   298: 	ld		A,(CmdErrorPointer)		; Load error pointer as counter
01:89C1 47              	   299: 	ld		B,A
                        	   300: PrintErrorLoop:
01:89C2 3E20            	   301: 	ld		A," "
01:89C4 CD7480          	   302: 	call	PrintChar				; Print a space character
01:89C7 10F9            	   303: 	djnz	PrintErrorLoop			; Decrement B, and repeat printing space, until 0
01:89C9 3E5E            	   304: 	ld		A,ERRORPTR
01:89CB CD7480          	   305: 	call	PrintChar				; Print the error pointer character
01:89CE CD7F80          	   306: 	call	PrintCRLF				; Change line
                        	   307: 	
01:89D1 C1              	   308: 	pop		BC
01:89D2 F1              	   309: 	pop		AF
01:89D3 C9              	   310: 	ret
                        	   311: 
                        	   312: 
                        	   313: ;  ____                                  __     __          _   _       _           _     _                 
                        	   314: ; |  _ \    __ _   _ __     __ _    ___  \ \   / /   __ _  | | (_)   __| |   __ _  | |_  (_)   ___    _ __  
                        	   315: ; | |_) |  / _` | | '_ \   / _` |  / _ \  \ \ / /   / _` | | | | |  / _` |  / _` | | __| | |  / _ \  | '_ \ 
                        	   316: ; |  _ <  | (_| | | | | | | (_| | |  __/   \ V /   | (_| | | | | | | (_| | | (_| | | |_  | | | (_) | | | | |
                        	   317: ; |_| \_\  \__,_| |_| |_|  \__, |  \___|    \_/     \__,_| |_| |_|  \__,_|  \__,_|  \__| |_|  \___/  |_| |_|
                        	   318: ;                          |___/                                                                            
                        	   319: 
                        	   320: ; *********************************************************************************************************************
                        	   321: ; Validates a range of addresses that can be written to with commands such as Fill and Zero. The range returns
                        	   322: ; one or two ranges (before BIOS and after BIOS). It excludes BIOS, Interrupt vectors, jump table, and stack.
                        	   323: ; - Input:	StartAddress, EndAddress
                        	   324: ; - Output:	Updated StartAddress and EndAddress for low range, and StartAddressAlt and EndAddressAlt for high range
                        	   325: ;			C = Flags: bit0 = Low bank, bit1 = High bank
                        	   326: ; *********************************************************************************************************************
                        	   327: 
                        	   328: RangeValidation:
01:89D4 F5              	   329: 	push	AF
01:89D5 D5              	   330: 	push	DE
01:89D6 E5              	   331: 	push	HL
                        	   332: 	
01:89D7 0E00            	   333: 	ld		C,0						; Clear the region flag
01:89D9 210000          	   334: 	ld		HL,0
01:89DC 22A9B0          	   335: 	ld		(StartAddressAlt),HL	; Reset alternate start address (that represents low memory)
01:89DF 22ABB0          	   336: 	ld		(EndAddressAlt),HL		; Reset alternate end address (that represents high memory)
                        	   337: 	
                        	   338: ; CHECK ORDER OF START AND END ADDRESSES, AND IF RANGE IS ZERO
                        	   339: ; ------------------------------------------------------------
                        	   340: ValCheckInverted:
01:89E2 2AA5B0          	   341: 	ld		HL,(StartAddress)		; Load start address
01:89E5 ED5BA7B0        	   342: 	ld		DE,(EndAddress)			; Load end address
01:89E9 B7              	   343: 	or		A						; Clear carry flag
01:89EA ED52            	   344: 	sbc		HL,DE					; HL = HL - DE
01:89EC CA1B8B          	   345: 	jp		z,ValRangeTooSmallError	; If the range is 0, then print invalid error and exit
01:89EF D2218B          	   346: 	jp		nc,ValInvertedError		; If start address is higher than the end address, then print error and exit
                        	   347: 
                        	   348: ; CHECK IF THE START AND END ADDRESSES ARE IN THE VECTOR AREAS AND AJUST THEM ACCORDINGLY
                        	   349: ; ----------------------------------------------------------------------------------------
                        	   350: ValCheckLowLimit:					; VALIDATE START ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:89F2 2AA5B0          	   351: 	ld		HL,(StartAddress)		; Load start address
01:89F5 118100          	   352: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:89F8 B7              	   353: 	or		A						; Clear carry flag
01:89F9 ED52            	   354: 	sbc		HL,DE					; HL = HL - DE
01:89FB 3006            	   355: 	jr		nc, ValCheckLowLimit2	; If it's not in the interrupt vector table, continue to next validation 
01:89FD 218000          	   356: 	ld		HL,InterruptVectorEnd			; Load 
01:8A00 22A5B0          	   357: 	ld		(StartAddress),HL
                        	   358: 
                        	   359: ValCheckLowLimit2:					; VALIDATE END ADDRESS IF IT'S IN INTERRUPT VECTOR TABLE
01:8A03 2AA7B0          	   360: 	ld		HL,(EndAddress)			; Load end address
01:8A06 118100          	   361: 	ld		DE,InterruptVectorEnd+1	; Load interrupt vector address to compare too
01:8A09 B7              	   362: 	or		A						; Clear carry flag
01:8A0A ED52            	   363: 	sbc		HL,DE					; HL = HL - DE
01:8A0C DA278B          	   364: 	jp		c, RangeValidationError	; If it's in the interrupt vector table, print error and exit
                        	   365: 
                        	   366: ValCheckHighLimit:					; VALIDATE END ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A0F 2AA7B0          	   367: 	ld		HL,(EndAddress)			; Load start address
01:8A12 1100FD          	   368: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A15 B7              	   369: 	or		A						; Clear carry flag
01:8A16 ED52            	   370: 	sbc		HL,DE					; HL = HL - DE
01:8A18 3806            	   371: 	jr		c, ValCheckHighLimit2	; If it's not in the vector tables, continue to next validation
01:8A1A 21FFFC          	   372: 	ld		HL,VectorTable-1		; Load Start of vector table area
01:8A1D 22A7B0          	   373: 	ld		(EndAddress),HL
                        	   374: 	
                        	   375: ValCheckHighLimit2:					; VALIDATE START ADDRESS IF IT'S IN THE END VECTOR TABLES AND STACK
01:8A20 2AA5B0          	   376: 	ld		HL,(StartAddress)		; Load start address
01:8A23 1100FD          	   377: 	ld		DE,VectorTable			; Load end vector table address to compare too (includes stack)
01:8A26 B7              	   378: 	or		A						; Clear carry flag
01:8A27 ED52            	   379: 	sbc		HL,DE					; HL = HL - DE
01:8A29 D2278B          	   380: 	jp		nc,RangeValidationError	; If it's in the interrupt vector table, then change upper limit 
                        	   381: 
                        	   382: ; CHECK IF THE RANGE IS COMPLETELY IN BIOS ZONE
                        	   383: ; ---------------------------------------------
                        	   384: ValCheckBiosLow:
01:8A2C 2AA5B0          	   385: 	ld		HL,(StartAddress)		; Load start address
01:8A2F 110080          	   386: 	ld		DE,StartOfCode			; Load start of code to compare too
01:8A32 B7              	   387: 	or		A						; Clear carry flag
01:8A33 ED52            	   388: 	sbc		HL,DE					; HL = HL - DE
01:8A35 380E            	   389: 	jr		c,ValCheckHigh			; If start address is lower than the start of code, then check if in high RRAM
                        	   390: 
                        	   391: ValCheckBiosHi:
01:8A37 2AA7B0          	   392: 	ld		HL,(EndAddress)			; Load end address
01:8A3A 11B2B0          	   393: 	ld		DE,EndOfCode			; Load end of code address to compare too
01:8A3D B7              	   394: 	or		A						; Clear carry flag
01:8A3E ED52            	   395: 	sbc		HL,DE					; HL = HL - DE
01:8A40 3003            	   396: 	jr		nc,ValCheckHigh			; If end address is higher than the end of code, then check if in high RAM
01:8A42 C3158B          	   397: 	jp		ValBiosRangeError		; Else print invalid range and exit
                        	   398: 
                        	   399: ; CHECK IF RANGE IS IN HIGH MEMORY
                        	   400: ; --------------------------------
                        	   401: ValCheckHigh:
                        	   402: 	; Is it in high memory?
01:8A45 2AA5B0          	   403: 	ld		HL,(StartAddress)		; Load start address
01:8A48 110080          	   404: 	ld		DE,StartOfCode			; Load start of code address
01:8A4B B7              	   405: 	or		A						; Clear carry flag
01:8A4C ED52            	   406: 	sbc		HL,DE					; HL = HL - DE
                        	   407: 	; No, then check for low memory
01:8A4E 3829            	   408: 	jr		c,ValCheckLow
                        	   409: 
                        	   410: 	; Is it in high memory, but is it within the BIOS region?
01:8A50 2AA5B0          	   411: 	ld		HL,(StartAddress)		; Load start address
01:8A53 11B2B0          	   412: 	ld		DE,EndOfCode			; Load end of code address
01:8A56 B7              	   413: 	or		A						; Clear carry flag
01:8A57 ED52            	   414: 	sbc		HL,DE					; HL = HL - DE
                        	   415: 	; Yes, then change StartAddress to upper limit of BIOS
01:8A59 3810            	   416: 	jr		c,ValCheckHighBios
                        	   417: 	; No, then only copy start and end addresses to the Alt locations
01:8A5B 2AA5B0          	   418: 	ld		HL,(StartAddress)		;
01:8A5E 22A9B0          	   419: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A61 2AA7B0          	   420: 	ld		HL,(EndAddress)			;
01:8A64 22ABB0          	   421: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A67 CBC9            	   422: 	set		1,C						; Flag high address
01:8A69 180E            	   423: 	jr		ValCheckLow
                        	   424: 
                        	   425: ValCheckHighBios:
01:8A6B 21B2B0          	   426: 	ld		HL,EndOfCode		;
01:8A6E 22A9B0          	   427: 	ld		(StartAddressAlt),HL	; Set start address at the end of code, in case it overlapped
01:8A71 2AA7B0          	   428: 	ld		HL,(EndAddress)			;
01:8A74 22ABB0          	   429: 	ld		(EndAddressAlt),HL		; Set end address in the high alternate position
01:8A77 CBC9            	   430: 	set		1,C						; Flag high address
                        	   431: 	
                        	   432: ; CHECK IF RANGE IS IN LOW MEMORY
                        	   433: ; -------------------------------
                        	   434: ValCheckLow:
                        	   435: 	; Is it in low memory only?
01:8A79 2AA7B0          	   436: 	ld		HL,(EndAddress)			; Load start address
01:8A7C 11B2B0          	   437: 	ld		DE,EndOfCode			; Load start of code address
01:8A7F B7              	   438: 	or		A						; Clear carry flag
01:8A80 ED52            	   439: 	sbc		HL,DE					; HL = HL - DE
                        	   440: 	; No, then it overlaps BIOS
01:8A82 3018            	   441: 	jr		nc,ValBiosOverlap
                        	   442: 
                        	   443: 	; Is it in low memory, but is it within the BIOS region?
01:8A84 2AA7B0          	   444: 	ld		HL,(EndAddress)			; Load start address
01:8A87 110080          	   445: 	ld		DE,StartOfCode			; Load end of code address
01:8A8A B7              	   446: 	or		A						; Clear carry flag
01:8A8B ED52            	   447: 	sbc		HL,DE					; HL = HL - DE
                        	   448: 	; Yes, then change EndAddress to lower limit of BIOS
01:8A8D 3004            	   449: 	jr		nc,ValCheckLowBios
                        	   450: 	; No, then only flag low memory
01:8A8F CBC1            	   451: 	set		0,C						; Flag low address
01:8A91 1809            	   452: 	jr		ValBiosOverlap
                        	   453: 
                        	   454: ValCheckLowBios:
01:8A93 210080          	   455: 	ld		HL,StartOfCode			;
01:8A96 2B              	   456: 	dec		HL
01:8A97 22A7B0          	   457: 	ld		(EndAddress),HL			; Set start address at the end of code, in case it overlapped
01:8A9A CBC1            	   458: 	set		0,C						; Flag low address
                        	   459: 
                        	   460: ; CHECK IF RANGE OVERLAPS BIOS AREA
                        	   461: ; ---------------------------------
                        	   462: ValBiosOverlap:
01:8A9C 79              	   463: 	ld		A,C
01:8A9D FE00            	   464: 	cp		0
01:8A9F 2017            	   465: 	jr		nz,ValCheckIfZeroDataLow
                        	   466: 	; Move EndAddress to the Alternate one
01:8AA1 2AA7B0          	   467: 	ld		HL,(EndAddress)
01:8AA4 22ABB0          	   468: 	ld		(EndAddressAlt),HL
                        	   469: 	; Change low memory EndAddress to beginning of BIOS -1
01:8AA7 210080          	   470: 	ld		HL,StartOfCode		
01:8AAA 2B              	   471: 	dec		HL
01:8AAB 22A7B0          	   472: 	ld		(EndAddress),HL
                        	   473: 	; Change high memory StartAddressAlt to end of BIOS
01:8AAE 21B2B0          	   474: 	ld		HL,EndOfCode
01:8AB1 22A9B0          	   475: 	ld		(StartAddressAlt),HL
01:8AB4 CBC1            	   476: 	set		0,C						; Flag low address
01:8AB6 CBC9            	   477: 	set		1,C						; Flag high address
                        	   478: 
                        	   479: ; CHECK IF RANGE(S) ARE ZERO, WITH REASSIGNMENT, IT'S POSSIBLE
                        	   480: ; ------------------------------------------------------------
                        	   481: ValCheckIfZeroDataLow:
01:8AB8 CB41            	   482: 	bit		0,C
01:8ABA 280C            	   483: 	jr		z,ValCheckIfZeroDataHigh
01:8ABC 2AA5B0          	   484: 	ld		HL,(StartAddress)		; Load start address
01:8ABF ED5BA7B0        	   485: 	ld		DE,(EndAddress)			; Load end address
01:8AC3 B7              	   486: 	or		A						; Clear carry flag
01:8AC4 ED52            	   487: 	sbc		HL,DE					; HL = HL - DE
01:8AC6 2853            	   488: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   489: 
                        	   490: ValCheckIfZeroDataHigh:
01:8AC8 CB49            	   491: 	bit		1,C
01:8ACA 280C            	   492: 	jr		z,ValPrintRange
01:8ACC 2AA9B0          	   493: 	ld		HL,(StartAddressAlt)	; Load alternate start address
01:8ACF ED5BABB0        	   494: 	ld		DE,(EndAddressAlt)		; Load alternate end address
01:8AD3 B7              	   495: 	or		A						; Clear carry flag
01:8AD4 ED52            	   496: 	sbc		HL,DE					; HL = HL - DE
01:8AD6 2843            	   497: 	jr		z,ValRangeTooSmallError	; If the range is 0, then print error and exit
                        	   498: 
                        	   499: 	; PRINTS ADDRESS RANGE
                        	   500: ValPrintRange:
01:8AD8 CDF3AF          	   501: 	call	Range
                        	   502: 
                        	   503: ValPrintRange1:
01:8ADB CB41            	   504: 	bit		0,C
01:8ADD 2816            	   505: 	jr		z,ValPrintRange2
01:8ADF 3E20            	   506: 	ld		A," "
01:8AE1 CD7480          	   507: 	call	PrintChar
01:8AE4 2AA5B0          	   508: 	ld		HL,(StartAddress)
01:8AE7 CDBC80          	   509: 	call	PrintWord
01:8AEA 3E2D            	   510: 	ld		A,"-"
01:8AEC CD7480          	   511: 	call	PrintChar
01:8AEF 2AA7B0          	   512: 	ld		HL,(EndAddress)
01:8AF2 CDBC80          	   513: 	call	PrintWord
                        	   514: 	
                        	   515: ValPrintRange2:
01:8AF5 CB49            	   516: 	bit		1,C
01:8AF7 2816            	   517: 	jr		z,ValPrintRangeEnd
01:8AF9 3E20            	   518: 	ld		A," "
01:8AFB CD7480          	   519: 	call	PrintChar
01:8AFE 2AA9B0          	   520: 	ld		HL,(StartAddressAlt)
01:8B01 CDBC80          	   521: 	call	PrintWord
01:8B04 3E2D            	   522: 	ld		A,"-"
01:8B06 CD7480          	   523: 	call	PrintChar
01:8B09 2AABB0          	   524: 	ld		HL,(EndAddressAlt)
01:8B0C CDBC80          	   525: 	call	PrintWord	
                        	   526: 
                        	   527: ValPrintRangeEnd:
01:8B0F CD7F80          	   528: 	call	PrintCRLF
01:8B12 37              	   529: 	scf								; Set carry
01:8B13 1816            	   530: 	jr		RangeValidationEnd
                        	   531: 
                        	   532: ValBiosRangeError:
01:8B15 CD0EB0          	   533: 	call	BiosRange
01:8B18 B7              	   534: 	or		A
01:8B19 1810            	   535: 	jr		RangeValidationEnd
                        	   536: 
                        	   537: ValRangeTooSmallError:
01:8B1B CD05B0          	   538: 	call	RangeTooSmall
01:8B1E B7              	   539: 	or		A
01:8B1F 180A            	   540: 	jr		RangeValidationEnd
                        	   541: 
                        	   542: ValInvertedError:
01:8B21 CD17B0          	   543: 	call	RangeInverted
01:8B24 B7              	   544: 	or		A
01:8B25 1804            	   545: 	jr		RangeValidationEnd
                        	   546: 	
                        	   547: RangeValidationError:
01:8B27 CDFCAF          	   548: 	call	InvalidVectorRange
01:8B2A B7              	   549: 	or		A						; Clear Carry
                        	   550: 
                        	   551: RangeValidationEnd:
01:8B2B E1              	   552: 	pop		HL
01:8B2C D1              	   553: 	pop		DE
01:8B2D F1              	   554: 	pop		AF
                        	   555: 
01:8B2E C9              	   556: 	ret
                        	   557: 
                        	   558: 
                        	   559: ;  ____                        _     _____                                ____            _           _                
                        	   560: ; |  _ \    ___   ___    ___  | |_  | ____|  _ __   _ __    ___    _ __  |  _ \    ___   (_)  _ __   | |_    ___   _ __
                        	   561: ; | |_) |  / _ \ / __|  / _ \ | __| |  _|   | '__| | '__|  / _ \  | '__| | |_) |  / _ \  | | | '_ \  | __|  / _ \ | '__
                        	   562: ; |  _ <  |  __/ \__ \ |  __/ | |_  | |___  | |    | |    | (_) | | |    |  __/  | (_) | | | | | | | | |_  |  __/ | |  
                        	   563: ; |_| \_\  \___| |___/  \___|  \__| |_____| |_|    |_|     \___/  |_|    |_|      \___/  |_| |_| |_|  \__|  \___| |_|  
                        	   564: ;
                        	   565: ;
                        	   566: ; *********************************************************************************************************************
                        	   567: ; Increment error pointer by one
                        	   568: ; *********************************************************************************************************************
                        	   569: 
                        	   570: ResetErrorPointer:
01:8B2F F5              	   571: 	push	AF
01:8B30 3E08            	   572: 	ld		A,ErrorPtrOffset
01:8B32 3288B0          	   573: 	ld		(CmdErrorPointer),A
01:8B35 F1              	   574: 	pop		AF
01:8B36 C9              	   575: 	ret
                        	   576: 
                        	   577: 
                        	   578: ;  ____    _      _           ____                                      
                        	   579: ; / ___|  | | __ (_)  _ __   / ___|   _ __     __ _    ___    ___   ___ 
                        	   580: ; \___ \  | |/ / | | | '_ \  \___ \  | '_ \   / _` |  / __|  / _ \ / __|
                        	   581: ;  ___) | |   <  | | | |_) |  ___) | | |_) | | (_| | | (__  |  __/ \__ \
                        	   582: ; |____/  |_|\_\ |_| | .__/  |____/  | .__/   \__,_|  \___|  \___| |___/
                        	   583: ;                    |_|             |_|                                
                        	   584: ;
                        	   585: ; *********************************************************************************************************************
                        	   586: ; Removes leading spaces for parsing commands
                        	   587: ;	- Input:	HL pointing to command string
                        	   588: ;	- Output:	HL points to the next delimiterless position
                        	   589: ; *********************************************************************************************************************
                        	   590: 
                        	   591: SkipSpaces:
01:8B37 F5              	   592: 	push	AF
                        	   593: SkipSpacesLoop:
01:8B38 7E              	   594: 	ld		A,(HL)					; Read the contents of HL, where the 
01:8B39 FE20            	   595: 	cp		" "						; Is it a space?
01:8B3B 2006            	   596: 	jr		nz,SkipSpacesEnd		; It's not a space, so end routine
01:8B3D 23              	   597: 	inc		HL						; It's a space, so move to next character
01:8B3E CD4A89          	   598: 	call	IncErrorPointer			; Increment command line error pointer
01:8B41 18F5            	   599: 	jr		SkipSpacesLoop			; Check for other spaces, just in case
                        	   600: SkipSpacesEnd:
01:8B43 F1              	   601: 	pop		AF
01:8B44 C9              	   602: 	ret
                        	   603: 
                        	   604: 

Source: "main.asm"
                        	   273: 	.include	"basic.asm"			; Nascom Microsoft Basic (from Grant Searle)

Source: "basic.asm"
                        	     1: ;==================================================================================
                        	     2: ; The updates to the original BASIC within this file are copyright Grant Searle
                        	     3: ;
                        	     4: ; You have permission to use this for NON COMMERCIAL USE ONLY
                        	     5: ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        	     6: ;
                        	     7: ; http://searle.hostei.com/grant/index.html
                        	     8: ;
                        	     9: ; eMail: home.micros01@btinternet.com
                        	    10: ;
                        	    11: ; If the above don't work, please perform an Internet search to see if I have
                        	    12: ; updated the web page hosting service.
                        	    13: ;
                        	    14: ;==================================================================================
                        	    15: 
                        	    16: ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        	    17: ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        	    18: ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        	    19: ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        	    20: ; the original ROM code (checksum A934H). PA
                        	    21: ;
                        	    22: ;==================================================================================
                        	    23: 
                        	    24: ; BASIC ERROR CODE VALUES
                        	    25: 
                        	    26: NF		.EQU	00H				; NEXT without FOR
                        	    27: SN		.EQU	02H				; Syntax error
                        	    28: RG		.EQU	04H				; RETURN without GOSUB
                        	    29: OD		.EQU	06H				; Out of DATA
                        	    30: FC		.EQU	08H				; Function call error
                        	    31: OV		.EQU	0AH				; Overflow
                        	    32: OM		.EQU	0CH				; Out of memory
                        	    33: UL		.EQU	0EH				; Undefined line number
                        	    34: BS		.EQU	10H				; Bad subscript
                        	    35: DD		.EQU	12H				; Re-DIMensioned array
                        	    36: DZ		.EQU	14H				; Division by zero (/0)
                        	    37: ID		.EQU	16H				; Illegal direct
                        	    38: TM		.EQU	18H				; Type miss-match
                        	    39: OS		.EQU	1AH				; Out of string space
                        	    40: LS		.EQU	1CH				; String too long
                        	    41: ST		.EQU	1EH				; String formula too complex
                        	    42: CN		.EQU	20H				; Can't CONTinue
                        	    43: UF		.EQU	22H				; UnDEFined FN function
                        	    44: MO		.EQU	24H				; Missing operand
                        	    45: HX		.EQU	26H				; HEX error
                        	    46: BN		.EQU	28H				; BIN error
                        	    47: 
                        	    48: 
                        	    49: ; BASIC WORK SPACE LOCATIONS
                        	    50: 
                        	    51: ;WRKSPC	.EQU	2045H			  ; BASIC Work space
                        	    52: WRKSPC	.EQU	$1000			  ; BASIC Work space
                        	    53: USR		.EQU	WRKSPC+3H			; "USR (x)" jump
                        	    54: OUTSUB	.EQU	WRKSPC+6H			; "OUT p,n"
                        	    55: OTPORT	.EQU	WRKSPC+7H			; Port (p)
                        	    56: DIVSUP	.EQU	WRKSPC+9H			; Division support routine
                        	    57: DIV1	.EQU	WRKSPC+0AH			 ; <- Values
                        	    58: DIV2	.EQU	WRKSPC+0EH			 ; <-	to
                        	    59: DIV3	.EQU	WRKSPC+12H			 ; <-	be
                        	    60: DIV4	.EQU	WRKSPC+15H			 ; <-inserted
                        	    61: SEED	.EQU	WRKSPC+17H			 ; Random number seed
                        	    62: LSTRND	.EQU	WRKSPC+3AH			 ; Last random number
                        	    63: INPSUB	.EQU	WRKSPC+3EH			 ; #INP (x)" Routine
                        	    64: INPORT	.EQU	WRKSPC+3FH			 ; PORT (x)
                        	    65: NULLS	.EQU	WRKSPC+41H			 ; Number of nulls
                        	    66: LWIDTH	.EQU	WRKSPC+42H			 ; Terminal width
                        	    67: COMMAN	.EQU	WRKSPC+43H			 ; Width for commas
                        	    68: NULFLG	.EQU	WRKSPC+44H			 ; Null after input byte flag
                        	    69: CTLOFG	.EQU	WRKSPC+45H			 ; Control "O" flag
                        	    70: LINESC	.EQU	WRKSPC+46H			 ; Lines counter
                        	    71: LINESN	.EQU	WRKSPC+48H			 ; Lines number
                        	    72: CHKSUM	.EQU	WRKSPC+4AH			 ; Array load/save check sum
                        	    73: NMIFLG	.EQU	WRKSPC+4CH			 ; Flag for NMI break routine
                        	    74: BRKFLG	.EQU	WRKSPC+4DH			 ; Break flag
                        	    75: RINPUT	.EQU	WRKSPC+4EH			 ; Input reflection
                        	    76: POINT	.EQU	WRKSPC+51H			 ; "POINT" reflection (unused)
                        	    77: PSET	.EQU	WRKSPC+54H			 ; "SET"   reflection
                        	    78: RESET	.EQU	WRKSPC+57H			 ; "RESET" reflection
                        	    79: STRSPC	.EQU	WRKSPC+5AH			 ; Bottom of string space
                        	    80: LINEAT	.EQU	WRKSPC+5CH			 ; Current line number
                        	    81: BASTXT	.EQU	WRKSPC+5EH			 ; Pointer to start of program
                        	    82: BUFFER	.EQU	WRKSPC+61H			 ; Input buffer
                        	    83: STACK	.EQU	WRKSPC+66H			 ; Initial stack
                        	    84: CURPOS	.EQU	WRKSPC+0ABH			 ; Character position on line
                        	    85: LCRFLG	.EQU	WRKSPC+0ACH			 ; Locate/Create flag
                        	    86: TYPE	.EQU	WRKSPC+0ADH			 ; Data type flag
                        	    87: DATFLG	.EQU	WRKSPC+0AEH			 ; Literal statement flag
                        	    88: LSTRAM	.EQU	WRKSPC+0AFH			 ; Last available RAM
                        	    89: TMSTPT	.EQU	WRKSPC+0B1H			 ; Temporary string pointer
                        	    90: TMSTPL	.EQU	WRKSPC+0B3H			 ; Temporary string pool
                        	    91: TMPSTR	.EQU	WRKSPC+0BFH			 ; Temporary string
                        	    92: STRBOT	.EQU	WRKSPC+0C3H			 ; Bottom of string space
                        	    93: CUROPR	.EQU	WRKSPC+0C5H			 ; Current operator in EVAL
                        	    94: LOOPST	.EQU	WRKSPC+0C7H			 ; First statement of loop
                        	    95: DATLIN	.EQU	WRKSPC+0C9H			 ; Line of current DATA item
                        	    96: FORFLG	.EQU	WRKSPC+0CBH			 ; "FOR" loop flag
                        	    97: LSTBIN	.EQU	WRKSPC+0CCH			 ; Last byte entered
                        	    98: READFG	.EQU	WRKSPC+0CDH			 ; Read/Input flag
                        	    99: BRKLIN	.EQU	WRKSPC+0CEH			 ; Line of break
                        	   100: NXTOPR	.EQU	WRKSPC+0D0H			 ; Next operator in EVAL
                        	   101: ERRLIN	.EQU	WRKSPC+0D2H			 ; Line of error
                        	   102: CONTAD	.EQU	WRKSPC+0D4H			 ; Where to CONTinue
                        	   103: PROGND	.EQU	WRKSPC+0D6H			 ; End of program
                        	   104: VAREND	.EQU	WRKSPC+0D8H			 ; End of variables
                        	   105: ARREND	.EQU	WRKSPC+0DAH			 ; End of arrays
                        	   106: NXTDAT	.EQU	WRKSPC+0DCH			 ; Next data item
                        	   107: FNRGNM	.EQU	WRKSPC+0DEH			 ; Name of FN argument
                        	   108: FNARG	.EQU	WRKSPC+0E0H			 ; FN argument value
                        	   109: FPREG	.EQU	WRKSPC+0E4H			 ; Floating point register
                        	   110: FPEXP	.EQU	FPREG+3			; Floating point exponent
                        	   111: SGNRES	.EQU	WRKSPC+0E8H		; Sign of result
                        	   112: PBUFF	.EQU	WRKSPC+0E9H		; Number print buffer
                        	   113: MULVAL	.EQU	WRKSPC+0F6H		; Multiplier
                        	   114: PROGST	.EQU	WRKSPC+0F9H		; Start of program text area
                        	   115: STLOOK	.EQU	WRKSPC+15DH		; Start of memory test
                        	   116: 
                        	   117: 
                        	   118: ;TEMPSTACK	.EQU	$20ED ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   119: TEMPSTACK	.EQU	$7FFF ; Top of BASIC line input buffer so is "free ram" when BASIC resets
                        	   120: 
                        	   121: 
                        	   122: ;  ____       _      ____    ___    ____ 
                        	   123: ; | __ )     / \    / ___|  |_ _|  / ___|
                        	   124: ; |  _ \    / _ \   \___ \   | |  | |    
                        	   125: ; | |_) |  / ___ \   ___) |  | |  | |___ 
                        	   126: ; |____/  /_/   \_\ |____/  |___|  \____|
                        	   127: ;
                        	   128: ;
                        	   129: ; *********************************************************************************************************************
                        	   130: 
                        	   131: BASIC:
01:8B45 CDAA82          	   132: 	call	ClearScreen				; Clear screen
01:8B48 216E8B          	   133: 	ld		HL,SignOnMsg			; Sign-on message
01:8B4B CDAE80          	   134: 	call	PrintString				; Output string
                        	   135: 
                        	   136: ColdOrWarm:
01:8B4E CDC780          	   137: 	call	ReadChar				; Read a character
01:8B51 CD9F82          	   138: 	call	Uppercase				; Convert to uppercase
                        	   139: 
                        	   140: CheckIfCold:
01:8B54 FE43            	   141: 	cp		"C"						; Is it C for Coldstart?
01:8B56 2009            	   142: 	jr		nz,CheckIfWarm			; No, then check if it's Warmstart
01:8B58 CD7480          	   143: 	call	PrintChar				; Print the C
01:8B5B CD7F80          	   144: 	call	PrintCRLF				; Print carriage return and linefeed
01:8B5E C3CA8B          	   145: 	jp		COLD					; Start BASIC COLD
                        	   146: 
                        	   147: CheckIfWarm:
01:8B61 FE57            	   148: 	cp		"W"						
01:8B63 20E9            	   149: 	jr		nz,ColdOrWarm
01:8B65 CD7480          	   150: 	call	PrintChar
01:8B68 CD7F80          	   151: 	call	PrintCRLF
01:8B6B C3688C          	   152: 	jp		WARM					; Start BASIC WARM
                        	   153: 			  
                        	   154: SignOnMsg:
01:8B6E 5570646174657320	   155: 	db		"Updates to BASIC by Grant Searle",CR,LF
01:8B76 746F204241534943
01:8B7E 206279204772616E
01:8B86 7420536561726C65
01:8B8E 0D
01:8B8F 0A
01:8B90 4164617074656420	   156: 	db		"Adapted by Frederic Segard",CR,LF
01:8B98 6279204672656465
01:8BA0 7269632053656761
01:8BA8 7264
01:8BAA 0D
01:8BAB 0A
01:8BAC 436F6C64206F7220	   157: 	db		"Cold or warm start (C or W)? ",0
01:8BB4 7761726D20737461
01:8BBC 7274202843206F72
01:8BC4 2057293F20
01:8BC9 00
                        	   158: 
                        	   159: ; COLD START SEQUENCE
                        	   160: COLD:
01:8BCA DD210000        	   161: 	LD		IX,0					; Flag cold start
01:8BCE C3D58B          	   162: 	jp		CSTART					; Jump to initialise
                        	   163: 
01:8BD1 7D94            	   164: 	dw		DEINT					; Get integer -32768 to 32767
01:8BD3 F39B            	   165: 	dw		ABPASS					; Return integer in AB
                        	   166: 
                        	   167: CSTART:
01:8BD5 210010          	   168: 	ld		HL,WRKSPC				; Start of workspace RAM
01:8BD8 F9              	   169: 	ld		SP,HL					; Set up a temporary stack
01:8BD9 C312A8          	   170: 	jp		INITST					; Go to initialise
                        	   171: 
                        	   172: INIT:
01:8BDC 11A18E          	   173: 	ld		DE,INITAB				; Initialise workspace
01:8BDF 0663            	   174: 	ld		B,INITBE-INITAB+3		; Bytes to copy
01:8BE1 210010          	   175: 	ld		HL,WRKSPC				; Into workspace RAM
                        	   176: COPYY:
01:8BE4 1A              	   177: 	ld		A,(DE)					; Get source
01:8BE5 77              	   178: 	ld		(HL),A					; To destination
01:8BE6 23              	   179: 	inc		HL						; Next destination
01:8BE7 13              	   180: 	inc		DE						; Next source
01:8BE8 05              	   181: 	dec		B						; Count bytes
01:8BE9 C2E48B          	   182: 	jp		NZ,COPYY				; More to move
01:8BEC F9              	   183: 	ld		SP,HL					; Temporary stack
01:8BED CDA290          	   184: 	call	CLREG					; Clear registers and stack
01:8BF0 CD7396          	   185: 	call	PRNTCRLF				; Output CRLF
01:8BF3 32AA10          	   186: 	ld		(BUFFER+72+1),A 		; Mark end of buffer
01:8BF6 32F910          	   187: 	ld		(PROGST),A				; Initialise program area
                        	   188: MSIZE:
01:8BF9 21B68C          	   189: 	ld		HL,MEMMSG				; Point to message
01:8BFC CD119D          	   190: 	call	PRS						; Output "Memory size"
01:8BFF CDBF90          	   191: 	call	PROMPT					; Get input with '?'
01:8C02 CDC893          	   192: 	call	GETCHR					; Get next character
01:8C05 B7              	   193: 	or		A						; Set flags
01:8C06 C21E8C          	   194: 	jp		NZ,TSTMEM				; If number - Test if RAM there
01:8C09 215D11          	   195: 	ld		HL,STLOOK				; Point to start of RAM
                        	   196: MLOOP:
01:8C0C 23              	   197: 	inc		HL						; Next byte
01:8C0D 7C              	   198: 	ld		A,H						; Above address FFFF ?
01:8C0E B5              	   199: 	or		L
01:8C0F CA308C          	   200: 	jp		Z,SETTOP				; Yes - 64K RAM
01:8C12 7E              	   201: 	ld		A,(HL)					; Get contents
01:8C13 47              	   202: 	ld		B,A						; Save it
01:8C14 2F              	   203: 	cpl								; Flip all bits
01:8C15 77              	   204: 	ld		(HL),A					; Put it back
01:8C16 BE              	   205: 	cp		(HL)					; RAM there if same
01:8C17 70              	   206: 	ld		(HL),B					; Restore old contents
01:8C18 CA0C8C          	   207: 	jp		Z,MLOOP					; If RAM - test next byte
01:8C1B C3308C          	   208: 	jp		SETTOP					; Top of RAM found
                        	   209: 
                        	   210: TSTMEM:
01:8C1E CD9794          	   211: 	call	ATOH					; Get high memory into DE
01:8C21 B7              	   212: 	or		A						; Set flags on last byte
01:8C22 C2708F          	   213: 	jp		NZ,SNERR				; ?SN Error if bad character
01:8C25 EB              	   214: 	ex		DE,HL					; Address into HL
01:8C26 2B              	   215: 	dec		HL						; Back one byte
01:8C27 3ED9            	   216: 	ld		A,11011001B				; Test byte
01:8C29 46              	   217: 	ld		B,(HL)					; Get old contents
01:8C2A 77              	   218: 	ld		(HL),A					; Load test byte
01:8C2B BE              	   219: 	cp		(HL)					; RAM there if same
01:8C2C 70              	   220: 	ld		(HL),B					; Restore old contents
01:8C2D C2F98B          	   221: 	jp		NZ,MSIZE				; Ask again if no RAM
                        	   222: 
                        	   223: SETTOP:
01:8C30 2B              	   224: 	dec		HL						; Back one byte
01:8C31 115C11          	   225: 	ld		DE,STLOOK-1				; See if enough RAM
01:8C34 CD3892          	   226: 	call	CPDEHL					; Compare DE with HL
01:8C37 DAF98B          	   227: 	jp		C,MSIZE					; Ask again if not enough RAM
01:8C3A 11CEFF          	   228: 	ld		DE,0-50					; 50 Bytes string space
01:8C3D 22AF10          	   229: 	ld		(LSTRAM),HL				; Save last available RAM
01:8C40 19              	   230: 	add		HL,DE					; Allocate string space
01:8C41 225A10          	   231: 	ld		(STRSPC),HL				; Save string space
01:8C44 CD7D90          	   232: 	call	CLRPTR					; Clear program area
01:8C47 2A5A10          	   233: 	ld		HL,(STRSPC)				; Get end of memory
01:8C4A 11EFFF          	   234: 	ld		DE,0-17					; Offset for free bytes
01:8C4D 19              	   235: 	add		HL,DE					; Adjust HL
01:8C4E 11F910          	   236: 	ld		DE,PROGST				; Start of program text
01:8C51 7D              	   237: 	ld		A,L						; Get LSB
01:8C52 93              	   238: 	sub		E						; Adjust it
01:8C53 6F              	   239: 	ld		L,A						; Re-save
01:8C54 7C              	   240: 	ld		A,H						; Get MSB
01:8C55 9A              	   241: 	sbc		A,D						; Adjust it
01:8C56 67              	   242: 	ld		H,A						; Re-save
01:8C57 E5              	   243: 	push	HL						; Save bytes free
01:8C58 21808C          	   244: 	ld		HL,SIGNON				; Sign-on message
01:8C5B CD119D          	   245: 	call	PRS						; Output string
01:8C5E E1              	   246: 	pop		HL						; Get bytes free back
01:8C5F CDB4A3          	   247: 	call	PRNTHL					; Output amount of free memory
01:8C62 21718C          	   248: 	ld		HL,BFREE				; " Bytes free" message
01:8C65 CD119D          	   249: 	call	PRS						; Output string
                        	   250: 
                        	   251: WARM:								; WARM START
01:8C68 316610          	   252: 	ld		SP,STACK				; Temporary stack
                        	   253: BRKRET:
01:8C6B CDA290          	   254: 	call	CLREG					; Clear registers and stack
01:8C6E C3BB8F          	   255: 	jp		PRNTOK					; Go to get command line
                        	   256: 
                        	   257: BFREE:	
01:8C71 2042797465732066	   258: 	db	" Bytes free",CR,LF,0,0
01:8C79 726565
01:8C7C 0D
01:8C7D 0A
01:8C7E 00
01:8C7F 00
                        	   259: 
                        	   260: SIGNON: 
01:8C80 5A38302042415349	   261: 	db	"Z80 BASIC Ver 4.7b",CR,LF
01:8C88 432056657220342E
01:8C90 3762
01:8C92 0D
01:8C93 0A
01:8C94 436F707972696768	   262: 	db	"Copyright (C) 1978 by Microsoft",CR,LF,0
01:8C9C 7420284329203139
01:8CA4 3738206279204D69
01:8CAC 63726F736F6674
01:8CB3 0D
01:8CB4 0A
01:8CB5 00
                        	   263: 
                        	   264: MEMMSG:
01:8CB6 4D656D6F72792074	   265: 	db	"Memory top",0
01:8CBE 6F70
01:8CC0 00
                        	   266: 
                        	   267: 
                        	   268: ; FUNCTION ADDRESS TABLE
                        	   269: 
                        	   270: FNCTAB:
01:8CC1 29A2            	   271: 	dw	SGN
01:8CC3 EDA2            	   272: 	dw	INT
01:8CC5 3FA2            	   273: 	dw	ABS
01:8CC7 0310            	   274: 	dw	USR
01:8CC9 D19B            	   275: 	dw	FRE
01:8CCB 569F            	   276: 	dw	INP
01:8CCD FF9B            	   277: 	dw	POS
01:8CCF B3A4            	   278: 	dw	SQR
01:8CD1 92A5            	   279: 	dw	RND
01:8CD3 CEA0            	   280: 	dw	LOG
01:8CD5 01A5            	   281: 	dw	EXPP
01:8CD7 07A6            	   282: 	dw	COS
01:8CD9 0DA6            	   283: 	dw	SIN
01:8CDB 6EA6            	   284: 	dw	TAN
01:8CDD 83A6            	   285: 	dw	ATN
01:8CDF AA9F            	   286: 	dw	PEEK
01:8CE1 EEA6            	   287: 	dw	DEEK
01:8CE3 5110            	   288: 	dw	POINT
01:8CE5 839E            	   289: 	dw	LEN
01:8CE7 9B9C            	   290: 	dw	STRR
01:8CE9 1D9F            	   291: 	dw	VAL
01:8CEB 929E            	   292: 	dw	ASCC
01:8CED A39E            	   293: 	dw	CHR
01:8CEF 10A7            	   294: 	dw	HEX
01:8CF1 A3A7            	   295: 	dw	BIN
01:8CF3 B39E            	   296: 	dw	LEFT
01:8CF5 E39E            	   297: 	dw	RIGHT
01:8CF7 ED9E            	   298: 	dw	MID
                        	   299: 
                        	   300: 
                        	   301: ; RESERVED WORD LIST
                        	   302: 
                        	   303: WORDS:
01:8CF9 C5              	   304: 	db	'E'+80H,"ND"
01:8CFA 4E44
01:8CFC C6              	   305: 	db	'F'+80H,"OR"
01:8CFD 4F52
01:8CFF CE              	   306: 	db	'N'+80H,"EXT"
01:8D00 455854
01:8D03 C4              	   307: 	db	'D'+80H,"ATA"
01:8D04 415441
01:8D07 C9              	   308: 	db	'I'+80H,"NPUT"
01:8D08 4E505554
01:8D0C C4              	   309: 	db	'D'+80H,"IM"
01:8D0D 494D
01:8D0F D2              	   310: 	db	'R'+80H,"EAD"
01:8D10 454144
01:8D13 CC              	   311: 	db	'L'+80H,"ET"
01:8D14 4554
01:8D16 C7              	   312: 	db	'G'+80H,"OTO"
01:8D17 4F544F
01:8D1A D2              	   313: 	db	'R'+80H,"UN"
01:8D1B 554E
01:8D1D C9              	   314: 	db	'I'+80H,"F"
01:8D1E 46
01:8D1F D2              	   315: 	db	'R'+80H,"ESTORE"
01:8D20 4553544F5245
01:8D26 C7              	   316: 	db	'G'+80H,"OSUB"
01:8D27 4F535542
01:8D2B D2              	   317: 	db	'R'+80H,"ETURN"
01:8D2C 455455524E
01:8D31 D2              	   318: 	db	'R'+80H,"EM"
01:8D32 454D
01:8D34 D3              	   319: 	db	'S'+80H,"TOP"
01:8D35 544F50
01:8D38 CF              	   320: 	db	'O'+80H,"UT"
01:8D39 5554
01:8D3B CF              	   321: 	db	'O'+80H,"N"
01:8D3C 4E
01:8D3D CE              	   322: 	db	'N'+80H,"ULL"
01:8D3E 554C4C
01:8D41 D7              	   323: 	db	'W'+80H,"AIT"
01:8D42 414954
01:8D45 C4              	   324: 	db	'D'+80H,"EF"
01:8D46 4546
01:8D48 D0              	   325: 	db	'P'+80H,"OKE"
01:8D49 4F4B45
01:8D4C C4              	   326: 	db	'D'+80H,"OKE"
01:8D4D 4F4B45
01:8D50 D3              	   327: 	db	'S'+80H,"CREEN"
01:8D51 435245454E
01:8D56 CC              	   328: 	db	'L'+80H,"INES"
01:8D57 494E4553
01:8D5B C3              	   329: 	db	'C'+80H,"LS"
01:8D5C 4C53
01:8D5E D7              	   330: 	db	'W'+80H,"IDTH"
01:8D5F 49445448
01:8D63 CD              	   331: 	db	'M'+80H,"ONITOR"
01:8D64 4F4E49544F52
01:8D6A D3              	   332: 	db	'S'+80H,"ET"
01:8D6B 4554
01:8D6D D2              	   333: 	db	'R'+80H,"ESET"
01:8D6E 45534554
01:8D72 D0              	   334: 	db	'P'+80H,"RINT"
01:8D73 52494E54
01:8D77 C3              	   335: 	db	'C'+80H,"ONT"
01:8D78 4F4E54
01:8D7B CC              	   336: 	db	'L'+80H,"IST"
01:8D7C 495354
01:8D7F C3              	   337: 	db	'C'+80H,"LEAR"
01:8D80 4C454152
01:8D84 C3              	   338: 	db	'C'+80H,"LOAD"
01:8D85 4C4F4144
01:8D89 C3              	   339: 	db	'C'+80H,"SAVE"
01:8D8A 53415645
01:8D8E CE              	   340: 	db	'N'+80H,"EW"
01:8D8F 4557
                        	   341: 
01:8D91 D4              	   342: 	db	'T'+80H,"AB("
01:8D92 414228
01:8D95 D4              	   343: 	db	'T'+80H,"O"
01:8D96 4F
01:8D97 C6              	   344: 	db	'F'+80H,"N"
01:8D98 4E
01:8D99 D3              	   345: 	db	'S'+80H,"PC("
01:8D9A 504328
01:8D9D D4              	   346: 	db	'T'+80H,"HEN"
01:8D9E 48454E
01:8DA1 CE              	   347: 	db	'N'+80H,"OT"
01:8DA2 4F54
01:8DA4 D3              	   348: 	db	'S'+80H,"TEP"
01:8DA5 544550
                        	   349: 
01:8DA8 AB              	   350: 	db	'+'+80H
01:8DA9 AD              	   351: 	db	'-'+80H
01:8DAA AA              	   352: 	db	'*'+80H
01:8DAB AF              	   353: 	db	'/'+80H
01:8DAC DE              	   354: 	db	'^'+80H
01:8DAD C1              	   355: 	db	'A'+80H,"ND"
01:8DAE 4E44
01:8DB0 CF              	   356: 	db	'O'+80H,"R"
01:8DB1 52
01:8DB2 BE              	   357: 	db	'>'+80H
01:8DB3 BD              	   358: 	db	'='+80H
01:8DB4 BC              	   359: 	db	'<'+80H
                        	   360: 
01:8DB5 D3              	   361: 	db	'S'+80H,"GN"
01:8DB6 474E
01:8DB8 C9              	   362: 	db	'I'+80H,"NT"
01:8DB9 4E54
01:8DBB C1              	   363: 	db	'A'+80H,"BS"
01:8DBC 4253
01:8DBE D5              	   364: 	db	'U'+80H,"SR"
01:8DBF 5352
01:8DC1 C6              	   365: 	db	'F'+80H,"RE"
01:8DC2 5245
01:8DC4 C9              	   366: 	db	'I'+80H,"NP"
01:8DC5 4E50
01:8DC7 D0              	   367: 	db	'P'+80H,"OS"
01:8DC8 4F53
01:8DCA D3              	   368: 	db	'S'+80H,"QR"
01:8DCB 5152
01:8DCD D2              	   369: 	db	'R'+80H,"ND"
01:8DCE 4E44
01:8DD0 CC              	   370: 	db	'L'+80H,"OG"
01:8DD1 4F47
01:8DD3 C5              	   371: 	db	'E'+80H,"XP"
01:8DD4 5850
01:8DD6 C3              	   372: 	db	'C'+80H,"OS"
01:8DD7 4F53
01:8DD9 D3              	   373: 	db	'S'+80H,"IN"
01:8DDA 494E
01:8DDC D4              	   374: 	db	'T'+80H,"AN"
01:8DDD 414E
01:8DDF C1              	   375: 	db	'A'+80H,"TN"
01:8DE0 544E
01:8DE2 D0              	   376: 	db	'P'+80H,"EEK"
01:8DE3 45454B
01:8DE6 C4              	   377: 	db	'D'+80H,"EEK"
01:8DE7 45454B
01:8DEA D0              	   378: 	db	'P'+80H,"OINT"
01:8DEB 4F494E54
01:8DEF CC              	   379: 	db	'L'+80H,"EN"
01:8DF0 454E
01:8DF2 D3              	   380: 	db	'S'+80H,"TR$"
01:8DF3 545224
01:8DF6 D6              	   381: 	db	'V'+80H,"AL"
01:8DF7 414C
01:8DF9 C1              	   382: 	db	'A'+80H,"SC"
01:8DFA 5343
01:8DFC C3              	   383: 	db	'C'+80H,"HR$"
01:8DFD 485224
01:8E00 C8              	   384: 	db	'H'+80H,"EX$"
01:8E01 455824
01:8E04 C2              	   385: 	db	'B'+80H,"IN$"
01:8E05 494E24
01:8E08 CC              	   386: 	db	'L'+80H,"EFT$"
01:8E09 45465424
01:8E0D D2              	   387: 	db	'R'+80H,"IGHT$"
01:8E0E 4947485424
01:8E13 CD              	   388: 	db	'M'+80H,"ID$"
01:8E14 494424
01:8E17 80              	   389: 	db	80H				; End of list marker
                        	   390: 
                        	   391: ; KEYWORD ADDRESS TABLE
                        	   392: 
                        	   393: WORDTB:
01:8E18 1594            	   394: 	dw	PEND
01:8E1A 0F93            	   395: 	dw	FOR
01:8E1C ED97            	   396: 	dw	NEXT
01:8E1E 6295            	   397: 	dw	DATAA
01:8E20 F496            	   398: 	dw	INPUT
01:8E22 299A            	   399: 	dw	DIM
01:8E24 2397            	   400: 	dw	READ
01:8E26 7995            	   401: 	dw	LET
01:8E28 1F95            	   402: 	dw	GOTO
01:8E2A 0295            	   403: 	dw	RUN
01:8E2C F195            	   404: 	dw	IFF
01:8E2E D893            	   405: 	dw	RESTOR
01:8E30 0E95            	   406: 	dw	GOSUB
01:8E32 3D95            	   407: 	dw	RETURN
01:8E34 6495            	   408: 	dw	REM
01:8E36 1394            	   409: 	dw	STOPP
01:8E38 629F            	   410: 	dw	POUT
01:8E3A D395            	   411: 	dw	ON
01:8E3C 5494            	   412: 	dw	NULLL
01:8E3E 689F            	   413: 	dw	WAIT
01:8E40 079C            	   414: 	dw	DEF
01:8E42 B19F            	   415: 	dw	POKE
01:8E44 F9A6            	   416: 	dw	DOKE
01:8E46 6495            	   417: 	dw	REM
01:8E48 DFA6            	   418: 	dw	LINES
01:8E4A D4A6            	   419: 	dw	CLS
01:8E4C D7A6            	   420: 	dw	WIDTH
01:8E4E 0FA8            	   421: 	dw	MONITR
01:8E50 5410            	   422: 	dw	PSET
01:8E52 5710            	   423: 	dw	RESET
01:8E54 1596            	   424: 	dw	PRINTT
01:8E56 4194            	   425: 	dw	CONT
01:8E58 8492            	   426: 	dw	LISTT
01:8E5A BC94            	   427: 	dw	CLEAR
01:8E5C 6495            	   428: 	dw	REM
01:8E5E 6495            	   429: 	dw	REM
01:8E60 7C90            	   430: 	dw	NEW
                        	   431: 
                        	   432: ; RESERVED WORD TOKEN VALUES
                        	   433: 
                        	   434: ZEND	.EQU	080H			; END
                        	   435: ZFOR	.EQU	081H			; FOR
                        	   436: ZDATA	.EQU	083H			; DATA
                        	   437: ZGOTO	.EQU	088H			; GOTO
                        	   438: ZGOSUB	.EQU	08CH			; GOSUB
                        	   439: ZREM	.EQU	08EH			; REM
                        	   440: ZPRINT	.EQU	09EH			; PRINT
                        	   441: ZNEW	.EQU	0A4H			; NEW
                        	   442: 
                        	   443: ZTAB	.EQU	0A5H			; TAB
                        	   444: ZTO		.EQU	0A6H			; TO
                        	   445: ZFN		.EQU	0A7H			; FN
                        	   446: ZSPC	.EQU	0A8H			; SPC
                        	   447: ZTHEN	.EQU	0A9H			; THEN
                        	   448: ZNOT	.EQU	0AAH			; NOT
                        	   449: ZSTEP	.EQU	0ABH			; STEP
                        	   450: 
                        	   451: ZPLUS	.EQU	0ACH			; +
                        	   452: ZMINUS	.EQU	0ADH			; -
                        	   453: ZTIMES	.EQU	0AEH			; *
                        	   454: ZDIV	.EQU	0AFH			; /
                        	   455: ZOR		.EQU	0B2H			; OR
                        	   456: ZGTR	.EQU	0B3H			; >
                        	   457: ZEQUAL	.EQU	0B4H			; M
                        	   458: ZLTH	.EQU	0B5H			; <
                        	   459: ZSGN	.EQU	0B6H			; SGN
                        	   460: ZPOINT	.EQU	0C7H			; POINT
                        	   461: ZLEFT	.EQU	0CDH +2			; LEFT$
                        	   462: 
                        	   463: ; ARITHMETIC PRECEDENCE TABLE
                        	   464: 
01:8E62 79              	   465: PRITAB: db	79H				; Precedence value
01:8E63 9BA3            	   466: 		dw	PADD			; FPREG = <last> + FPREG
                        	   467: 
01:8E65 79              	   468: 		db	79H				; Precedence value
01:8E66 CF9F            	   469: 		dw	PSUB			; FPREG = <last> - FPREG
                        	   470: 
01:8E68 7C              	   471: 		db	7CH				; Precedence value
01:8E69 0DA1            	   472: 		dw	MULTT			; PPREG = <last> * FPREG
                        	   473: 
01:8E6B 7C              	   474: 		db	7CH				; Precedence value
01:8E6C 6EA1            	   475: 		dw	DIV				; FPREG = <last> / FPREG
                        	   476: 
01:8E6E 7F              	   477: 		db	7FH				; Precedence value
01:8E6F BCA4            	   478: 		dw	POWER			; FPREG = <last> ^ FPREG
                        	   479: 
01:8E71 50              	   480: 		db	50H				; Precedence value
01:8E72 8299            	   481: 		dw	PAND			; FPREG = <last> AND FPREG
                        	   482: 
01:8E74 46              	   483: 		db	46H				; Precedence value
01:8E75 8199            	   484: 		dw	POR				; FPREG = <last> OR FPREG
                        	   485: 
                        	   486: ; BASIC ERROR CODE LIST
                        	   487: 
01:8E77 4E46            	   488: ERRORS: db	"NF"			; NEXT without FOR
01:8E79 534E            	   489: 		db	"SN"			; Syntax error
01:8E7B 5247            	   490: 		db	"RG"			; RETURN without GOSUB
01:8E7D 4F44            	   491: 		db	"OD"			; Out of DATA
01:8E7F 4643            	   492: 		db	"FC"			; Illegal function call
01:8E81 4F56            	   493: 		db	"OV"			; Overflow error
01:8E83 4F4D            	   494: 		db	"OM"			; Out of memory
01:8E85 554C            	   495: 		db	"UL"			; Undefined line
01:8E87 4253            	   496: 		db	"BS"			; Bad subscript
01:8E89 4444            	   497: 		db	"DD"			; Re-DIMensioned array
01:8E8B 2F30            	   498: 		db	"/0"			; Division by zero
01:8E8D 4944            	   499: 		db	"ID"			; Illegal direct
01:8E8F 544D            	   500: 		db	"TM"			; Type mis-match
01:8E91 4F53            	   501: 		db	"OS"			; Out of string space
01:8E93 4C53            	   502: 		db	"LS"			; String too long
01:8E95 5354            	   503: 		db	"ST"			; String formula too complex
01:8E97 434E            	   504: 		db	"CN"			; Can't CONTinue
01:8E99 5546            	   505: 		db	"UF"			; Undefined FN function
01:8E9B 4D4F            	   506: 		db	"MO"			; Missing operand
01:8E9D 4858            	   507: 		db	"HX"			; HEX error
01:8E9F 424E            	   508: 		db	"BN"			; BIN error
                        	   509: 
                        	   510: ; INITIALISATION TABLE -------------------------------------------------------
                        	   511: 
01:8EA1 C3688C          	   512: INITAB: JP		WARM			; Warm start jump
01:8EA4 C39294          	   513: 		JP		FCERR			; "USR (X)" jump (Set to Error)
01:8EA7 D300            	   514: 		OUT		(0),A			; "OUT p,n" skeleton
01:8EA9 C9              	   515: 		RET
01:8EAA D600            	   516: 		SUB		0				; Division support routine
01:8EAC 6F              	   517: 		LD		L,A
01:8EAD 7C              	   518: 		LD		A,H
01:8EAE DE00            	   519: 		SBC		A,0
01:8EB0 67              	   520: 		LD		H,A
01:8EB1 78              	   521: 		LD		A,B
01:8EB2 DE00            	   522: 		SBC		A,0
01:8EB4 47              	   523: 		LD		B,A
01:8EB5 3E00            	   524: 		LD		A,0
01:8EB7 C9              	   525: 		RET
01:8EB8 00              	   526: 		db	0,0,0					; Random number seed table used by RND
01:8EB9 00
01:8EBA 00
01:8EBB 35              	   527: 		db	035H,04AH,0CAH,099H		;-2.65145E+07
01:8EBC 4A
01:8EBD CA
01:8EBE 99
01:8EBF 39              	   528: 		db	039H,01CH,076H,098H		; 1.61291E+07
01:8EC0 1C
01:8EC1 76
01:8EC2 98
01:8EC3 22              	   529: 		db	022H,095H,0B3H,098H		;-1.17691E+07
01:8EC4 95
01:8EC5 B3
01:8EC6 98
01:8EC7 0A              	   530: 		db	00AH,0DDH,047H,098H		; 1.30983E+07
01:8EC8 DD
01:8EC9 47
01:8ECA 98
01:8ECB 53              	   531: 		db	053H,0D1H,099H,099H		;-2-01612E+07
01:8ECC D1
01:8ECD 99
01:8ECE 99
01:8ECF 0A              	   532: 		db	00AH,01AH,09FH,098H		;-1.04269E+07
01:8ED0 1A
01:8ED1 9F
01:8ED2 98
01:8ED3 65              	   533: 		db	065H,0BCH,0CDH,098H		;-1.34831E+07
01:8ED4 BC
01:8ED5 CD
01:8ED6 98
01:8ED7 D6              	   534: 		db	0D6H,077H,03EH,098H		; 1.24825E+07
01:8ED8 77
01:8ED9 3E
01:8EDA 98
01:8EDB 52              	   535: 		db	052H,0C7H,04FH,080H		; Last random number
01:8EDC C7
01:8EDD 4F
01:8EDE 80
01:8EDF DB00            	   536: 		IN		A,(0)			; INP (x) skeleton
01:8EE1 C9              	   537: 		RET
01:8EE2 01              	   538: 		db	1				; POS (x) number (1)
01:8EE3 FF              	   539: 		db	255				; Terminal width (255 = no auto CRLF)
01:8EE4 1C              	   540: 		db	28				; Width for commas (3 columns)
01:8EE5 00              	   541: 		db	0				; No nulls after input bytes
01:8EE6 00              	   542: 		db	0				; Output enabled (^O off)
01:8EE7 1400            	   543: 		dw	20				; Initial lines counter
01:8EE9 1400            	   544: 		dw	20				; Initial lines number
01:8EEB 0000            	   545: 		dw	0				; Array load/save check sum
01:8EED 00              	   546: 		db	0				; Break not by NMI
01:8EEE 00              	   547: 		db	0				; Break flag
01:8EEF C3B591          	   548: 		JP		TTYLIN			; Input reflection (set to TTY)
01:8EF2 C30000          	   549: 		JP		$0000			; POINT reflection unused
01:8EF5 C30000          	   550: 		JP		$0000			; SET reflection
01:8EF8 C30000          	   551: 		JP		$0000			; RESET reflection
01:8EFB 5D11            	   552: 		dw	STLOOK			; Temp string space
01:8EFD FEFF            	   553: 		dw	-2				; Current line number (cold)
01:8EFF FA10            	   554: 		dw	PROGST+1		; Start of program text
                        	   555: INITBE:							
                        	   556: 
                        	   557: ; END OF INITIALISATION TABLE ---------------------------------------------------
                        	   558: 
01:8F01 204572726F72    	   559: ERRMSG: db	" Error",0
01:8F07 00
01:8F08 20696E20        	   560: INMSG:	db	" in ",0
01:8F0C 00
                        	   561: ZERBYT	.EQU	$-1				; A zero byte
01:8F0D 4F6B            	   562: OKMSG:	db	"Ok",CR,LF,0,0
01:8F0F 0D
01:8F10 0A
01:8F11 00
01:8F12 00
01:8F13 427265616B      	   563: BRKMSG: db	"Break",0
01:8F18 00
                        	   564: 
01:8F19 210400          	   565: BAKSTK: LD		HL,4			; Look for "FOR" block with
01:8F1C 39              	   566: 		ADD		HL,SP			; same index as specified
01:8F1D 7E              	   567: LOKFOR: LD		A,(HL)			; Get block ID
01:8F1E 23              	   568: 		INC		HL				; Point to index address
01:8F1F FE81            	   569: 		CP		ZFOR			; Is it a "FOR" token
01:8F21 C0              	   570: 		RET		NZ				; No - exit
01:8F22 4E              	   571: 		LD		C,(HL)			; BC = Address of "FOR" index
01:8F23 23              	   572: 		INC		HL
01:8F24 46              	   573: 		LD		B,(HL)
01:8F25 23              	   574: 		INC		HL				; Point to sign of STEP
01:8F26 E5              	   575: 		PUSH	HL				; Save pointer to sign
01:8F27 69              	   576: 		LD		L,C				; HL = address of "FOR" index
01:8F28 60              	   577: 		LD		H,B
01:8F29 7A              	   578: 		LD		A,D				; See if an index was specified
01:8F2A B3              	   579: 		OR		E				; DE = 0 if no index specified
01:8F2B EB              	   580: 		EX		DE,HL			; Specified index into HL
01:8F2C CA338F          	   581: 		JP		Z,INDFND		; Skip if no index given
01:8F2F EB              	   582: 		EX		DE,HL			; Index back into DE
01:8F30 CD3892          	   583: 		CALL	CPDEHL			; Compare index with one given
01:8F33 010D00          	   584: INDFND: LD		BC,16-3			; Offset to next block
01:8F36 E1              	   585: 		POP		HL				; Restore pointer to sign
01:8F37 C8              	   586: 		RET		Z				; Return if block found
01:8F38 09              	   587: 		ADD		HL,BC			; Point to next block
01:8F39 C31D8F          	   588: 		JP		LOKFOR			; Keep on looking
                        	   589: 
01:8F3C CD568F          	   590: MOVUP:	CALL	ENFMEM			; See if enough memory
01:8F3F C5              	   591: MOVSTR: PUSH	BC				; Save end of source
01:8F40 E3              	   592: 		EX		(SP),HL			; Swap source and dest" end
01:8F41 C1              	   593: 		POP		BC				; Get end of destination
01:8F42 CD3892          	   594: MOVLP:	CALL	CPDEHL			; See if list moved
01:8F45 7E              	   595: 		LD		A,(HL)			; Get byte
01:8F46 02              	   596: 		LD		(BC),A			; Move it
01:8F47 C8              	   597: 		RET		Z				; Exit if all done
01:8F48 0B              	   598: 		DEC		BC				; Next byte to move to
01:8F49 2B              	   599: 		DEC		HL				; Next byte to move
01:8F4A C3428F          	   600: 		JP		MOVLP			; Loop until all bytes moved
                        	   601: 
01:8F4D E5              	   602: CHKSTK: PUSH	HL				; Save code string address
01:8F4E 2ADA10          	   603: 		LD		HL,(ARREND)		; Lowest free memory
01:8F51 0600            	   604: 		LD		B,0				; BC = Number of levels to test
01:8F53 09              	   605: 		ADD		HL,BC			; 2 Bytes for each level
01:8F54 09              	   606: 		ADD		HL,BC
01:8F55 3E              	   607: 		db	3EH				; Skip "PUSH HL"
01:8F56 E5              	   608: ENFMEM: PUSH	HL				; Save code string address
01:8F57 3ED0            	   609: 		LD		A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
01:8F59 95              	   610: 		SUB		L
01:8F5A 6F              	   611: 		LD		L,A
01:8F5B 3EFF            	   612: 		LD		A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
01:8F5D 9C              	   613: 		SBC		A,H
01:8F5E DA658F          	   614: 		JP		C,OMERR			; Not enough - ?OM Error
01:8F61 67              	   615: 		LD		H,A
01:8F62 39              	   616: 		ADD		HL,SP			; Test if stack is overflowed
01:8F63 E1              	   617: 		POP		HL				; Restore code string address
01:8F64 D8              	   618: 		RET		C				; Return if enough mmory
01:8F65 1E0C            	   619: OMERR:	LD		E,OM			; ?OM Error
01:8F67 C3848F          	   620: 		JP		ERROR
                        	   621: 
01:8F6A 2AC910          	   622: DATSNR: LD		HL,(DATLIN)		; Get line of current DATA item
01:8F6D 225C10          	   623: 		LD		(LINEAT),HL		; Save as current line
01:8F70 1E02            	   624: SNERR:	LD		E,SN			; ?SN Error
01:8F72 01              	   625: 		db	01H				; Skip "LD E,DZ"
01:8F73 1E14            	   626: DZERR:	LD		E,DZ			; ?/0 Error
01:8F75 01              	   627: 		db	01H				; Skip "LD E,NF"
01:8F76 1E00            	   628: NFERR:	LD		E,NF			; ?NF Error
01:8F78 01              	   629: 		db	01H				; Skip "LD E,DD"
01:8F79 1E12            	   630: DDERR:	LD		E,DD			; ?DD Error
01:8F7B 01              	   631: 		db	01H				; Skip "LD E,UF"
01:8F7C 1E22            	   632: UFERR:	LD		E,UF			; ?UF Error
01:8F7E 01              	   633: 		db	01H				; Skip "LD E,OV
01:8F7F 1E0A            	   634: OVERR:	LD		E,OV			; ?OV Error
01:8F81 01              	   635: 		db	01H				; Skip "LD E,TM"
01:8F82 1E18            	   636: TMERR:	LD		E,TM			; ?TM Error
                        	   637: 
01:8F84 CDA290          	   638: ERROR:	CALL	CLREG			; Clear registers and stack
01:8F87 324510          	   639: 		LD		(CTLOFG),A		; Enable output (A is 0)
01:8F8A CD6696          	   640: 		CALL	STTLIN			; Start new line
01:8F8D 21778E          	   641: 		LD		HL,ERRORS		; Point to error codes
01:8F90 57              	   642: 		LD		D,A				; D = 0 (A is 0)
01:8F91 3E3F            	   643: 		LD		A,'?'
01:8F93 CD4992          	   644: 		CALL	OUTC			; Output '?'
01:8F96 19              	   645: 		ADD		HL,DE			; Offset to correct error code
01:8F97 7E              	   646: 		LD		A,(HL)			; First character
01:8F98 CD4992          	   647: 		CALL	OUTC			; Output it
01:8F9B CDC893          	   648: 		CALL	GETCHR			; Get next character
01:8F9E CD4992          	   649: 		CALL	OUTC			; Output it
01:8FA1 21018F          	   650: 		LD		HL,ERRMSG		; "Error" message
01:8FA4 CD119D          	   651: ERRIN:	CALL	PRS				; Output message
01:8FA7 2A5C10          	   652: 		LD		HL,(LINEAT)		; Get line of error
01:8FAA 11FEFF          	   653: 		LD		DE,-2			; Cold start error if -2
01:8FAD CD3892          	   654: 		CALL	CPDEHL			; See if cold start error
01:8FB0 CAD58B          	   655: 		JP		Z,CSTART		; Cold start error - Restart
01:8FB3 7C              	   656: 		LD		A,H				; Was it a direct error?
01:8FB4 A5              	   657: 		AND		L				; Line = -1 if direct error
01:8FB5 3C              	   658: 		INC		A
01:8FB6 C4ACA3          	   659: 		CALL	NZ,LINEIN		; No - output line of error
01:8FB9 3E              	   660: 		db	3EH				; Skip "POP BC"
01:8FBA C1              	   661: POPNOK: POP		BC				; Drop address in input buffer
                        	   662: 
01:8FBB AF              	   663: PRNTOK: XOR		A				; Output "Ok" and get command
01:8FBC 324510          	   664: 		LD		(CTLOFG),A		; Enable output
01:8FBF CD6696          	   665: 		CALL	STTLIN			; Start new line
01:8FC2 210D8F          	   666: 		LD		HL,OKMSG		; "Ok" message
01:8FC5 CD119D          	   667: 		CALL	PRS				; Output "Ok"
01:8FC8 21FFFF          	   668: GETCMD: LD		HL,-1			; Flag direct mode
01:8FCB 225C10          	   669: 		LD		(LINEAT),HL		; Save as current line
01:8FCE CDB591          	   670: 		CALL	GETLIN			; Get an input line
01:8FD1 DAC88F          	   671: 		JP		C,GETCMD		; Get line again if break
01:8FD4 CDC893          	   672: 		CALL	GETCHR			; Get first character
01:8FD7 3C              	   673: 		INC		A				; Test if end of line
01:8FD8 3D              	   674: 		DEC		A				; Without affecting Carry
01:8FD9 CAC88F          	   675: 		JP		Z,GETCMD		; Nothing entered - Get another
01:8FDC F5              	   676: 		PUSH	AF				; Save Carry status
01:8FDD CD9794          	   677: 		CALL	ATOH			; Get line number into DE
01:8FE0 D5              	   678: 		PUSH	DE				; Save line number
01:8FE1 CDCC90          	   679: 		CALL	CRUNCH			; Tokenise rest of line
01:8FE4 47              	   680: 		LD		B,A				; Length of tokenised line
01:8FE5 D1              	   681: 		POP		DE				; Restore line number
01:8FE6 F1              	   682: 		POP		AF				; Restore Carry
01:8FE7 D2A893          	   683: 		JP		NC,EXCUTE		; No line number - Direct mode
01:8FEA D5              	   684: 		PUSH	DE				; Save line number
01:8FEB C5              	   685: 		PUSH	BC				; Save length of tokenised line
01:8FEC AF              	   686: 		XOR		A
01:8FED 32CC10          	   687: 		LD		(LSTBIN),A		; Clear last byte input
01:8FF0 CDC893          	   688: 		CALL	GETCHR			; Get next character
01:8FF3 B7              	   689: 		OR		A				; Set flags
01:8FF4 F5              	   690: 		PUSH	AF				; And save them
01:8FF5 CD5C90          	   691: 		CALL	SRCHLN			; Search for line number in DE
01:8FF8 DA0190          	   692: 		JP		C,LINFND		; Jump if line found
01:8FFB F1              	   693: 		POP		AF				; Get status
01:8FFC F5              	   694: 		PUSH	AF				; And re-save
01:8FFD CA3895          	   695: 		JP		Z,ULERR			; Nothing after number - Error
01:9000 B7              	   696: 		OR		A				; Clear Carry
01:9001 C5              	   697: LINFND: PUSH	BC				; Save address of line in prog
01:9002 D21890          	   698: 		JP		NC,INEWLN		; Line not found - Insert new
01:9005 EB              	   699: 		EX		DE,HL			; Next line address in DE
01:9006 2AD610          	   700: 		LD		HL,(PROGND)		; End of program
01:9009 1A              	   701: SFTPRG: LD		A,(DE)			; Shift rest of program down
01:900A 02              	   702: 		LD		(BC),A
01:900B 03              	   703: 		INC		BC				; Next destination
01:900C 13              	   704: 		INC		DE				; Next source
01:900D CD3892          	   705: 		CALL	CPDEHL			; All done?
01:9010 C20990          	   706: 		JP		NZ,SFTPRG		; More to do
01:9013 60              	   707: 		LD		H,B				; HL - New end of program
01:9014 69              	   708: 		LD		L,C
01:9015 22D610          	   709: 		LD		(PROGND),HL		; Update end of program
                        	   710: 
01:9018 D1              	   711: INEWLN: POP		DE				; Get address of line,
01:9019 F1              	   712: 		POP		AF				; Get status
01:901A CA3F90          	   713: 		JP		Z,SETPTR		; No text - Set up pointers
01:901D 2AD610          	   714: 		LD		HL,(PROGND)		; Get end of program
01:9020 E3              	   715: 		EX		(SP),HL			; Get length of input line
01:9021 C1              	   716: 		POP		BC				; End of program to BC
01:9022 09              	   717: 		ADD		HL,BC			; Find new end
01:9023 E5              	   718: 		PUSH	HL				; Save new end
01:9024 CD3C8F          	   719: 		CALL	MOVUP			; Make space for line
01:9027 E1              	   720: 		POP		HL				; Restore new end
01:9028 22D610          	   721: 		LD		(PROGND),HL		; Update end of program pointer
01:902B EB              	   722: 		EX		DE,HL			; Get line to move up in HL
01:902C 74              	   723: 		LD		(HL),H			; Save MSB
01:902D D1              	   724: 		POP		DE				; Get new line number
01:902E 23              	   725: 		INC		HL				; Skip pointer
01:902F 23              	   726: 		INC		HL
01:9030 73              	   727: 		LD		(HL),E			; Save LSB of line number
01:9031 23              	   728: 		INC		HL
01:9032 72              	   729: 		LD		(HL),D			; Save MSB of line number
01:9033 23              	   730: 		INC		HL				; To first byte in line
01:9034 116110          	   731: 		LD		DE,BUFFER		; Copy buffer to program
01:9037 1A              	   732: MOVBUF: LD		A,(DE)			; Get source
01:9038 77              	   733: 		LD		(HL),A			; Save destinations
01:9039 23              	   734: 		INC		HL				; Next source
01:903A 13              	   735: 		INC		DE				; Next destination
01:903B B7              	   736: 		OR		A				; Done?
01:903C C23790          	   737: 		JP		NZ,MOVBUF		; No - Repeat
01:903F CD8890          	   738: SETPTR: CALL	RUNFST			; Set line pointers
01:9042 23              	   739: 		INC		HL				; To LSB of pointer
01:9043 EB              	   740: 		EX		DE,HL			; Address to DE
01:9044 62              	   741: PTRLP:	LD		H,D				; Address to HL
01:9045 6B              	   742: 		LD		L,E
01:9046 7E              	   743: 		LD		A,(HL)			; Get LSB of pointer
01:9047 23              	   744: 		INC		HL				; To MSB of pointer
01:9048 B6              	   745: 		OR		(HL)			; Compare with MSB pointer
01:9049 CAC88F          	   746: 		JP		Z,GETCMD		; Get command line if end
01:904C 23              	   747: 		INC		HL				; To LSB of line number
01:904D 23              	   748: 		INC		HL				; Skip line number
01:904E 23              	   749: 		INC		HL				; Point to first byte in line
01:904F AF              	   750: 		XOR		A				; Looking for 00 byte
01:9050 BE              	   751: FNDEND: CP		(HL)			; Found end of line?
01:9051 23              	   752: 		INC		HL				; Move to next byte
01:9052 C25090          	   753: 		JP		NZ,FNDEND		; No - Keep looking
01:9055 EB              	   754: 		EX		DE,HL			; Next line address to HL
01:9056 73              	   755: 		LD		(HL),E			; Save LSB of pointer
01:9057 23              	   756: 		INC		HL
01:9058 72              	   757: 		LD		(HL),D			; Save MSB of pointer
01:9059 C34490          	   758: 		JP		PTRLP			; Do next line
                        	   759: 
01:905C 2A5E10          	   760: SRCHLN: LD		HL,(BASTXT)		; Start of program text
01:905F 44              	   761: SRCHLP: LD		B,H				; BC = Address to look at
01:9060 4D              	   762: 		LD		C,L
01:9061 7E              	   763: 		LD		A,(HL)			; Get address of next line
01:9062 23              	   764: 		INC		HL
01:9063 B6              	   765: 		OR		(HL)			; End of program found?
01:9064 2B              	   766: 		DEC		HL
01:9065 C8              	   767: 		RET		Z				; Yes - Line not found
01:9066 23              	   768: 		INC		HL
01:9067 23              	   769: 		INC		HL
01:9068 7E              	   770: 		LD		A,(HL)			; Get LSB of line number
01:9069 23              	   771: 		INC		HL
01:906A 66              	   772: 		LD		H,(HL)			; Get MSB of line number
01:906B 6F              	   773: 		LD		L,A
01:906C CD3892          	   774: 		CALL	CPDEHL			; Compare with line in DE
01:906F 60              	   775: 		LD		H,B				; HL = Start of this line
01:9070 69              	   776: 		LD		L,C
01:9071 7E              	   777: 		LD		A,(HL)			; Get LSB of next line address
01:9072 23              	   778: 		INC		HL
01:9073 66              	   779: 		LD		H,(HL)			; Get MSB of next line address
01:9074 6F              	   780: 		LD		L,A				; Next line to HL
01:9075 3F              	   781: 		CCF
01:9076 C8              	   782: 		RET		Z				; Lines found - Exit
01:9077 3F              	   783: 		CCF
01:9078 D0              	   784: 		RET		NC				; Line not found,at line after
01:9079 C35F90          	   785: 		JP		SRCHLP			; Keep looking
                        	   786: 
01:907C C0              	   787: NEW:	RET		NZ				; Return if any more on line
01:907D 2A5E10          	   788: CLRPTR: LD		HL,(BASTXT)		; Point to start of program
01:9080 AF              	   789: 		XOR		A				; Set program area to empty
01:9081 77              	   790: 		LD		(HL),A			; Save LSB = 00
01:9082 23              	   791: 		INC		HL
01:9083 77              	   792: 		LD		(HL),A			; Save MSB = 00
01:9084 23              	   793: 		INC		HL
01:9085 22D610          	   794: 		LD		(PROGND),HL		; Set program end
                        	   795: 
01:9088 2A5E10          	   796: RUNFST: LD		HL,(BASTXT)		; Clear all variables
01:908B 2B              	   797: 		DEC		HL
                        	   798: 
01:908C 22CE10          	   799: INTVAR: LD		(BRKLIN),HL		; Initialise RUN variables
01:908F 2AAF10          	   800: 		LD		HL,(LSTRAM)		; Get end of RAM
01:9092 22C310          	   801: 		LD		(STRBOT),HL		; Clear string space
01:9095 AF              	   802: 		XOR		A
01:9096 CDD893          	   803: 		CALL	RESTOR			; Reset DATA pointers
01:9099 2AD610          	   804: 		LD		HL,(PROGND)		; Get end of program
01:909C 22D810          	   805: 		LD		(VAREND),HL		; Clear variables
01:909F 22DA10          	   806: 		LD		(ARREND),HL		; Clear arrays
                        	   807: 
01:90A2 C1              	   808: CLREG:	POP		BC				; Save return address
01:90A3 2A5A10          	   809: 		LD		HL,(STRSPC)		; Get end of working RAN
01:90A6 F9              	   810: 		LD		SP,HL			; Set stack
01:90A7 21B310          	   811: 		LD		HL,TMSTPL		; Temporary string pool
01:90AA 22B110          	   812: 		LD		(TMSTPT),HL		; Reset temporary string ptr
01:90AD AF              	   813: 		XOR		A				; A = 00
01:90AE 6F              	   814: 		LD		L,A				; HL = 0000
01:90AF 67              	   815: 		LD		H,A
01:90B0 22D410          	   816: 		LD		(CONTAD),HL		; No CONTinue
01:90B3 32CB10          	   817: 		LD		(FORFLG),A		; Clear FOR flag
01:90B6 22DE10          	   818: 		LD		(FNRGNM),HL		; Clear FN argument
01:90B9 E5              	   819: 		PUSH	HL				; HL = 0000
01:90BA C5              	   820: 		PUSH	BC				; Put back return
01:90BB 2ACE10          	   821: DOAGN:	LD		HL,(BRKLIN)		; Get address of code to RUN
01:90BE C9              	   822: 		RET						; Return to execution driver
                        	   823: 
01:90BF 3E3F            	   824: PROMPT: LD		A,'?'			; '?'
01:90C1 CD4992          	   825: 		CALL	OUTC			; Output character
01:90C4 3E20            	   826: 		LD		A,' '			; Space
01:90C6 CD4992          	   827: 		CALL	OUTC			; Output character
01:90C9 C34E10          	   828: 		JP		RINPUT			; Get input line
                        	   829: 
01:90CC AF              	   830: CRUNCH: XOR		A				; Tokenise line @ HL to BUFFER
01:90CD 32AE10          	   831: 		LD		(DATFLG),A		; Reset literal flag
01:90D0 0E05            	   832: 		LD		C,2+3			; 2 byte number and 3 nulls
01:90D2 116110          	   833: 		LD		DE,BUFFER		; Start of input buffer
01:90D5 7E              	   834: CRNCLP: LD		A,(HL)			; Get byte
01:90D6 FE20            	   835: 		CP		' '				; Is it a space?
01:90D8 CA5491          	   836: 		JP		Z,MOVDIR		; Yes - Copy direct
01:90DB 47              	   837: 		LD		B,A				; Save character
01:90DC FE22            	   838: 		CP		'"'				; Is it a quote?"
01:90DE CA7491          	   839: 		JP		Z,CPYLIT		; Yes - Copy literal string
01:90E1 B7              	   840: 		OR		A				; Is it end of buffer?
01:90E2 CA7B91          	   841: 		JP		Z,ENDBUF		; Yes - End buffer
01:90E5 3AAE10          	   842: 		LD		A,(DATFLG)		; Get data type
01:90E8 B7              	   843: 		OR		A				; Literal?
01:90E9 7E              	   844: 		LD		A,(HL)			; Get byte to copy
01:90EA C25491          	   845: 		JP		NZ,MOVDIR		; Literal - Copy direct
01:90ED FE3F            	   846: 		CP		'?'				; Is it '?' short for PRINT
01:90EF 3E9E            	   847: 		LD		A,ZPRINT		; "PRINT" token
01:90F1 CA5491          	   848: 		JP		Z,MOVDIR		; Yes - replace it
01:90F4 7E              	   849: 		LD		A,(HL)			; Get byte again
01:90F5 FE30            	   850: 		CP		'0'				; Is it less than '0'
01:90F7 DAFF90          	   851: 		JP		C,FNDWRD		; Yes - Look for reserved words
01:90FA FE3C            	   852: 		CP		60; ";"+1			; Is it "0123456789:;" ?
01:90FC DA5491          	   853: 		JP		C,MOVDIR		; Yes - copy it direct
01:90FF D5              	   854: FNDWRD: PUSH	DE				; Look for reserved words
01:9100 11F88C          	   855: 		LD		DE,WORDS-1		; Point to table
01:9103 C5              	   856: 		PUSH	BC				; Save count
01:9104 015091          	   857: 		LD		BC,RETNAD		; Where to return to
01:9107 C5              	   858: 		PUSH	BC				; Save return address
01:9108 067F            	   859: 		LD		B,ZEND-1		; First token value -1
01:910A 7E              	   860: 		LD		A,(HL)			; Get byte
01:910B FE61            	   861: 		CP		'a'				; Less than 'a' ?
01:910D DA1891          	   862: 		JP		C,SEARCH		; Yes - search for words
01:9110 FE7B            	   863: 		CP		'z'+1			; Greater than 'z' ?
01:9112 D21891          	   864: 		JP		NC,SEARCH		; Yes - search for words
01:9115 E65F            	   865: 		AND		01011111B		; Force upper case
01:9117 77              	   866: 		LD		(HL),A			; Replace byte
01:9118 4E              	   867: SEARCH: LD		C,(HL)			; Search for a word
01:9119 EB              	   868: 		EX		DE,HL
01:911A 23              	   869: GETNXT: INC		HL				; Get next reserved word
01:911B B6              	   870: 		OR		(HL)			; Start of word?
01:911C F21A91          	   871: 		JP		P,GETNXT		; No - move on
01:911F 04              	   872: 		INC		B				; Increment token value
01:9120 7E              	   873: 		LD		A, (HL)			; Get byte from table
01:9121 E67F            	   874: 		AND		01111111B		; Strip bit 7
01:9123 C8              	   875: 		RET		Z				; Return if end of list
01:9124 B9              	   876: 		CP		C				; Same character as in buffer?
01:9125 C21A91          	   877: 		JP		NZ,GETNXT		; No - get next word
01:9128 EB              	   878: 		EX		DE,HL
01:9129 E5              	   879: 		PUSH	HL				; Save start of word
                        	   880: 
01:912A 13              	   881: NXTBYT: INC		DE				; Look through rest of word
01:912B 1A              	   882: 		LD		A,(DE)			; Get byte from table
01:912C B7              	   883: 		OR		A				; End of word ?
01:912D FA4C91          	   884: 		JP		M,MATCH			; Yes - Match found
01:9130 4F              	   885: 		LD		C,A				; Save it
01:9131 78              	   886: 		LD		A,B				; Get token value
01:9132 FE88            	   887: 		CP		ZGOTO			; Is it "GOTO" token ?
01:9134 C23B91          	   888: 		JP		NZ,NOSPC		; No - Don't allow spaces
01:9137 CDC893          	   889: 		CALL	GETCHR			; Get next character
01:913A 2B              	   890: 		DEC		HL				; Cancel increment from GETCHR
01:913B 23              	   891: NOSPC:	INC		HL				; Next byte
01:913C 7E              	   892: 		LD		A,(HL)			; Get byte
01:913D FE61            	   893: 		CP		'a'				; Less than 'a' ?
01:913F DA4491          	   894: 		JP		C,NOCHNG		; Yes - don't change
01:9142 E65F            	   895: 		AND		01011111B		; Make upper case
01:9144 B9              	   896: NOCHNG: CP		C				; Same as in buffer ?
01:9145 CA2A91          	   897: 		JP		Z,NXTBYT		; Yes - keep testing
01:9148 E1              	   898: 		POP		HL				; Get back start of word
01:9149 C31891          	   899: 		JP		SEARCH			; Look at next word
                        	   900: 
01:914C 48              	   901: MATCH:	LD		C,B				; Word found - Save token value
01:914D F1              	   902: 		POP		AF				; Throw away return
01:914E EB              	   903: 		EX		DE,HL
01:914F C9              	   904: 		RET						; Return to "RETNAD"
01:9150 EB              	   905: RETNAD: EX		DE,HL			; Get address in string
01:9151 79              	   906: 		LD		A,C				; Get token value
01:9152 C1              	   907: 		POP		BC				; Restore buffer length
01:9153 D1              	   908: 		POP		DE				; Get destination address
01:9154 23              	   909: MOVDIR: INC		HL				; Next source in buffer
01:9155 12              	   910: 		LD		(DE),A			; Put byte in buffer
01:9156 13              	   911: 		INC		DE				; Move up buffer
01:9157 0C              	   912: 		INC		C				; Increment length of buffer
01:9158 D63A            	   913: 		SUB		':'				; End of statement?
01:915A CA6291          	   914: 		JP		Z,SETLIT		; Jump if multi-statement line
01:915D FE49            	   915: 		CP		ZDATA-3AH		; Is it DATA statement ?
01:915F C26591          	   916: 		JP		NZ,TSTREM		; No - see if REM
01:9162 32AE10          	   917: SETLIT: LD		(DATFLG),A		; Set literal flag
01:9165 D654            	   918: TSTREM: SUB		ZREM-3AH		; Is it REM?
01:9167 C2D590          	   919: 		JP		NZ,CRNCLP		; No - Leave flag
01:916A 47              	   920: 		LD		B,A				; Copy rest of buffer
01:916B 7E              	   921: NXTCHR: LD		A,(HL)			; Get byte
01:916C B7              	   922: 		OR		A				; End of line ?
01:916D CA7B91          	   923: 		JP		Z,ENDBUF		; Yes - Terminate buffer
01:9170 B8              	   924: 		CP		B				; End of statement ?
01:9171 CA5491          	   925: 		JP		Z,MOVDIR		; Yes - Get next one
01:9174 23              	   926: CPYLIT: INC		HL				; Move up source string
01:9175 12              	   927: 		LD		(DE),A			; Save in destination
01:9176 0C              	   928: 		INC		C				; Increment length
01:9177 13              	   929: 		INC		DE				; Move up destination
01:9178 C36B91          	   930: 		JP		NXTCHR			; Repeat
                        	   931: 
01:917B 216010          	   932: ENDBUF: LD		HL,BUFFER-1		; Point to start of buffer
01:917E 12              	   933: 		LD		(DE),A			; Mark end of buffer (A = 00)
01:917F 13              	   934: 		INC		DE
01:9180 12              	   935: 		LD		(DE),A			; A = 00
01:9181 13              	   936: 		INC		DE
01:9182 12              	   937: 		LD		(DE),A			; A = 00
01:9183 C9              	   938: 		RET
                        	   939: 
01:9184 3A4410          	   940: DODEL:	LD		A,(NULFLG)		; Get null flag status
01:9187 B7              	   941: 		OR		A				; Is it zero?
01:9188 3E00            	   942: 		LD		A,0				; Zero A - Leave flags
01:918A 324410          	   943: 		LD		(NULFLG),A		; Zero null flag
01:918D C29891          	   944: 		JP		NZ,ECHDEL		; Set - Echo it
01:9190 05              	   945: 		DEC		B				; Decrement length
01:9191 CAB591          	   946: 		JP		Z,GETLIN		; Get line again if empty
01:9194 CD4992          	   947: 		CALL	OUTC			; Output null character
01:9197 3E              	   948: 		db	3EH				; Skip "DEC B"
01:9198 05              	   949: ECHDEL: DEC		B				; Count bytes in buffer
01:9199 2B              	   950: 		DEC		HL				; Back space buffer
01:919A CAAC91          	   951: 		JP		Z,OTKLN			; No buffer - Try again
01:919D 7E              	   952: 		LD		A,(HL)			; Get deleted byte
01:919E CD4992          	   953: 		CALL	OUTC			; Echo it
01:91A1 C3BE91          	   954: 		JP		MORINP			; Get more input
                        	   955: 
01:91A4 05              	   956: DELCHR: DEC		B				; Count bytes in buffer
01:91A5 2B              	   957: 		DEC		HL				; Back space buffer
01:91A6 CD4992          	   958: 		CALL	OUTC			; Output character in A
01:91A9 C2BE91          	   959: 		JP		NZ,MORINP		; Not end - Get more
01:91AC CD4992          	   960: OTKLN:	CALL	OUTC			; Output character in A
01:91AF CD7396          	   961: KILIN:	CALL	PRNTCRLF		; Output CRLF
01:91B2 C3B591          	   962: 		JP		TTYLIN			; Get line again
                        	   963: 
                        	   964: GETLIN:
01:91B5 216110          	   965: TTYLIN: LD		HL,BUFFER		; Get a line by character
01:91B8 0601            	   966: 		LD		B,1				; Set buffer as empty
01:91BA AF              	   967: 		XOR		A
01:91BB 324410          	   968: 		LD		(NULFLG),A		; Clear null flag
01:91BE CD7392          	   969: MORINP: CALL	CLOTST			; Get character and test ^O
01:91C1 4F              	   970: 		LD		C,A				; Save character in C
01:91C2 FE7F            	   971: 		CP		DEL				; Delete character?
01:91C4 CA8491          	   972: 		JP		Z,DODEL			; Yes - Process it
01:91C7 3A4410          	   973: 		LD		A,(NULFLG)		; Get null flag
01:91CA B7              	   974: 		OR		A				; Test null flag status
01:91CB CAD791          	   975: 		JP		Z,PROCES		; Reset - Process character
01:91CE 3E00            	   976: 		LD		A,0				; Set a null
01:91D0 CD4992          	   977: 		CALL	OUTC			; Output null
01:91D3 AF              	   978: 		XOR		A				; Clear A
01:91D4 324410          	   979: 		LD		(NULFLG),A		; Reset null flag
01:91D7 79              	   980: PROCES: LD		A,C				; Get character
01:91D8 FE07            	   981: 		CP		CTRLG			; Bell?
01:91DA CA1B92          	   982: 		JP		Z,PUTCTL		; Yes - Save it
01:91DD FE03            	   983: 		CP		CTRLC			; Is it control "C"?
01:91DF CC7396          	   984: 		CALL	Z,PRNTCRLF		; Yes - Output CRLF
01:91E2 37              	   985: 		SCF						; Flag break
01:91E3 C8              	   986: 		RET		Z				; Return if control "C"
01:91E4 FE0D            	   987: 		CP		CR				; Is it enter?
01:91E6 CA6E96          	   988: 		JP		Z,ENDINP		; Yes - Terminate input
01:91E9 FE15            	   989: 		CP		CTRLU			; Is it control "U"?
01:91EB CAAF91          	   990: 		JP		Z,KILIN			; Yes - Get another line
01:91EE FE40            	   991: 		CP		'@'				; Is it "kill line"?
01:91F0 CAAC91          	   992: 		JP		Z,OTKLN			; Yes - Kill line
01:91F3 FE5F            	   993: 		CP		'_'				; Is it delete?
01:91F5 CAA491          	   994: 		JP		Z,DELCHR		; Yes - Delete character
01:91F8 FE08            	   995: 		CP		BKSP			; Is it backspace?
01:91FA CAA491          	   996: 		JP		Z,DELCHR		; Yes - Delete character
01:91FD FE12            	   997: 		CP		CTRLR			; Is it control "R"?
01:91FF C21692          	   998: 		JP		NZ,PUTBUF		; No - Put in buffer
01:9202 C5              	   999: 		PUSH	BC				; Save buffer length
01:9203 D5              	  1000: 		PUSH	DE				; Save DE
01:9204 E5              	  1001: 		PUSH	HL				; Save buffer address
01:9205 3600            	  1002: 		LD		(HL),0			; Mark end of buffer
01:9207 CD23A8          	  1003: 		CALL	OUTNCR			; Output and do CRLF
01:920A 216110          	  1004: 		LD		HL,BUFFER		; Point to buffer start
01:920D CD119D          	  1005: 		CALL	PRS				; Output buffer
01:9210 E1              	  1006: 		POP		HL				; Restore buffer address
01:9211 D1              	  1007: 		POP		DE				; Restore DE
01:9212 C1              	  1008: 		POP		BC				; Restore buffer length
01:9213 C3BE91          	  1009: 		JP		MORINP			; Get another character
                        	  1010: 
01:9216 FE20            	  1011: PUTBUF: CP		' '				; Is it a control code?
01:9218 DABE91          	  1012: 		JP		C,MORINP		; Yes - Ignore
01:921B 78              	  1013: PUTCTL: LD		A,B				; Get number of bytes in buffer
01:921C FE49            	  1014: 		CP		72+1			; Test for line overflow
01:921E 3E07            	  1015: 		LD		A,CTRLG			; Set a bell
01:9220 D23092          	  1016: 		JP		NC,OUTNBS		; Ring bell if buffer full
01:9223 79              	  1017: 		LD		A,C				; Get character
01:9224 71              	  1018: 		LD		(HL),C			; Save in buffer
01:9225 32CC10          	  1019: 		LD		(LSTBIN),A		; Save last input byte
01:9228 23              	  1020: 		INC		HL				; Move up buffer
01:9229 04              	  1021: 		INC		B				; Increment length
01:922A CD4992          	  1022: OUTIT:	CALL	OUTC			; Output the character entered
01:922D C3BE91          	  1023: 		JP		MORINP			; Get another character
                        	  1024: 
01:9230 CD4992          	  1025: OUTNBS: CALL	OUTC			; Output bell and back over it
01:9233 3E08            	  1026: 		LD		A,BKSP			; Set back space
01:9235 C32A92          	  1027: 		JP		OUTIT			; Output it and get more
                        	  1028: 
01:9238 7C              	  1029: CPDEHL: LD		A,H				; Get H
01:9239 92              	  1030: 		SUB		D				; Compare with D
01:923A C0              	  1031: 		RET		NZ				; Different - Exit
01:923B 7D              	  1032: 		LD		A,L				; Get L
01:923C 93              	  1033: 		SUB		E				; Compare with E
01:923D C9              	  1034: 		RET						; Return status
                        	  1035: 
01:923E 7E              	  1036: CHKSYN: LD		A,(HL)			; Check syntax of character
01:923F E3              	  1037: 		EX		(SP),HL			; Address of test byte
01:9240 BE              	  1038: 		CP		(HL)			; Same as in code string?
01:9241 23              	  1039: 		INC		HL				; Return address
01:9242 E3              	  1040: 		EX		(SP),HL			; Put it back
01:9243 CAC893          	  1041: 		JP		Z,GETCHR		; Yes - Get next character
01:9246 C3708F          	  1042: 		JP		SNERR			; Different - ?SN Error
                        	  1043: 
01:9249 F5              	  1044: OUTC:	PUSH	AF				; Save character
01:924A 3A4510          	  1045: 		LD		A,(CTLOFG)		; Get control "O" flag
01:924D B7              	  1046: 		OR		A				; Is it set?
01:924E C2469D          	  1047: 		JP		NZ,POPAF		; Yes - don't output
01:9251 F1              	  1048: 		POP		AF				; Restore character
01:9252 C5              	  1049: 		PUSH	BC				; Save buffer length
01:9253 F5              	  1050: 		PUSH	AF				; Save character
01:9254 FE20            	  1051: 		CP		' '				; Is it a control code?
01:9256 DA6D92          	  1052: 		JP		C,DINPOS		; Yes - Don't INC POS(X)
01:9259 3A4210          	  1053: 		LD		A,(LWIDTH)		; Get line width
01:925C 47              	  1054: 		LD		B,A				; To B
01:925D 3AAB10          	  1055: 		LD		A,(CURPOS)		; Get cursor position
01:9260 04              	  1056: 		INC		B				; Width 255?
01:9261 CA6992          	  1057: 		JP		Z,INCLEN		; Yes - No width limit
01:9264 05              	  1058: 		DEC		B				; Restore width
01:9265 B8              	  1059: 		CP		B				; At end of line?
01:9266 CC7396          	  1060: 		CALL	Z,PRNTCRLF		; Yes - output CRLF
01:9269 3C              	  1061: INCLEN: INC		A				; Move on one character
01:926A 32AB10          	  1062: 		LD		(CURPOS),A		; Save new position
01:926D F1              	  1063: DINPOS: POP		AF				; Restore character
01:926E C1              	  1064: 		POP		BC				; Restore buffer length
01:926F CD0CA8          	  1065: 		CALL	MONOUT			; Send it
01:9272 C9              	  1066: 		RET
                        	  1067: 
01:9273 CDD0A6          	  1068: CLOTST: CALL	GETINP			; Get input character
01:9276 E67F            	  1069: 		AND		01111111B		; Strip bit 7
01:9278 FE0F            	  1070: 		CP		CTRLO			; Is it control "O"?
01:927A C0              	  1071: 		RET		NZ				; No don't flip flag
01:927B 3A4510          	  1072: 		LD		A,(CTLOFG)		; Get flag
01:927E 2F              	  1073: 		CPL						; Flip it
01:927F 324510          	  1074: 		LD		(CTLOFG),A		; Put it back
01:9282 AF              	  1075: 		XOR		A				; Null character
01:9283 C9              	  1076: 		RET
                        	  1077: 
01:9284 CD9794          	  1078: LISTT:	CALL	ATOH			; ASCII number to DE
01:9287 C0              	  1079: 		RET		NZ				; Return if anything extra
01:9288 C1              	  1080: 		POP		BC				; Rubbish - Not needed
01:9289 CD5C90          	  1081: 		CALL	SRCHLN			; Search for line number in DE
01:928C C5              	  1082: 		PUSH	BC				; Save address of line
01:928D CDDA92          	  1083: 		CALL	SETLIN			; Set up lines counter
01:9290 E1              	  1084: LISTLP: POP		HL				; Restore address of line
01:9291 4E              	  1085: 		LD		C,(HL)			; Get LSB of next line
01:9292 23              	  1086: 		INC		HL
01:9293 46              	  1087: 		LD		B,(HL)			; Get MSB of next line
01:9294 23              	  1088: 		INC		HL
01:9295 78              	  1089: 		LD		A,B				; BC = 0 (End of program)?
01:9296 B1              	  1090: 		OR		C
01:9297 CABB8F          	  1091: 		JP		Z,PRNTOK		; Yes - Go to command mode
01:929A CDE392          	  1092: 		CALL	COUNT			; Count lines
01:929D CDF393          	  1093: 		CALL	TSTBRK			; Test for break key
01:92A0 C5              	  1094: 		PUSH	BC				; Save address of next line
01:92A1 CD7396          	  1095: 		CALL	PRNTCRLF		; Output CRLF
01:92A4 5E              	  1096: 		LD		E,(HL)			; Get LSB of line number
01:92A5 23              	  1097: 		INC		HL
01:92A6 56              	  1098: 		LD		D,(HL)			; Get MSB of line number
01:92A7 23              	  1099: 		INC		HL
01:92A8 E5              	  1100: 		PUSH	HL				; Save address of line start
01:92A9 EB              	  1101: 		EX		DE,HL			; Line number to HL
01:92AA CDB4A3          	  1102: 		CALL	PRNTHL			; Output line number in decimal
01:92AD 3E20            	  1103: 		LD		A,' '			; Space after line number
01:92AF E1              	  1104: 		POP		HL				; Restore start of line address
01:92B0 CD4992          	  1105: LSTLP2: CALL	OUTC			; Output character in A
01:92B3 7E              	  1106: LSTLP3: LD		A,(HL)			; Get next byte in line
01:92B4 B7              	  1107: 		OR		A				; End of line?
01:92B5 23              	  1108: 		INC		HL				; To next byte in line
01:92B6 CA9092          	  1109: 		JP		Z,LISTLP		; Yes - get next line
01:92B9 F2B092          	  1110: 		JP		P,LSTLP2		; No token - output it
01:92BC D67F            	  1111: 		SUB		ZEND-1			; Find and output word
01:92BE 4F              	  1112: 		LD		C,A				; Token offset+1 to C
01:92BF 11F98C          	  1113: 		LD		DE,WORDS		; Reserved word list
01:92C2 1A              	  1114: FNDTOK: LD		A,(DE)			; Get character in list
01:92C3 13              	  1115: 		INC		DE				; Move on to next
01:92C4 B7              	  1116: 		OR		A				; Is it start of word?
01:92C5 F2C292          	  1117: 		JP		P,FNDTOK		; No - Keep looking for word
01:92C8 0D              	  1118: 		DEC		C				; Count words
01:92C9 C2C292          	  1119: 		JP		NZ,FNDTOK		; Not there - keep looking
01:92CC E67F            	  1120: OUTWRD: AND		01111111B		; Strip bit 7
01:92CE CD4992          	  1121: 		CALL	OUTC			; Output first character
01:92D1 1A              	  1122: 		LD		A,(DE)			; Get next character
01:92D2 13              	  1123: 		INC		DE				; Move on to next
01:92D3 B7              	  1124: 		OR		A				; Is it end of word?
01:92D4 F2CC92          	  1125: 		JP		P,OUTWRD		; No - output the rest
01:92D7 C3B392          	  1126: 		JP		LSTLP3			; Next byte in line
                        	  1127: 
01:92DA E5              	  1128: SETLIN: PUSH	HL				; Set up LINES counter
01:92DB 2A4810          	  1129: 		LD		HL,(LINESN)		; Get LINES number
01:92DE 224610          	  1130: 		LD		(LINESC),HL		; Save in LINES counter
01:92E1 E1              	  1131: 		POP		HL
01:92E2 C9              	  1132: 		RET
                        	  1133: 
01:92E3 E5              	  1134: COUNT:	PUSH	HL				; Save code string address
01:92E4 D5              	  1135: 		PUSH	DE
01:92E5 2A4610          	  1136: 		LD		HL,(LINESC)		; Get LINES counter
01:92E8 11FFFF          	  1137: 		LD		DE,-1
01:92EB ED5A            	  1138: 		ADC		HL,DE			; Decrement
01:92ED 224610          	  1139: 		LD		(LINESC),HL		; Put it back
01:92F0 D1              	  1140: 		POP		DE
01:92F1 E1              	  1141: 		POP		HL				; Restore code string address
01:92F2 F0              	  1142: 		RET		P				; Return if more lines to go
01:92F3 E5              	  1143: 		PUSH	HL				; Save code string address
01:92F4 2A4810          	  1144: 		LD		HL,(LINESN)		; Get LINES number
01:92F7 224610          	  1145: 		LD		(LINESC),HL		; Reset LINES counter
01:92FA CDD0A6          	  1146: 		CALL	GETINP			; Get input character
01:92FD FE03            	  1147: 		CP		CTRLC			; Is it control "C"?
01:92FF CA0693          	  1148: 		JP		Z,RSLNBK		; Yes - Reset LINES and break
01:9302 E1              	  1149: 		POP		HL				; Restore code string address
01:9303 C3E392          	  1150: 		JP		COUNT			; Keep on counting
                        	  1151: 
01:9306 2A4810          	  1152: RSLNBK: LD		HL,(LINESN)		; Get LINES number
01:9309 224610          	  1153: 		LD		(LINESC),HL		; Reset LINES counter
01:930C C36B8C          	  1154: 		JP		BRKRET			; Go and output "Break"
                        	  1155: 
01:930F 3E64            	  1156: FOR:	LD		A,64H			; Flag "FOR" assignment
01:9311 32CB10          	  1157: 		LD		(FORFLG),A		; Save "FOR" flag
01:9314 CD7995          	  1158: 		CALL	LET				; Set up initial index
01:9317 C1              	  1159: 		POP		BC				; Drop RETurn address
01:9318 E5              	  1160: 		PUSH	HL				; Save code string address
01:9319 CD6295          	  1161: 		CALL	DATAA			; Get next statement address
01:931C 22C710          	  1162: 		LD		(LOOPST),HL		; Save it for start of loop
01:931F 210200          	  1163: 		LD		HL,2			; Offset for "FOR" block
01:9322 39              	  1164: 		ADD		HL,SP			; Point to it
01:9323 CD1D8F          	  1165: FORSLP: CALL	LOKFOR			; Look for existing "FOR" block
01:9326 D1              	  1166: 		POP		DE				; Get code string address
01:9327 C23F93          	  1167: 		JP		NZ,FORFND		; No nesting found
01:932A 09              	  1168: 		ADD		HL,BC			; Move into "FOR" block
01:932B D5              	  1169: 		PUSH	DE				; Save code string address
01:932C 2B              	  1170: 		DEC		HL
01:932D 56              	  1171: 		LD		D,(HL)			; Get MSB of loop statement
01:932E 2B              	  1172: 		DEC		HL
01:932F 5E              	  1173: 		LD		E,(HL)			; Get LSB of loop statement
01:9330 23              	  1174: 		INC		HL
01:9331 23              	  1175: 		INC		HL
01:9332 E5              	  1176: 		PUSH	HL				; Save block address
01:9333 2AC710          	  1177: 		LD		HL,(LOOPST)		; Get address of loop statement
01:9336 CD3892          	  1178: 		CALL	CPDEHL			; Compare the FOR loops
01:9339 E1              	  1179: 		POP		HL				; Restore block address
01:933A C22393          	  1180: 		JP		NZ,FORSLP		; Different FORs - Find another
01:933D D1              	  1181: 		POP		DE				; Restore code string address
01:933E F9              	  1182: 		LD		SP,HL			; Remove all nested loops
                        	  1183: 
01:933F EB              	  1184: FORFND: EX		DE,HL			; Code string address to HL
01:9340 0E08            	  1185: 		LD		C,8
01:9342 CD4D8F          	  1186: 		CALL	CHKSTK			; Check for 8 levels of stack
01:9345 E5              	  1187: 		PUSH	HL				; Save code string address
01:9346 2AC710          	  1188: 		LD		HL,(LOOPST)		; Get first statement of loop
01:9349 E3              	  1189: 		EX		(SP),HL			; Save and restore code string
01:934A E5              	  1190: 		PUSH	HL				; Re-save code string address
01:934B 2A5C10          	  1191: 		LD		HL,(LINEAT)		; Get current line number
01:934E E3              	  1192: 		EX		(SP),HL			; Save and restore code string
01:934F CD3B98          	  1193: 		CALL	TSTNUM			; Make sure it's a number
01:9352 CD3E92          	  1194: 		CALL	CHKSYN			; Make sure "TO" is next
01:9355 A6              	  1195: 		db	ZTO			 ; "TO" token
01:9356 CD3898          	  1196: 		CALL	GETNUM			; Get "TO" expression value
01:9359 E5              	  1197: 		PUSH	HL				; Save code string address
01:935A CD66A2          	  1198: 		CALL	BCDEFP			; Move "TO" value to BCDE
01:935D E1              	  1199: 		POP		HL				; Restore code string address
01:935E C5              	  1200: 		PUSH	BC				; Save "TO" value in block
01:935F D5              	  1201: 		PUSH	DE
01:9360 010081          	  1202: 		LD		BC,8100H		; BCDE - 1 (default STEP)
01:9363 51              	  1203: 		LD		D,C				; C=0
01:9364 5A              	  1204: 		LD		E,D				; D=0
01:9365 7E              	  1205: 		LD		A,(HL)			; Get next byte in code string
01:9366 FEAB            	  1206: 		CP		ZSTEP			; See if "STEP" is stated
01:9368 3E01            	  1207: 		LD		A,1				; Sign of step = 1
01:936A C27B93          	  1208: 		JP		NZ,SAVSTP		; No STEP given - Default to 1
01:936D CDC893          	  1209: 		CALL	GETCHR			; Jump over "STEP" token
01:9370 CD3898          	  1210: 		CALL	GETNUM			; Get step value
01:9373 E5              	  1211: 		PUSH	HL				; Save code string address
01:9374 CD66A2          	  1212: 		CALL	BCDEFP			; Move STEP to BCDE
01:9377 CD1AA2          	  1213: 		CALL	TSTSGN			; Test sign of FPREG
01:937A E1              	  1214: 		POP		HL				; Restore code string address
01:937B C5              	  1215: SAVSTP: PUSH	BC				; Save the STEP value in block
01:937C D5              	  1216: 		PUSH	DE
01:937D F5              	  1217: 		PUSH	AF				; Save sign of STEP
01:937E 33              	  1218: 		INC		SP				; Don't save flags
01:937F E5              	  1219: 		PUSH	HL				; Save code string address
01:9380 2ACE10          	  1220: 		LD		HL,(BRKLIN)		; Get address of index variable
01:9383 E3              	  1221: 		EX		(SP),HL			; Save and restore code string
01:9384 0681            	  1222: PUTFID: LD		B,ZFOR			; "FOR" block marker
01:9386 C5              	  1223: 		PUSH	BC				; Save it
01:9387 33              	  1224: 		INC		SP				; Don't save C
                        	  1225: 
01:9388 CDF393          	  1226: RUNCNT: CALL	TSTBRK			; Execution driver - Test break
01:938B 22CE10          	  1227: 		LD		(BRKLIN),HL		; Save code address for break
01:938E 7E              	  1228: 		LD		A,(HL)			; Get next byte in code string
01:938F FE3A            	  1229: 		CP		':'				; Multi statement line?
01:9391 CAA893          	  1230: 		JP		Z,EXCUTE		; Yes - Execute it
01:9394 B7              	  1231: 		OR		A				; End of line?
01:9395 C2708F          	  1232: 		JP		NZ,SNERR		; No - Syntax error
01:9398 23              	  1233: 		INC		HL				; Point to address of next line
01:9399 7E              	  1234: 		LD		A,(HL)			; Get LSB of line pointer
01:939A 23              	  1235: 		INC		HL
01:939B B6              	  1236: 		OR		(HL)			; Is it zero (End of prog)?
01:939C CA1D94          	  1237: 		JP		Z,ENDPRG		; Yes - Terminate execution
01:939F 23              	  1238: 		INC		HL				; Point to line number
01:93A0 5E              	  1239: 		LD		E,(HL)			; Get LSB of line number
01:93A1 23              	  1240: 		INC		HL
01:93A2 56              	  1241: 		LD		D,(HL)			; Get MSB of line number
01:93A3 EB              	  1242: 		EX		DE,HL			; Line number to HL
01:93A4 225C10          	  1243: 		LD		(LINEAT),HL		; Save as current line number
01:93A7 EB              	  1244: 		EX		DE,HL			; Line number back to DE
01:93A8 CDC893          	  1245: EXCUTE: CALL	GETCHR			; Get key word
01:93AB 118893          	  1246: 		LD		DE,RUNCNT		; Where to RETurn to
01:93AE D5              	  1247: 		PUSH	DE				; Save for RETurn
01:93AF C8              	  1248: IFJMP:	RET		Z				; Go to RUNCNT if end of STMT
01:93B0 D680            	  1249: ONJMP:	SUB		ZEND			; Is it a token?
01:93B2 DA7995          	  1250: 		JP		C,LET			; No - try to assign it
01:93B5 FE25            	  1251: 		CP		ZNEW+1-ZEND		; END to NEW ?
01:93B7 D2708F          	  1252: 		JP		NC,SNERR		; Not a key word - ?SN Error
01:93BA 07              	  1253: 		RLCA					; Double it
01:93BB 4F              	  1254: 		LD		C,A				; BC = Offset into table
01:93BC 0600            	  1255: 		LD		B,0
01:93BE EB              	  1256: 		EX		DE,HL			; Save code string address
01:93BF 21188E          	  1257: 		LD		HL,WORDTB		; Keyword address table
01:93C2 09              	  1258: 		ADD		HL,BC			; Point to routine address
01:93C3 4E              	  1259: 		LD		C,(HL)			; Get LSB of routine address
01:93C4 23              	  1260: 		INC		HL
01:93C5 46              	  1261: 		LD		B,(HL)			; Get MSB of routine address
01:93C6 C5              	  1262: 		PUSH	BC				; Save routine address
01:93C7 EB              	  1263: 		EX		DE,HL			; Restore code string address
                        	  1264: 
01:93C8 23              	  1265: GETCHR: INC		HL				; Point to next character
01:93C9 7E              	  1266: 		LD		A,(HL)			; Get next code string byte
01:93CA FE3A            	  1267: 		CP		':'				; Z if ':'
01:93CC D0              	  1268: 		RET		NC				; NC if > "9"
01:93CD FE20            	  1269: 		CP		' '
01:93CF CAC893          	  1270: 		JP		Z,GETCHR		; Skip over spaces
01:93D2 FE30            	  1271: 		CP		'0'
01:93D4 3F              	  1272: 		CCF						; NC if < '0'
01:93D5 3C              	  1273: 		INC		A				; Test for zero - Leave carry
01:93D6 3D              	  1274: 		DEC		A				; Z if Null
01:93D7 C9              	  1275: 		RET
                        	  1276: 
01:93D8 EB              	  1277: RESTOR: EX		DE,HL			; Save code string address
01:93D9 2A5E10          	  1278: 		LD		HL,(BASTXT)		; Point to start of program
01:93DC CAED93          	  1279: 		JP		Z,RESTNL		; Just RESTORE - reset pointer
01:93DF EB              	  1280: 		EX		DE,HL			; Restore code string address
01:93E0 CD9794          	  1281: 		CALL	ATOH			; Get line number to DE
01:93E3 E5              	  1282: 		PUSH	HL				; Save code string address
01:93E4 CD5C90          	  1283: 		CALL	SRCHLN			; Search for line number in DE
01:93E7 60              	  1284: 		LD		H,B				; HL = Address of line
01:93E8 69              	  1285: 		LD		L,C
01:93E9 D1              	  1286: 		POP		DE				; Restore code string address
01:93EA D23895          	  1287: 		JP		NC,ULERR		; ?UL Error if not found
01:93ED 2B              	  1288: RESTNL: DEC		HL				; Byte before DATA statement
01:93EE 22DC10          	  1289: UPDATA: LD		(NXTDAT),HL		; Update DATA pointer
01:93F1 EB              	  1290: 		EX		DE,HL			; Restore code string address
01:93F2 C9              	  1291: 		RET
                        	  1292: 
                        	  1293: 
                        	  1294: TSTBRK: 
01:93F3 CDD080          	  1295: 	call	ReadCharNoWait			; Check for presence of character
01:93F6 C8              	  1296: 	ret		z						; Return if nothing is in SIO buffer
                        	  1297: 	
                        	  1298: ;		call	CKINCHAR				; Check input status
                        	  1299: ;		RET		Z				; No key, go back
                        	  1300: ;		call	RXA				; Get the key into A
01:93F7 FE1B            	  1301: 		CP		ESC				; Escape key?
01:93F9 2813            	  1302: 		JR		Z,BRK			; Yes, break
01:93FB FE03            	  1303: 		CP		CTRLC			; <Ctrl-C>
01:93FD 280F            	  1304: 		JR		Z,BRK			; Yes, break
01:93FF FE13            	  1305: 		CP		CTRLS			; Stop scrolling?
01:9401 C0              	  1306: 		RET		NZ				; Other key, ignore
                        	  1307: 
                        	  1308: 
01:9402 CDC780          	  1309: STALL:	call	ReadChar				; Wait for key
01:9405 FE11            	  1310: 		CP		CTRLQ			; Resume scrolling?
01:9407 C8              	  1311: 		RET		 Z				; Release the chokehold
01:9408 FE03            	  1312: 		CP		CTRLC			; Second break?
01:940A 2807            	  1313: 		JR		Z,STOPP			; Break during hold exits prog
01:940C 18F4            	  1314: 		JR		STALL			; Loop until <Ctrl-Q> or <brk>
                        	  1315: 
01:940E 3EFF            	  1316: BRK		LD		A,$FF			; Set BRKFLG
01:9410 324D10          	  1317: 		LD		(BRKFLG),A		; Store it
                        	  1318: 
                        	  1319: 
01:9413 C0              	  1320: STOPP:	RET		NZ				; Exit if anything else
01:9414 F6              	  1321: 		db	0F6H			; Flag "STOP"
01:9415 C0              	  1322: PEND:	RET		NZ				; Exit if anything else
01:9416 22CE10          	  1323: 		LD		(BRKLIN),HL		; Save point of break
01:9419 21              	  1324: 		db	21H				; Skip "OR 11111111B"
01:941A F6FF            	  1325: INPBRK: OR		11111111B		; Flag "Break" wanted
01:941C C1              	  1326: 		POP		BC				; Return not needed and more
01:941D 2A5C10          	  1327: ENDPRG: LD		HL,(LINEAT)		; Get current line number
01:9420 F5              	  1328: 		PUSH	AF				; Save STOP / END status
01:9421 7D              	  1329: 		LD		A,L				; Is it direct break?
01:9422 A4              	  1330: 		AND		H
01:9423 3C              	  1331: 		INC		A				; Line is -1 if direct break
01:9424 CA3094          	  1332: 		JP		Z,NOLIN			; Yes - No line number
01:9427 22D210          	  1333: 		LD		(ERRLIN),HL		; Save line of break
01:942A 2ACE10          	  1334: 		LD		HL,(BRKLIN)		; Get point of break
01:942D 22D410          	  1335: 		LD		(CONTAD),HL		; Save point to CONTinue
01:9430 AF              	  1336: NOLIN:	XOR		A
01:9431 324510          	  1337: 		LD		(CTLOFG),A		; Enable output
01:9434 CD6696          	  1338: 		CALL	STTLIN			; Start a new line
01:9437 F1              	  1339: 		POP		AF				; Restore STOP / END status
01:9438 21138F          	  1340: 		LD		HL,BRKMSG		; "Break" message
01:943B C2A48F          	  1341: 		JP		NZ,ERRIN		; "in line" wanted?
01:943E C3BB8F          	  1342: 		JP		PRNTOK			; Go to command mode
                        	  1343: 
01:9441 2AD410          	  1344: CONT:	LD		HL,(CONTAD)		; Get CONTinue address
01:9444 7C              	  1345: 		LD		A,H				; Is it zero?
01:9445 B5              	  1346: 		OR		L
01:9446 1E20            	  1347: 		LD		E,CN			; ?CN Error
01:9448 CA848F          	  1348: 		JP		Z,ERROR			; Yes - output "?CN Error"
01:944B EB              	  1349: 		EX		DE,HL			; Save code string address
01:944C 2AD210          	  1350: 		LD		HL,(ERRLIN)		; Get line of last break
01:944F 225C10          	  1351: 		LD		(LINEAT),HL		; Set up current line number
01:9452 EB              	  1352: 		EX		DE,HL			; Restore code string address
01:9453 C9              	  1353: 		RET						; CONTinue where left off
                        	  1354: 
01:9454 CD999F          	  1355: NULLL:	CALL	GETINT			; Get integer 0-255
01:9457 C0              	  1356: 		RET		NZ				; Return if bad value
01:9458 324110          	  1357: 		LD		(NULLS),A		; Set nulls number
01:945B C9              	  1358: 		RET
                        	  1359: 
                        	  1360: 
01:945C E5              	  1361: ACCSUM: PUSH	HL				; Save address in array
01:945D 2A4A10          	  1362: 		LD		HL,(CHKSUM)		; Get check sum
01:9460 0600            	  1363: 		LD		B,0				; BC - Value of byte
01:9462 4F              	  1364: 		LD		C,A
01:9463 09              	  1365: 		ADD		HL,BC			; Add byte to check sum
01:9464 224A10          	  1366: 		LD		(CHKSUM),HL		; Re-save check sum
01:9467 E1              	  1367: 		POP		HL				; Restore address in array
01:9468 C9              	  1368: 		RET
                        	  1369: 
01:9469 7E              	  1370: CHKLTR: LD		A,(HL)			; Get byte
01:946A FE41            	  1371: 		CP		'A'				; < 'a' ?
01:946C D8              	  1372: 		RET		C				; Carry set if not letter
01:946D FE5B            	  1373: 		CP		'Z'+1			; > 'z' ?
01:946F 3F              	  1374: 		CCF
01:9470 C9              	  1375: 		RET						; Carry set if not letter
                        	  1376: 
01:9471 CDC893          	  1377: FPSINT: CALL	GETCHR			; Get next character
01:9474 CD3898          	  1378: POSINT: CALL	GETNUM			; Get integer 0 to 32767
01:9477 CD1AA2          	  1379: DEPINT: CALL	TSTSGN			; Test sign of FPREG
01:947A FA9294          	  1380: 		JP		M,FCERR			; Negative - ?FC Error
01:947D 3AE710          	  1381: DEINT:	LD		A,(FPEXP)		; Get integer value to DE
01:9480 FE90            	  1382: 		CP		80H+16			; Exponent in range (16 bits)?
01:9482 DAC2A2          	  1383: 		JP		C,FPINT			; Yes - convert it
01:9485 018090          	  1384: 		LD		BC,9080H		; BCDE = -32768
01:9488 110000          	  1385: 		LD		DE,0000
01:948B E5              	  1386: 		PUSH	HL				; Save code string address
01:948C CD95A2          	  1387: 		CALL	CMPNUM			; Compare FPREG with BCDE
01:948F E1              	  1388: 		POP		HL				; Restore code string address
01:9490 51              	  1389: 		LD		D,C				; MSB to D
01:9491 C8              	  1390: 		RET		Z				; Return if in range
01:9492 1E08            	  1391: FCERR:	LD		E,FC			; ?FC Error
01:9494 C3848F          	  1392: 		JP		ERROR			; Output error-
                        	  1393: 
01:9497 2B              	  1394: ATOH:	DEC		HL				; ASCII number to DE binary
01:9498 110000          	  1395: GETLN:	LD		DE,0			; Get number to DE
01:949B CDC893          	  1396: GTLNLP: CALL	GETCHR			; Get next character
01:949E D0              	  1397: 		RET		NC				; Exit if not a digit
01:949F E5              	  1398: 		PUSH	HL				; Save code string address
01:94A0 F5              	  1399: 		PUSH	AF				; Save digit
01:94A1 219819          	  1400: 		LD		HL,65529/10		; Largest number 65529
01:94A4 CD3892          	  1401: 		CALL	CPDEHL			; Number in range?
01:94A7 DA708F          	  1402: 		JP		C,SNERR			; No - ?SN Error
01:94AA 62              	  1403: 		LD		H,D				; HL = Number
01:94AB 6B              	  1404: 		LD		L,E
01:94AC 19              	  1405: 		ADD		HL,DE			; Times 2
01:94AD 29              	  1406: 		ADD		HL,HL			; Times 4
01:94AE 19              	  1407: 		ADD		HL,DE			; Times 5
01:94AF 29              	  1408: 		ADD		HL,HL			; Times 10
01:94B0 F1              	  1409: 		POP		AF				; Restore digit
01:94B1 D630            	  1410: 		SUB		'0'				; Make it 0 to 9
01:94B3 5F              	  1411: 		LD		E,A				; DE = Value of digit
01:94B4 1600            	  1412: 		LD		D,0
01:94B6 19              	  1413: 		ADD		HL,DE			; Add to number
01:94B7 EB              	  1414: 		EX		DE,HL			; Number to DE
01:94B8 E1              	  1415: 		POP		HL				; Restore code string address
01:94B9 C39B94          	  1416: 		JP		GTLNLP			; Go to next character
                        	  1417: 
01:94BC CA8C90          	  1418: CLEAR:	JP		Z,INTVAR		; Just "CLEAR" Keep parameters
01:94BF CD7494          	  1419: 		CALL	POSINT			; Get integer 0 to 32767 to DE
01:94C2 2B              	  1420: 		DEC		HL				; Cancel increment
01:94C3 CDC893          	  1421: 		CALL	GETCHR			; Get next character
01:94C6 E5              	  1422: 		PUSH	HL				; Save code string address
01:94C7 2AAF10          	  1423: 		LD		HL,(LSTRAM)		; Get end of RAM
01:94CA CADF94          	  1424: 		JP		Z,STORED		; No value given - Use stored
01:94CD E1              	  1425: 		POP		HL				; Restore code string address
01:94CE CD3E92          	  1426: 		CALL	CHKSYN			; Check for comma
01:94D1 2C              	  1427: 		db	   ','
01:94D2 D5              	  1428: 		PUSH	DE				; Save number
01:94D3 CD7494          	  1429: 		CALL	POSINT			; Get integer 0 to 32767
01:94D6 2B              	  1430: 		DEC		HL				; Cancel increment
01:94D7 CDC893          	  1431: 		CALL	GETCHR			; Get next character
01:94DA C2708F          	  1432: 		JP		NZ,SNERR		; ?SN Error if more on line
01:94DD E3              	  1433: 		EX		(SP),HL			; Save code string address
01:94DE EB              	  1434: 		EX		DE,HL			; Number to DE
01:94DF 7D              	  1435: STORED: LD		A,L				; Get LSB of new RAM top
01:94E0 93              	  1436: 		SUB		E				; Subtract LSB of string space
01:94E1 5F              	  1437: 		LD		E,A				; Save LSB
01:94E2 7C              	  1438: 		LD		A,H				; Get MSB of new RAM top
01:94E3 9A              	  1439: 		SBC		A,D				; Subtract MSB of string space
01:94E4 57              	  1440: 		LD		D,A				; Save MSB
01:94E5 DA658F          	  1441: 		JP		C,OMERR			; ?OM Error if not enough mem
01:94E8 E5              	  1442: 		PUSH	HL				; Save RAM top
01:94E9 2AD610          	  1443: 		LD		HL,(PROGND)		; Get program end
01:94EC 012800          	  1444: 		LD		BC,40			; 40 Bytes minimum working RAM
01:94EF 09              	  1445: 		ADD		HL,BC			; Get lowest address
01:94F0 CD3892          	  1446: 		CALL	CPDEHL			; Enough memory?
01:94F3 D2658F          	  1447: 		JP		NC,OMERR		; No - ?OM Error
01:94F6 EB              	  1448: 		EX		DE,HL			; RAM top to HL
01:94F7 225A10          	  1449: 		LD		(STRSPC),HL		; Set new string space
01:94FA E1              	  1450: 		POP		HL				; End of memory to use
01:94FB 22AF10          	  1451: 		LD		(LSTRAM),HL		; Set new top of RAM
01:94FE E1              	  1452: 		POP		HL				; Restore code string address
01:94FF C38C90          	  1453: 		JP		INTVAR			; Initialise variables
                        	  1454: 
01:9502 CA8890          	  1455: RUN:	JP		Z,RUNFST		; RUN from start if just RUN
01:9505 CD8C90          	  1456: 		CALL	INTVAR			; Initialise variables
01:9508 018893          	  1457: 		LD		BC,RUNCNT		; Execution driver loop
01:950B C31E95          	  1458: 		JP		RUNLIN			; RUN from line number
                        	  1459: 
01:950E 0E03            	  1460: GOSUB:	LD		C,3				; 3 Levels of stack needed
01:9510 CD4D8F          	  1461: 		CALL	CHKSTK			; Check for 3 levels of stack
01:9513 C1              	  1462: 		POP		BC				; Get return address
01:9514 E5              	  1463: 		PUSH	HL				; Save code string for RETURN
01:9515 E5              	  1464: 		PUSH	HL				; And for GOSUB routine
01:9516 2A5C10          	  1465: 		LD		HL,(LINEAT)		; Get current line
01:9519 E3              	  1466: 		EX		(SP),HL			; Into stack - Code string out
01:951A 3E8C            	  1467: 		LD		A,ZGOSUB		; "GOSUB" token
01:951C F5              	  1468: 		PUSH	AF				; Save token
01:951D 33              	  1469: 		INC		SP				; Don't save flags
                        	  1470: 
01:951E C5              	  1471: RUNLIN: PUSH	BC				; Save return address
01:951F CD9794          	  1472: GOTO:	CALL	ATOH			; ASCII number to DE binary
01:9522 CD6495          	  1473: 		CALL	REM				; Get end of line
01:9525 E5              	  1474: 		PUSH	HL				; Save end of line
01:9526 2A5C10          	  1475: 		LD		HL,(LINEAT)		; Get current line
01:9529 CD3892          	  1476: 		CALL	CPDEHL			; Line after current?
01:952C E1              	  1477: 		POP		HL				; Restore end of line
01:952D 23              	  1478: 		INC		HL				; Start of next line
01:952E DC5F90          	  1479: 		CALL	C,SRCHLP		; Line is after current line
01:9531 D45C90          	  1480: 		CALL	NC,SRCHLN		; Line is before current line
01:9534 60              	  1481: 		LD		H,B				; Set up code string address
01:9535 69              	  1482: 		LD		L,C
01:9536 2B              	  1483: 		DEC		HL				; Incremented after
01:9537 D8              	  1484: 		RET		C				; Line found
01:9538 1E0E            	  1485: ULERR:	LD		E,UL			; ?UL Error
01:953A C3848F          	  1486: 		JP		ERROR			; Output error message
                        	  1487: 
01:953D C0              	  1488: RETURN: RET		NZ				; Return if not just RETURN
01:953E 16FF            	  1489: 		LD		D,-1			; Flag "GOSUB" search
01:9540 CD198F          	  1490: 		CALL	BAKSTK			; Look "GOSUB" block
01:9543 F9              	  1491: 		LD		SP,HL			; Kill all FORs in subroutine
01:9544 FE8C            	  1492: 		CP		ZGOSUB			; Test for "GOSUB" token
01:9546 1E04            	  1493: 		LD		E,RG			; ?RG Error
01:9548 C2848F          	  1494: 		JP		NZ,ERROR		; Error if no "GOSUB" found
01:954B E1              	  1495: 		POP		HL				; Get RETURN line number
01:954C 225C10          	  1496: 		LD		(LINEAT),HL		; Save as current
01:954F 23              	  1497: 		INC		HL				; Was it from direct statement?
01:9550 7C              	  1498: 		LD		A,H
01:9551 B5              	  1499: 		OR		L				; Return to line
01:9552 C25C95          	  1500: 		JP		NZ,RETLIN		; No - Return to line
01:9555 3ACC10          	  1501: 		LD		A,(LSTBIN)		; Any INPUT in subroutine?
01:9558 B7              	  1502: 		OR		A				; If so buffer is corrupted
01:9559 C2BA8F          	  1503: 		JP		NZ,POPNOK		; Yes - Go to command mode
01:955C 218893          	  1504: RETLIN: LD		HL,RUNCNT		; Execution driver loop
01:955F E3              	  1505: 		EX		(SP),HL			; Into stack - Code string out
01:9560 3E              	  1506: 		db	   3EH			   ; Skip "POP HL"
01:9561 E1              	  1507: NXTDTA: POP		HL				; Restore code string address
                        	  1508: 
01:9562 01              	  1509: DATAA:	db	   01H,3AH		   ; ':' End of statement
01:9563 3A
01:9564 0E00            	  1510: REM:	LD		C,0				; 00  End of statement
01:9566 0600            	  1511: 		LD		B,0
01:9568 79              	  1512: NXTSTL: LD		A,C				; Statement and byte
01:9569 48              	  1513: 		LD		C,B
01:956A 47              	  1514: 		LD		B,A				; Statement end byte
01:956B 7E              	  1515: NXTSTT: LD		A,(HL)			; Get byte
01:956C B7              	  1516: 		OR		A				; End of line?
01:956D C8              	  1517: 		RET		Z				; Yes - Exit
01:956E B8              	  1518: 		CP		B				; End of statement?
01:956F C8              	  1519: 		RET		Z				; Yes - Exit
01:9570 23              	  1520: 		INC		HL				; Next byte
01:9571 FE22            	  1521: 		CP		'"'				; Literal string?
01:9573 CA6895          	  1522: 		JP		Z,NXTSTL		; Yes - Look for another '"'
01:9576 C36B95          	  1523: 		JP		NXTSTT			; Keep looking
                        	  1524: 
01:9579 CD2E9A          	  1525: LET:	CALL	GETVAR			; Get variable name
01:957C CD3E92          	  1526: 		CALL	CHKSYN			; Make sure "=" follows
01:957F B4              	  1527: 		db	   ZEQUAL		   ; "=" token
01:9580 D5              	  1528: 		PUSH	DE				; Save address of variable
01:9581 3AAD10          	  1529: 		LD		A,(TYPE)		; Get data type
01:9584 F5              	  1530: 		PUSH	AF				; Save type
01:9585 CD4A98          	  1531: 		CALL	EVAL			; Evaluate expression
01:9588 F1              	  1532: 		POP		AF				; Restore type
01:9589 E3              	  1533: 		EX		(SP),HL			; Save code - Get var addr
01:958A 22CE10          	  1534: 		LD		(BRKLIN),HL		; Save address of variable
01:958D 1F              	  1535: 		RRA						; Adjust type
01:958E CD3D98          	  1536: 		CALL	CHKTYP			; Check types are the same
01:9591 CACC95          	  1537: 		JP		Z,LETNUM		; Numeric - Move value
01:9594 E5              	  1538: LETSTR: PUSH	HL				; Save address of string var
01:9595 2AE410          	  1539: 		LD		HL,(FPREG)		; Pointer to string entry
01:9598 E5              	  1540: 		PUSH	HL				; Save it on stack
01:9599 23              	  1541: 		INC		HL				; Skip over length
01:959A 23              	  1542: 		INC		HL
01:959B 5E              	  1543: 		LD		E,(HL)			; LSB of string address
01:959C 23              	  1544: 		INC		HL
01:959D 56              	  1545: 		LD		D,(HL)			; MSB of string address
01:959E 2A5E10          	  1546: 		LD		HL,(BASTXT)		; Point to start of program
01:95A1 CD3892          	  1547: 		CALL	CPDEHL			; Is string before program?
01:95A4 D2BB95          	  1548: 		JP		NC,CRESTR		; Yes - Create string entry
01:95A7 2A5A10          	  1549: 		LD		HL,(STRSPC)		; Point to string space
01:95AA CD3892          	  1550: 		CALL	CPDEHL			; Is string literal in program?
01:95AD D1              	  1551: 		POP		DE				; Restore address of string
01:95AE D2C395          	  1552: 		JP		NC,MVSTPT		; Yes - Set up pointer
01:95B1 21BF10          	  1553: 		LD		HL,TMPSTR		; Temporary string pool
01:95B4 CD3892          	  1554: 		CALL	CPDEHL			; Is string in temporary pool?
01:95B7 D2C395          	  1555: 		JP		NC,MVSTPT		; No - Set up pointer
01:95BA 3E              	  1556: 		db	3EH				; Skip "POP DE"
01:95BB D1              	  1557: CRESTR: POP		DE				; Restore address of string
01:95BC CD729E          	  1558: 		CALL	BAKTMP			; Back to last tmp-str entry
01:95BF EB              	  1559: 		EX		DE,HL			; Address of string entry
01:95C0 CDAB9C          	  1560: 		CALL	SAVSTR			; Save string in string area
01:95C3 CD729E          	  1561: MVSTPT: CALL	BAKTMP			; Back to last tmp-str entry
01:95C6 E1              	  1562: 		POP		HL				; Get string pointer
01:95C7 CD75A2          	  1563: 		CALL	DETHL4			; Move string pointer to var
01:95CA E1              	  1564: 		POP		HL				; Restore code string address
01:95CB C9              	  1565: 		RET
                        	  1566: 
01:95CC E5              	  1567: LETNUM: PUSH	HL				; Save address of variable
01:95CD CD72A2          	  1568: 		CALL	FPTHL			; Move value to variable
01:95D0 D1              	  1569: 		POP		DE				; Restore address of variable
01:95D1 E1              	  1570: 		POP		HL				; Restore code string address
01:95D2 C9              	  1571: 		RET
                        	  1572: 
01:95D3 CD999F          	  1573: ON:		CALL	GETINT			; Get integer 0-255
01:95D6 7E              	  1574: 		LD		A,(HL)			; Get "GOTO" or "GOSUB" token
01:95D7 47              	  1575: 		LD		B,A				; Save in B
01:95D8 FE8C            	  1576: 		CP		ZGOSUB			; "GOSUB" token?
01:95DA CAE295          	  1577: 		JP		Z,ONGO			; Yes - Find line number
01:95DD CD3E92          	  1578: 		CALL	CHKSYN			; Make sure it's "GOTO"
01:95E0 88              	  1579: 		db	ZGOTO			; "GOTO" token
01:95E1 2B              	  1580: 		DEC		HL				; Cancel increment
01:95E2 4B              	  1581: ONGO:	LD		C,E				; Integer of branch value
01:95E3 0D              	  1582: ONGOLP: DEC		C				; Count branches
01:95E4 78              	  1583: 		LD		A,B				; Get "GOTO" or "GOSUB" token
01:95E5 CAB093          	  1584: 		JP		Z,ONJMP			; Go to that line if right one
01:95E8 CD9894          	  1585: 		CALL	GETLN			; Get line number to DE
01:95EB FE2C            	  1586: 		CP		','				; Another line number?
01:95ED C0              	  1587: 		RET		NZ				; No - Drop through
01:95EE C3E395          	  1588: 		JP		ONGOLP			; Yes - loop
                        	  1589: 
01:95F1 CD4A98          	  1590: IFF:		CALL	EVAL			; Evaluate expression
01:95F4 7E              	  1591: 		LD		A,(HL)			; Get token
01:95F5 FE88            	  1592: 		CP		ZGOTO			; "GOTO" token?
01:95F7 CAFF95          	  1593: 		JP		Z,IFGO			; Yes - Get line
01:95FA CD3E92          	  1594: 		CALL	CHKSYN			; Make sure it's "THEN"
01:95FD A9              	  1595: 		db	   ZTHEN		   ; "THEN" token
01:95FE 2B              	  1596: 		DEC		HL				; Cancel increment
01:95FF CD3B98          	  1597: IFGO:	CALL	TSTNUM			; Make sure it's numeric
01:9602 CD1AA2          	  1598: 		CALL	TSTSGN			; Test state of expression
01:9605 CA6495          	  1599: 		JP		Z,REM			; False - Drop through
01:9608 CDC893          	  1600: 		CALL	GETCHR			; Get next character
01:960B DA1F95          	  1601: 		JP		C,GOTO			; Number - GOTO that line
01:960E C3AF93          	  1602: 		JP		IFJMP			; Otherwise do statement
                        	  1603: 
01:9611 2B              	  1604: MRPRNT: DEC		HL				; DEC 'cos GETCHR INCs
01:9612 CDC893          	  1605: 		CALL	GETCHR			; Get next character
01:9615 CA7396          	  1606: PRINTT:	JP		Z,PRNTCRLF		; CRLF if just PRINT
01:9618 C8              	  1607: PRNTLP: RET		Z				; End of list - Exit
01:9619 FEA5            	  1608: 		CP		ZTAB			; "TAB(" token?
01:961B CAA696          	  1609: 		JP		Z,DOTAB			; Yes - Do TAB routine
01:961E FEA8            	  1610: 		CP		ZSPC			; "SPC(" token?
01:9620 CAA696          	  1611: 		JP		Z,DOTAB			; Yes - Do SPC routine
01:9623 E5              	  1612: 		PUSH	HL				; Save code string address
01:9624 FE2C            	  1613: 		CP		','				; Comma?
01:9626 CA8F96          	  1614: 		JP		Z,DOCOM			; Yes - Move to next zone
01:9629 FE3B            	  1615: 		CP		59 ;";"			; Semi-colon?
01:962B CAC996          	  1616: 		JP		Z,NEXITM		; Do semi-colon routine
01:962E C1              	  1617: 		POP		BC				; Code string address to BC
01:962F CD4A98          	  1618: 		CALL	EVAL			; Evaluate expression
01:9632 E5              	  1619: 		PUSH	HL				; Save code string address
01:9633 3AAD10          	  1620: 		LD		A,(TYPE)		; Get variable type
01:9636 B7              	  1621: 		OR		A				; Is it a string variable?
01:9637 C25F96          	  1622: 		JP		NZ,PRNTST		; Yes - Output string contents
01:963A CDBFA3          	  1623: 		CALL	NUMASC			; Convert number to text
01:963D CDCF9C          	  1624: 		CALL	CRTST			; Create temporary string
01:9640 3620            	  1625: 		LD		(HL),' '		; Followed by a space
01:9642 2AE410          	  1626: 		LD		HL,(FPREG)		; Get length of output
01:9645 34              	  1627: 		INC		(HL)			; Plus 1 for the space
01:9646 2AE410          	  1628: 		LD		HL,(FPREG)		; < Not needed >
01:9649 3A4210          	  1629: 		LD		A,(LWIDTH)		; Get width of line
01:964C 47              	  1630: 		LD		B,A				; To B
01:964D 04              	  1631: 		INC		B				; Width 255 (No limit)?
01:964E CA5B96          	  1632: 		JP		Z,PRNTNB		; Yes - Output number string
01:9651 04              	  1633: 		INC		B				; Adjust it
01:9652 3AAB10          	  1634: 		LD		A,(CURPOS)		; Get cursor position
01:9655 86              	  1635: 		ADD		A,(HL)			; Add length of string
01:9656 3D              	  1636: 		DEC		A				; Adjust it
01:9657 B8              	  1637: 		CP		B				; Will output fit on this line?
01:9658 D47396          	  1638: 		CALL	NC,PRNTCRLF		; No - CRLF first
01:965B CD149D          	  1639: PRNTNB: CALL	PRS1			; Output string at (HL)
01:965E AF              	  1640: 		XOR		A				; Skip CALL by setting 'z' flag
01:965F C4149D          	  1641: PRNTST: CALL	NZ,PRS1			; Output string at (HL)
01:9662 E1              	  1642: 		POP		HL				; Restore code string address
01:9663 C31196          	  1643: 		JP		MRPRNT			; See if more to PRINT
                        	  1644: 
01:9666 3AAB10          	  1645: STTLIN: LD		A,(CURPOS)		; Make sure on new line
01:9669 B7              	  1646: 		OR		A				; Already at start?
01:966A C8              	  1647: 		RET		Z				; Yes - Do nothing
01:966B C37396          	  1648: 		JP		PRNTCRLF		; Start a new line
                        	  1649: 
01:966E 3600            	  1650: ENDINP: LD		(HL),0			; Mark end of buffer
01:9670 216010          	  1651: 		LD		HL,BUFFER-1		; Point to buffer
01:9673 3E0D            	  1652: PRNTCRLF: LD	A,CR			; Load a CR
01:9675 CD4992          	  1653: 		CALL	OUTC			; Output character
01:9678 3E0A            	  1654: 		LD		A,LF			; Load a LF
01:967A CD4992          	  1655: 		CALL	OUTC			; Output character
01:967D AF              	  1656: DONULL: XOR		A				; Set to position 0
01:967E 32AB10          	  1657: 		LD		(CURPOS),A		; Store it
01:9681 3A4110          	  1658: 		LD		A,(NULLS)		; Get number of nulls
01:9684 3D              	  1659: NULLP:	DEC		A				; Count them
01:9685 C8              	  1660: 		RET		Z				; Return if done
01:9686 F5              	  1661: 		PUSH	AF				; Save count
01:9687 AF              	  1662: 		XOR		A				; Load a null
01:9688 CD4992          	  1663: 		CALL	OUTC			; Output it
01:968B F1              	  1664: 		POP		AF				; Restore count
01:968C C38496          	  1665: 		JP		NULLP			; Keep counting
                        	  1666: 
01:968F 3A4310          	  1667: DOCOM:	LD		A,(COMMAN)		; Get comma width
01:9692 47              	  1668: 		LD		B,A				; Save in B
01:9693 3AAB10          	  1669: 		LD		A,(CURPOS)		; Get current position
01:9696 B8              	  1670: 		CP		B				; Within the limit?
01:9697 D47396          	  1671: 		CALL	NC,PRNTCRLF		; No - output CRLF
01:969A D2C996          	  1672: 		JP		NC,NEXITM		; Get next item
01:969D D60E            	  1673: ZONELP: SUB		14				; Next zone of 14 characters
01:969F D29D96          	  1674: 		JP		NC,ZONELP		; Repeat if more zones
01:96A2 2F              	  1675: 		CPL						; Number of spaces to output
01:96A3 C3BE96          	  1676: 		JP		ASPCS			; Output them
                        	  1677: 
01:96A6 F5              	  1678: DOTAB:	PUSH	AF				; Save token
01:96A7 CD969F          	  1679: 		CALL	FNDNUM			; Evaluate expression
01:96AA CD3E92          	  1680: 		CALL	CHKSYN			; Make sure ")" follows
01:96AD 29              	  1681: 		db	")"
01:96AE 2B              	  1682: 		DEC		HL				; Back space on to ")"
01:96AF F1              	  1683: 		POP		AF				; Restore token
01:96B0 D6A8            	  1684: 		SUB		ZSPC			; Was it "SPC(" ?
01:96B2 E5              	  1685: 		PUSH	HL				; Save code string address
01:96B3 CAB996          	  1686: 		JP		Z,DOSPC			; Yes - Do 'E' spaces
01:96B6 3AAB10          	  1687: 		LD		A,(CURPOS)		; Get current position
01:96B9 2F              	  1688: DOSPC:	CPL						; Number of spaces to print to
01:96BA 83              	  1689: 		ADD		A,E				; Total number to print
01:96BB D2C996          	  1690: 		JP		NC,NEXITM		; TAB < Current POS(X)
01:96BE 3C              	  1691: ASPCS:	INC		A				; Output A spaces
01:96BF 47              	  1692: 		LD		B,A				; Save number to print
01:96C0 3E20            	  1693: 		LD		A,' '			; Space
01:96C2 CD4992          	  1694: SPCLP:	CALL	OUTC			; Output character in A
01:96C5 05              	  1695: 		DEC		B				; Count them
01:96C6 C2C296          	  1696: 		JP		NZ,SPCLP		; Repeat if more
01:96C9 E1              	  1697: NEXITM: POP		HL				; Restore code string address
01:96CA CDC893          	  1698: 		CALL	GETCHR			; Get next character
01:96CD C31896          	  1699: 		JP		PRNTLP			; More to print
                        	  1700: 
01:96D0 3F5265646F206672	  1701: REDO:	db	"?Redo from start",CR,LF,0
01:96D8 6F6D207374617274
01:96E0 0D
01:96E1 0A
01:96E2 00
                        	  1702: 
01:96E3 3ACD10          	  1703: BADINP: LD		A,(READFG)		; READ or INPUT?
01:96E6 B7              	  1704: 		OR		A
01:96E7 C26A8F          	  1705: 		JP		NZ,DATSNR		; READ - ?SN Error
01:96EA C1              	  1706: 		POP		BC				; Throw away code string addr
01:96EB 21D096          	  1707: 		LD		HL,REDO			; "Redo from start" message
01:96EE CD119D          	  1708: 		CALL	PRS				; Output string
01:96F1 C3BB90          	  1709: 		JP		DOAGN			; Do last INPUT again
                        	  1710: 
01:96F4 CD7C9C          	  1711: INPUT:	CALL	IDTEST			; Test for illegal direct
01:96F7 7E              	  1712: 		LD		A,(HL)			; Get character after "INPUT"
01:96F8 FE22            	  1713: 		CP		'"'				; Is there a prompt string?
01:96FA 3E00            	  1714: 		LD		A,0				; Clear A and leave flags
01:96FC 324510          	  1715: 		LD		(CTLOFG),A		; Enable output
01:96FF C20E97          	  1716: 		JP		NZ,NOPMPT		; No prompt - get input
01:9702 CDD09C          	  1717: 		CALL	QTSTR			; Get string terminated by '"'
01:9705 CD3E92          	  1718: 		CALL	CHKSYN			; Check for ';' after prompt
01:9708 3B              	  1719: 		db	';'
01:9709 E5              	  1720: 		PUSH	HL				; Save code string address
01:970A CD149D          	  1721: 		CALL	PRS1			; Output prompt string
01:970D 3E              	  1722: 		db	3EH				; Skip "PUSH HL"
01:970E E5              	  1723: NOPMPT: PUSH	HL				; Save code string address
01:970F CDBF90          	  1724: 		CALL	PROMPT			; Get input with "? " prompt
01:9712 C1              	  1725: 		POP		BC				; Restore code string address
01:9713 DA1A94          	  1726: 		JP		C,INPBRK		; Break pressed - Exit
01:9716 23              	  1727: 		INC		HL				; Next byte
01:9717 7E              	  1728: 		LD		A,(HL)			; Get it
01:9718 B7              	  1729: 		OR		A				; End of line?
01:9719 2B              	  1730: 		DEC		HL				; Back again
01:971A C5              	  1731: 		PUSH	BC				; Re-save code string address
01:971B CA6195          	  1732: 		JP		Z,NXTDTA		; Yes - Find next DATA stmt
01:971E 362C            	  1733: 		LD		(HL),','		; Store comma as separator
01:9720 C32897          	  1734: 		JP		NXTITM			; Get next item
                        	  1735: 
01:9723 E5              	  1736: READ:	PUSH	HL				; Save code string address
01:9724 2ADC10          	  1737: 		LD		HL,(NXTDAT)		; Next DATA statement
01:9727 F6              	  1738: 		db	0F6H			; Flag "READ"
01:9728 AF              	  1739: NXTITM: XOR		A				; Flag "INPUT"
01:9729 32CD10          	  1740: 		LD		(READFG),A		; Save "READ"/"INPUT" flag
01:972C E3              	  1741: 		EX		(SP),HL			; Get code str' , Save pointer
01:972D C33497          	  1742: 		JP		GTVLUS			; Get values
                        	  1743: 
01:9730 CD3E92          	  1744: NEDMOR: CALL	CHKSYN			; Check for comma between items
01:9733 2C              	  1745: 		db	   ','
01:9734 CD2E9A          	  1746: GTVLUS: CALL	GETVAR			; Get variable name
01:9737 E3              	  1747: 		EX		(SP),HL			; Save code str" , Get pointer
01:9738 D5              	  1748: 		PUSH	DE				; Save variable address
01:9739 7E              	  1749: 		LD		A,(HL)			; Get next "INPUT"/"DATA" byte
01:973A FE2C            	  1750: 		CP		','				; Comma?
01:973C CA5C97          	  1751: 		JP		Z,ANTVLU		; Yes - Get another value
01:973F 3ACD10          	  1752: 		LD		A,(READFG)		; Is it READ?
01:9742 B7              	  1753: 		OR		A
01:9743 C2C997          	  1754: 		JP		NZ,FDTLP		; Yes - Find next DATA stmt
01:9746 3E3F            	  1755: 		LD		A,'?'			; More INPUT needed
01:9748 CD4992          	  1756: 		CALL	OUTC			; Output character
01:974B CDBF90          	  1757: 		CALL	PROMPT			; Get INPUT with prompt
01:974E D1              	  1758: 		POP		DE				; Variable address
01:974F C1              	  1759: 		POP		BC				; Code string address
01:9750 DA1A94          	  1760: 		JP		C,INPBRK		; Break pressed
01:9753 23              	  1761: 		INC		HL				; Point to next DATA byte
01:9754 7E              	  1762: 		LD		A,(HL)			; Get byte
01:9755 B7              	  1763: 		OR		A				; Is it zero (No input) ?
01:9756 2B              	  1764: 		DEC		HL				; Back space INPUT pointer
01:9757 C5              	  1765: 		PUSH	BC				; Save code string address
01:9758 CA6195          	  1766: 		JP		Z,NXTDTA		; Find end of buffer
01:975B D5              	  1767: 		PUSH	DE				; Save variable address
01:975C 3AAD10          	  1768: ANTVLU: LD		A,(TYPE)		; Check data type
01:975F B7              	  1769: 		OR		A				; Is it numeric?
01:9760 CA8697          	  1770: 		JP		Z,INPBIN		; Yes - Convert to binary
01:9763 CDC893          	  1771: 		CALL	GETCHR			; Get next character
01:9766 57              	  1772: 		LD		D,A				; Save input character
01:9767 47              	  1773: 		LD		B,A				; Again
01:9768 FE22            	  1774: 		CP		'"'				; Start of literal sting?"
01:976A CA7A97          	  1775: 		JP		Z,STRENT		; Yes - Create string entry
01:976D 3ACD10          	  1776: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:9770 B7              	  1777: 		OR		A
01:9771 57              	  1778: 		LD		D,A				; Save 00 if "INPUT"
01:9772 CA7797          	  1779: 		JP		Z,ITMSEP		; "INPUT" - End with 00
01:9775 163A            	  1780: 		LD		D,':'			; "DATA" - End with 00 or ':'
01:9777 062C            	  1781: ITMSEP: LD		B,','			; Item separator
01:9779 2B              	  1782: 		DEC		HL				; Back space for DTSTR
01:977A CDD39C          	  1783: STRENT: CALL	DTSTR			; Get string terminated by D
01:977D EB              	  1784: 		EX		DE,HL			; String address to DE
01:977E 219197          	  1785: 		LD		HL,LTSTND		; Where to go after LETSTR
01:9781 E3              	  1786: 		EX		(SP),HL			; Save HL , get input pointer
01:9782 D5              	  1787: 		PUSH	DE				; Save address of string
01:9783 C39495          	  1788: 		JP		LETSTR			; Assign string to variable
                        	  1789: 
01:9786 CDC893          	  1790: INPBIN: CALL	GETCHR			; Get next character
01:9789 CD21A3          	  1791: 		CALL	ASCTFP			; Convert ASCII to FP number
01:978C E3              	  1792: 		EX		(SP),HL			; Save input ptr, Get var addr
01:978D CD72A2          	  1793: 		CALL	FPTHL			; Move FPREG to variable
01:9790 E1              	  1794: 		POP		HL				; Restore input pointer
01:9791 2B              	  1795: LTSTND: DEC		HL				; DEC 'cos GETCHR INCs
01:9792 CDC893          	  1796: 		CALL	GETCHR			; Get next character
01:9795 CA9D97          	  1797: 		JP		Z,MORDT			; End of line - More needed?
01:9798 FE2C            	  1798: 		CP		','				; Another value?
01:979A C2E396          	  1799: 		JP		NZ,BADINP		; No - Bad input
01:979D E3              	  1800: MORDT:	EX		(SP),HL			; Get code string address
01:979E 2B              	  1801: 		DEC		HL				; DEC 'cos GETCHR INCs
01:979F CDC893          	  1802: 		CALL	GETCHR			; Get next character
01:97A2 C23097          	  1803: 		JP		NZ,NEDMOR		; More needed - Get it
01:97A5 D1              	  1804: 		POP		DE				; Restore DATA pointer
01:97A6 3ACD10          	  1805: 		LD		A,(READFG)		; "READ" or "INPUT" ?
01:97A9 B7              	  1806: 		OR		A
01:97AA EB              	  1807: 		EX		DE,HL			; DATA pointer to HL
01:97AB C2EE93          	  1808: 		JP		NZ,UPDATA		; Update DATA pointer if "READ"
01:97AE D5              	  1809: 		PUSH	DE				; Save code string address
01:97AF B6              	  1810: 		OR		(HL)			; More input given?
01:97B0 21B897          	  1811: 		LD		HL,EXTIG		; "?Extra ignored" message
01:97B3 C4119D          	  1812: 		CALL	NZ,PRS			; Output string if extra given
01:97B6 E1              	  1813: 		POP		HL				; Restore code string address
01:97B7 C9              	  1814: 		RET
                        	  1815: 
01:97B8 3F45787472612069	  1816: EXTIG:	db	"?Extra ignored",CR,LF,0
01:97C0 676E6F726564
01:97C6 0D
01:97C7 0A
01:97C8 00
                        	  1817: 
01:97C9 CD6295          	  1818: FDTLP:	CALL	DATAA			; Get next statement
01:97CC B7              	  1819: 		OR		A				; End of line?
01:97CD C2E297          	  1820: 		JP		NZ,FANDT		; No - See if DATA statement
01:97D0 23              	  1821: 		INC		HL
01:97D1 7E              	  1822: 		LD		A,(HL)			; End of program?
01:97D2 23              	  1823: 		INC		HL
01:97D3 B6              	  1824: 		OR		(HL)			; 00 00 Ends program
01:97D4 1E06            	  1825: 		LD		E,OD			; ?OD Error
01:97D6 CA848F          	  1826: 		JP		Z,ERROR			; Yes - Out of DATA
01:97D9 23              	  1827: 		INC		HL
01:97DA 5E              	  1828: 		LD		E,(HL)			; LSB of line number
01:97DB 23              	  1829: 		INC		HL
01:97DC 56              	  1830: 		LD		D,(HL)			; MSB of line number
01:97DD EB              	  1831: 		EX		DE,HL
01:97DE 22C910          	  1832: 		LD		(DATLIN),HL		; Set line of current DATA item
01:97E1 EB              	  1833: 		EX		DE,HL
01:97E2 CDC893          	  1834: FANDT:	CALL	GETCHR			; Get next character
01:97E5 FE83            	  1835: 		CP		ZDATA			; "DATA" token
01:97E7 C2C997          	  1836: 		JP		NZ,FDTLP		; No "DATA" - Keep looking
01:97EA C35C97          	  1837: 		JP		ANTVLU			; Found - Convert input
                        	  1838: 
01:97ED 110000          	  1839: NEXT:	LD		DE,0			; In case no index given
01:97F0 C42E9A          	  1840: NEXT1:	CALL	NZ,GETVAR		; Get index address
01:97F3 22CE10          	  1841: 		LD		(BRKLIN),HL		; Save code string address
01:97F6 CD198F          	  1842: 		CALL	BAKSTK			; Look for "FOR" block
01:97F9 C2768F          	  1843: 		JP		NZ,NFERR		; No "FOR" - ?NF Error
01:97FC F9              	  1844: 		LD		SP,HL			; Clear nested loops
01:97FD D5              	  1845: 		PUSH	DE				; Save index address
01:97FE 7E              	  1846: 		LD		A,(HL)			; Get sign of STEP
01:97FF 23              	  1847: 		INC		HL
01:9800 F5              	  1848: 		PUSH	AF				; Save sign of STEP
01:9801 D5              	  1849: 		PUSH	DE				; Save index address
01:9802 CD58A2          	  1850: 		CALL	PHLTFP			; Move index value to FPREG
01:9805 E3              	  1851: 		EX		(SP),HL			; Save address of TO value
01:9806 E5              	  1852: 		PUSH	HL				; Save address of index
01:9807 CDC59F          	  1853: 		CALL	ADDPHL			; Add STEP to index value
01:980A E1              	  1854: 		POP		HL				; Restore address of index
01:980B CD72A2          	  1855: 		CALL	FPTHL			; Move value to index variable
01:980E E1              	  1856: 		POP		HL				; Restore address of TO value
01:980F CD69A2          	  1857: 		CALL	LOADFP			; Move TO value to BCDE
01:9812 E5              	  1858: 		PUSH	HL				; Save address of line of FOR
01:9813 CD95A2          	  1859: 		CALL	CMPNUM			; Compare index with TO value
01:9816 E1              	  1860: 		POP		HL				; Restore address of line num
01:9817 C1              	  1861: 		POP		BC				; Address of sign of STEP
01:9818 90              	  1862: 		SUB		B				; Compare with expected sign
01:9819 CD69A2          	  1863: 		CALL	LOADFP			; BC = Loop stmt,DE = Line num
01:981C CA2898          	  1864: 		JP		Z,KILFOR		; Loop finished - Terminate it
01:981F EB              	  1865: 		EX		DE,HL			; Loop statement line number
01:9820 225C10          	  1866: 		LD		(LINEAT),HL		; Set loop line number
01:9823 69              	  1867: 		LD		L,C				; Set code string to loop
01:9824 60              	  1868: 		LD		H,B
01:9825 C38493          	  1869: 		JP		PUTFID			; Put back "FOR" and continue
                        	  1870: 
01:9828 F9              	  1871: KILFOR: LD		SP,HL			; Remove "FOR" block
01:9829 2ACE10          	  1872: 		LD		HL,(BRKLIN)		; Code string after "NEXT"
01:982C 7E              	  1873: 		LD		A,(HL)			; Get next byte in code string
01:982D FE2C            	  1874: 		CP		','				; More NEXTs ?
01:982F C28893          	  1875: 		JP		NZ,RUNCNT		; No - Do next statement
01:9832 CDC893          	  1876: 		CALL	GETCHR			; Position to index name
01:9835 CDF097          	  1877: 		CALL	NEXT1			; Re-enter NEXT routine
                        	  1878: ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        	  1879: 
01:9838 CD4A98          	  1880: GETNUM: CALL	EVAL			; Get a numeric expression
01:983B F6              	  1881: TSTNUM: db	   0F6H			   ; Clear carry (numeric)
01:983C 37              	  1882: TSTSTR: SCF						; Set carry (string)
01:983D 3AAD10          	  1883: CHKTYP: LD		A,(TYPE)		; Check types match
01:9840 8F              	  1884: 		ADC		A,A				; Expected + actual
01:9841 B7              	  1885: 		OR		A				; Clear carry , set parity
01:9842 E8              	  1886: 		RET		PE				; Even parity - Types match
01:9843 C3828F          	  1887: 		JP		TMERR			; Different types - Error
                        	  1888: 
01:9846 CD3E92          	  1889: OPNPAR: CALL	CHKSYN			; Make sure "(" follows
01:9849 28              	  1890: 		db	"("
01:984A 2B              	  1891: EVAL:	DEC		HL				; Evaluate expression & save
01:984B 1600            	  1892: 		LD		D,0				; Precedence value
01:984D D5              	  1893: EVAL1:	PUSH	DE				; Save precedence
01:984E 0E01            	  1894: 		LD		C,1
01:9850 CD4D8F          	  1895: 		CALL	CHKSTK			; Check for 1 level of stack
01:9853 CDC198          	  1896: 		CALL	OPRND			; Get next expression value
01:9856 22D010          	  1897: EVAL2:	LD		(NXTOPR),HL		; Save address of next operator
01:9859 2AD010          	  1898: EVAL3:	LD		HL,(NXTOPR)		; Restore address of next opr
01:985C C1              	  1899: 		POP		BC				; Precedence value and operator
01:985D 78              	  1900: 		LD		A,B				; Get precedence value
01:985E FE78            	  1901: 		CP		78H				; "AND" or "OR" ?
01:9860 D43B98          	  1902: 		CALL	NC,TSTNUM		; No - Make sure it's a number
01:9863 7E              	  1903: 		LD		A,(HL)			; Get next operator / function
01:9864 1600            	  1904: 		LD		D,0				; Clear Last relation
01:9866 D6B3            	  1905: RLTLP:	SUB		ZGTR			; ">" Token
01:9868 DA8298          	  1906: 		JP		C,FOPRND		; + - * / ^ AND OR - Test it
01:986B FE03            	  1907: 		CP		ZLTH+1-ZGTR		; < = >
01:986D D28298          	  1908: 		JP		NC,FOPRND		; Function - Call it
01:9870 FE01            	  1909: 		CP		ZEQUAL-ZGTR		; "="
01:9872 17              	  1910: 		RLA						; <- Test for legal
01:9873 AA              	  1911: 		XOR		D				; <- combinations of < = >
01:9874 BA              	  1912: 		CP		D				; <- by combining last token
01:9875 57              	  1913: 		LD		D,A				; <- with current one
01:9876 DA708F          	  1914: 		JP		C,SNERR			; Error if "<<' '==" or ">>"
01:9879 22C510          	  1915: 		LD		(CUROPR),HL		; Save address of current token
01:987C CDC893          	  1916: 		CALL	GETCHR			; Get next character
01:987F C36698          	  1917: 		JP		RLTLP			; Treat the two as one
                        	  1918: 
01:9882 7A              	  1919: FOPRND: LD		A,D				; < = > found ?
01:9883 B7              	  1920: 		OR		A
01:9884 C2A999          	  1921: 		JP		NZ,TSTRED		; Yes - Test for reduction
01:9887 7E              	  1922: 		LD		A,(HL)			; Get operator token
01:9888 22C510          	  1923: 		LD		(CUROPR),HL		; Save operator address
01:988B D6AC            	  1924: 		SUB		ZPLUS			; Operator or function?
01:988D D8              	  1925: 		RET		C				; Neither - Exit
01:988E FE07            	  1926: 		CP		ZOR+1-ZPLUS		; Is it + - * / ^ AND OR ?
01:9890 D0              	  1927: 		RET		NC				; No - Exit
01:9891 5F              	  1928: 		LD		E,A				; Coded operator
01:9892 3AAD10          	  1929: 		LD		A,(TYPE)		; Get data type
01:9895 3D              	  1930: 		DEC		A				; FF = numeric , 00 = string
01:9896 B3              	  1931: 		OR		E				; Combine with coded operator
01:9897 7B              	  1932: 		LD		A,E				; Get coded operator
01:9898 CA079E          	  1933: 		JP		Z,CONCAT		; String concatenation
01:989B 07              	  1934: 		RLCA					; Times 2
01:989C 83              	  1935: 		ADD		A,E				; Times 3
01:989D 5F              	  1936: 		LD		E,A				; To DE (D is 0)
01:989E 21628E          	  1937: 		LD		HL,PRITAB		; Precedence table
01:98A1 19              	  1938: 		ADD		HL,DE			; To the operator concerned
01:98A2 78              	  1939: 		LD		A,B				; Last operator precedence
01:98A3 56              	  1940: 		LD		D,(HL)			; Get evaluation precedence
01:98A4 BA              	  1941: 		CP		D				; Compare with eval precedence
01:98A5 D0              	  1942: 		RET		NC				; Exit if higher precedence
01:98A6 23              	  1943: 		INC		HL				; Point to routine address
01:98A7 CD3B98          	  1944: 		CALL	TSTNUM			; Make sure it's a number
                        	  1945: 
01:98AA C5              	  1946: STKTHS: PUSH	BC				; Save last precedence & token
01:98AB 015998          	  1947: 		LD		BC,EVAL3		; Where to go on prec' break
01:98AE C5              	  1948: 		PUSH	BC				; Save on stack for return
01:98AF 43              	  1949: 		LD		B,E				; Save operator
01:98B0 4A              	  1950: 		LD		C,D				; Save precedence
01:98B1 CD4BA2          	  1951: 		CALL	STAKFP			; Move value to stack
01:98B4 58              	  1952: 		LD		E,B				; Restore operator
01:98B5 51              	  1953: 		LD		D,C				; Restore precedence
01:98B6 4E              	  1954: 		LD		C,(HL)			; Get LSB of routine address
01:98B7 23              	  1955: 		INC		HL
01:98B8 46              	  1956: 		LD		B,(HL)			; Get MSB of routine address
01:98B9 23              	  1957: 		INC		HL
01:98BA C5              	  1958: 		PUSH	BC				; Save routine address
01:98BB 2AC510          	  1959: 		LD		HL,(CUROPR)		; Address of current operator
01:98BE C34D98          	  1960: 		JP		EVAL1			; Loop until prec' break
                        	  1961: 
01:98C1 AF              	  1962: OPRND:	XOR		A				; Get operand routine
01:98C2 32AD10          	  1963: 		LD		(TYPE),A		; Set numeric expected
01:98C5 CDC893          	  1964: 		CALL	GETCHR			; Get next character
01:98C8 1E24            	  1965: 		LD		E,MO			; ?MO Error
01:98CA CA848F          	  1966: 		JP		Z,ERROR			; No operand - Error
01:98CD DA21A3          	  1967: 		JP		C,ASCTFP		; Number - Get value
01:98D0 CD6994          	  1968: 		CALL	CHKLTR			; See if a letter
01:98D3 D22899          	  1969: 		JP		NC,CONVAR		; Letter - Find variable
01:98D6 FE26            	  1970: 		CP		'&'				; &H = HEX, &B = BINARY
01:98D8 2012            	  1971: 		JR		NZ, NOTAMP
01:98DA CDC893          	  1972: 		CALL	GETCHR			; Get next character
01:98DD FE48            	  1973: 		CP		'H'				; Hex number indicated? [function added]
01:98DF CA65A7          	  1974: 		JP		Z,HEXTFP		; Convert Hex to FPREG
01:98E2 FE42            	  1975: 		CP		'B'				; Binary number indicated? [function added]
01:98E4 CAD5A7          	  1976: 		JP		Z,BINTFP		; Convert Bin to FPREG
01:98E7 1E02            	  1977: 		LD		E,SN			; If neither then a ?SN Error
01:98E9 CA848F          	  1978: 		JP		Z,ERROR			; 
01:98EC FEAC            	  1979: NOTAMP: CP		ZPLUS			; '+' Token ?
01:98EE CAC198          	  1980: 		JP		Z,OPRND			; Yes - Look for operand
01:98F1 FE2E            	  1981: 		CP		'.'				; '.' ?
01:98F3 CA21A3          	  1982: 		JP		Z,ASCTFP		; Yes - Create FP number
01:98F6 FEAD            	  1983: 		CP		ZMINUS			; '-' Token ?
01:98F8 CA1799          	  1984: 		JP		Z,MINUS			; Yes - Do minus
01:98FB FE22            	  1985: 		CP		'"'				; Literal string ?
01:98FD CAD09C          	  1986: 		JP		Z,QTSTR			; Get string terminated by '"'
01:9900 FEAA            	  1987: 		CP		ZNOT			; "NOT" Token ?
01:9902 CA099A          	  1988: 		JP		Z,EVNOT			; Yes - Eval NOT expression
01:9905 FEA7            	  1989: 		CP		ZFN				; "FN" Token ?
01:9907 CA349C          	  1990: 		JP		Z,DOFN			; Yes - Do FN routine
01:990A D6B6            	  1991: 		SUB		ZSGN			; Is it a function?
01:990C D23999          	  1992: 		JP		NC,FNOFST		; Yes - Evaluate function
01:990F CD4698          	  1993: EVLPAR: CALL	OPNPAR			; Evaluate expression in "()"
01:9912 CD3E92          	  1994: 		CALL	CHKSYN			; Make sure ")" follows
01:9915 29              	  1995: 		db	")"
01:9916 C9              	  1996: 		RET
                        	  1997: 
01:9917 167D            	  1998: MINUS:	LD		D,7DH			; '-' precedence
01:9919 CD4D98          	  1999: 		CALL	EVAL1			; Evaluate until prec' break
01:991C 2AD010          	  2000: 		LD		HL,(NXTOPR)		; Get next operator address
01:991F E5              	  2001: 		PUSH	HL				; Save next operator address
01:9920 CD43A2          	  2002: 		CALL	INVSGN			; Negate value
01:9923 CD3B98          	  2003: RETNUM: CALL	TSTNUM			; Make sure it's a number
01:9926 E1              	  2004: 		POP		HL				; Restore next operator address
01:9927 C9              	  2005: 		RET
                        	  2006: 
01:9928 CD2E9A          	  2007: CONVAR: CALL	GETVAR			; Get variable address to DE
01:992B E5              	  2008: FRMEVL: PUSH	HL				; Save code string address
01:992C EB              	  2009: 		EX		DE,HL			; Variable address to HL
01:992D 22E410          	  2010: 		LD		(FPREG),HL		; Save address of variable
01:9930 3AAD10          	  2011: 		LD		A,(TYPE)		; Get type
01:9933 B7              	  2012: 		OR		A				; Numeric?
01:9934 CC58A2          	  2013: 		CALL	Z,PHLTFP		; Yes - Move contents to FPREG
01:9937 E1              	  2014: 		POP		HL				; Restore code string address
01:9938 C9              	  2015: 		RET
                        	  2016: 
01:9939 0600            	  2017: FNOFST: LD		B,0				; Get address of function
01:993B 07              	  2018: 		RLCA					; Double function offset
01:993C 4F              	  2019: 		LD		C,A				; BC = Offset in function table
01:993D C5              	  2020: 		PUSH	BC				; Save adjusted token value
01:993E CDC893          	  2021: 		CALL	GETCHR			; Get next character
01:9941 79              	  2022: 		LD		A,C				; Get adjusted token value
01:9942 FE31            	  2023: 		CP		2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
01:9944 DA6099          	  2024: 		JP		C,FNVAL			; No - Do function
01:9947 CD4698          	  2025: 		CALL	OPNPAR			; Evaluate expression  (X,...
01:994A CD3E92          	  2026: 		CALL	CHKSYN			; Make sure ',' follows
01:994D 2C              	  2027: 		db	   ','
01:994E CD3C98          	  2028: 		CALL	TSTSTR			; Make sure it's a string
01:9951 EB              	  2029: 		EX		DE,HL			; Save code string address
01:9952 2AE410          	  2030: 		LD		HL,(FPREG)		; Get address of string
01:9955 E3              	  2031: 		EX		(SP),HL			; Save address of string
01:9956 E5              	  2032: 		PUSH	HL				; Save adjusted token value
01:9957 EB              	  2033: 		EX		DE,HL			; Restore code string address
01:9958 CD999F          	  2034: 		CALL	GETINT			; Get integer 0-255
01:995B EB              	  2035: 		EX		DE,HL			; Save code string address
01:995C E3              	  2036: 		EX		(SP),HL			; Save integer,HL = adj' token
01:995D C36899          	  2037: 		JP		GOFUNC			; Jump to string function
                        	  2038: 
01:9960 CD0F99          	  2039: FNVAL:	CALL	EVLPAR			; Evaluate expression
01:9963 E3              	  2040: 		EX		(SP),HL			; HL = Adjusted token value
01:9964 112399          	  2041: 		LD		DE,RETNUM		; Return number from function
01:9967 D5              	  2042: 		PUSH	DE				; Save on stack
01:9968 01C18C          	  2043: GOFUNC: LD		BC,FNCTAB		; Function routine addresses
01:996B 09              	  2044: 		ADD		HL,BC			; Point to right address
01:996C 4E              	  2045: 		LD		C,(HL)			; Get LSB of address
01:996D 23              	  2046: 		INC		HL				;
01:996E 66              	  2047: 		LD		H,(HL)			; Get MSB of address
01:996F 69              	  2048: 		LD		L,C				; Address to HL
01:9970 E9              	  2049: 		JP		(HL)			; Jump to function
                        	  2050: 
01:9971 15              	  2051: SGNEXP: DEC		D				; Dee to flag negative exponent
01:9972 FEAD            	  2052: 		CP		ZMINUS			; '-' token ?
01:9974 C8              	  2053: 		RET		Z				; Yes - Return
01:9975 FE2D            	  2054: 		CP		'-'				; '-' ASCII ?
01:9977 C8              	  2055: 		RET		Z				; Yes - Return
01:9978 14              	  2056: 		INC		D				; Inc to flag positive exponent
01:9979 FE2B            	  2057: 		CP		'+'				; '+' ASCII ?
01:997B C8              	  2058: 		RET		Z				; Yes - Return
01:997C FEAC            	  2059: 		CP		ZPLUS			; '+' token ?
01:997E C8              	  2060: 		RET		Z				; Yes - Return
01:997F 2B              	  2061: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9980 C9              	  2062: 		RET						; Return "NZ"
                        	  2063: 
01:9981 F6              	  2064: POR:	db	   0F6H			   ; Flag "OR"
01:9982 AF              	  2065: PAND:	XOR		A				; Flag "AND"
01:9983 F5              	  2066: 		PUSH	AF				; Save "AND" / "OR" flag
01:9984 CD3B98          	  2067: 		CALL	TSTNUM			; Make sure it's a number
01:9987 CD7D94          	  2068: 		CALL	DEINT			; Get integer -32768 to 32767
01:998A F1              	  2069: 		POP		AF				; Restore "AND" / "OR" flag
01:998B EB              	  2070: 		EX		DE,HL			; <- Get last
01:998C C1              	  2071: 		POP		BC				; <-  value
01:998D E3              	  2072: 		EX		(SP),HL			; <-  from
01:998E EB              	  2073: 		EX		DE,HL			; <-  stack
01:998F CD5BA2          	  2074: 		CALL	FPBCDE			; Move last value to FPREG
01:9992 F5              	  2075: 		PUSH	AF				; Save "AND" / "OR" flag
01:9993 CD7D94          	  2076: 		CALL	DEINT			; Get integer -32768 to 32767
01:9996 F1              	  2077: 		POP		AF				; Restore "AND" / "OR" flag
01:9997 C1              	  2078: 		POP		BC				; Get value
01:9998 79              	  2079: 		LD		A,C				; Get LSB
01:9999 21F29B          	  2080: 		LD		HL,ACPASS		; Address of save AC as current
01:999C C2A499          	  2081: 		JP		NZ,POR1			; Jump if OR
01:999F A3              	  2082: 		AND		E				; "AND" LSBs
01:99A0 4F              	  2083: 		LD		C,A				; Save LSB
01:99A1 78              	  2084: 		LD		A,B				; Get MBS
01:99A2 A2              	  2085: 		AND		D				; "AND" MSBs
01:99A3 E9              	  2086: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2087: 
01:99A4 B3              	  2088: POR1:	OR		E				; "OR" LSBs
01:99A5 4F              	  2089: 		LD		C,A				; Save LSB
01:99A6 78              	  2090: 		LD		A,B				; Get MSB
01:99A7 B2              	  2091: 		OR		D				; "OR" MSBs
01:99A8 E9              	  2092: 		JP		(HL)			; Save AC as current (ACPASS)
                        	  2093: 
01:99A9 21BB99          	  2094: TSTRED: LD		HL,CMPLOG		; Logical compare routine
01:99AC 3AAD10          	  2095: 		LD		A,(TYPE)		; Get data type
01:99AF 1F              	  2096: 		RRA						; Carry set = string
01:99B0 7A              	  2097: 		LD		A,D				; Get last precedence value
01:99B1 17              	  2098: 		RLA						; Times 2 plus carry
01:99B2 5F              	  2099: 		LD		E,A				; To E
01:99B3 1664            	  2100: 		LD		D,64H			; Relational precedence
01:99B5 78              	  2101: 		LD		A,B				; Get current precedence
01:99B6 BA              	  2102: 		CP		D				; Compare with last
01:99B7 D0              	  2103: 		RET		NC				; Eval if last was rel' or log'
01:99B8 C3AA98          	  2104: 		JP		STKTHS			; Stack this one and get next
                        	  2105: 
01:99BB BD99            	  2106: CMPLOG: dw	CMPLG1			; Compare two values / strings
01:99BD 79              	  2107: CMPLG1: LD		A,C				; Get data type
01:99BE B7              	  2108: 		OR		A
01:99BF 1F              	  2109: 		RRA
01:99C0 C1              	  2110: 		POP		BC				; Get last expression to BCDE
01:99C1 D1              	  2111: 		POP		DE
01:99C2 F5              	  2112: 		PUSH	AF				; Save status
01:99C3 CD3D98          	  2113: 		CALL	CHKTYP			; Check that types match
01:99C6 21FF99          	  2114: 		LD		HL,CMPRES		; Result to comparison
01:99C9 E5              	  2115: 		PUSH	HL				; Save for RETurn
01:99CA CA95A2          	  2116: 		JP		Z,CMPNUM		; Compare values if numeric
01:99CD AF              	  2117: 		XOR		A				; Compare two strings
01:99CE 32AD10          	  2118: 		LD		(TYPE),A		; Set type to numeric
01:99D1 D5              	  2119: 		PUSH	DE				; Save string name
01:99D2 CD549E          	  2120: 		CALL	GSTRCU			; Get current string
01:99D5 7E              	  2121: 		LD		A,(HL)			; Get length of string
01:99D6 23              	  2122: 		INC		HL
01:99D7 23              	  2123: 		INC		HL
01:99D8 4E              	  2124: 		LD		C,(HL)			; Get LSB of address
01:99D9 23              	  2125: 		INC		HL
01:99DA 46              	  2126: 		LD		B,(HL)			; Get MSB of address
01:99DB D1              	  2127: 		POP		DE				; Restore string name
01:99DC C5              	  2128: 		PUSH	BC				; Save address of string
01:99DD F5              	  2129: 		PUSH	AF				; Save length of string
01:99DE CD589E          	  2130: 		CALL	GSTRDE			; Get second string
01:99E1 CD69A2          	  2131: 		CALL	LOADFP			; Get address of second string
01:99E4 F1              	  2132: 		POP		AF				; Restore length of string 1
01:99E5 57              	  2133: 		LD		D,A				; Length to D
01:99E6 E1              	  2134: 		POP		HL				; Restore address of string 1
01:99E7 7B              	  2135: CMPSTR: LD		A,E				; Bytes of string 2 to do
01:99E8 B2              	  2136: 		OR		D				; Bytes of string 1 to do
01:99E9 C8              	  2137: 		RET		Z				; Exit if all bytes compared
01:99EA 7A              	  2138: 		LD		A,D				; Get bytes of string 1 to do
01:99EB D601            	  2139: 		SUB		1
01:99ED D8              	  2140: 		RET		C				; Exit if end of string 1
01:99EE AF              	  2141: 		XOR		A
01:99EF BB              	  2142: 		CP		E				; Bytes of string 2 to do
01:99F0 3C              	  2143: 		INC		A
01:99F1 D0              	  2144: 		RET		NC				; Exit if end of string 2
01:99F2 15              	  2145: 		DEC		D				; Count bytes in string 1
01:99F3 1D              	  2146: 		DEC		E				; Count bytes in string 2
01:99F4 0A              	  2147: 		LD		A,(BC)			; Byte in string 2
01:99F5 BE              	  2148: 		CP		(HL)			; Compare to byte in string 1
01:99F6 23              	  2149: 		INC		HL				; Move up string 1
01:99F7 03              	  2150: 		INC		BC				; Move up string 2
01:99F8 CAE799          	  2151: 		JP		Z,CMPSTR		; Same - Try next bytes
01:99FB 3F              	  2152: 		CCF						; Flag difference (">" or "<")
01:99FC C325A2          	  2153: 		JP		FLGDIF			; "<" gives -1 , ">" gives +1
                        	  2154: 
01:99FF 3C              	  2155: CMPRES: INC		A				; Increment current value
01:9A00 8F              	  2156: 		ADC		A,A				; Double plus carry
01:9A01 C1              	  2157: 		POP		BC				; Get other value
01:9A02 A0              	  2158: 		AND		B				; Combine them
01:9A03 C6FF            	  2159: 		ADD		A,-1			; Carry set if different
01:9A05 9F              	  2160: 		SBC		A,A				; 00 - Equal , FF - Different
01:9A06 C32CA2          	  2161: 		JP		FLGREL			; Set current value & continue
                        	  2162: 
01:9A09 165A            	  2163: EVNOT:	LD		D,5AH			; Precedence value for "NOT"
01:9A0B CD4D98          	  2164: 		CALL	EVAL1			; Eval until precedence break
01:9A0E CD3B98          	  2165: 		CALL	TSTNUM			; Make sure it's a number
01:9A11 CD7D94          	  2166: 		CALL	DEINT			; Get integer -32768 - 32767
01:9A14 7B              	  2167: 		LD		A,E				; Get LSB
01:9A15 2F              	  2168: 		CPL						; Invert LSB
01:9A16 4F              	  2169: 		LD		C,A				; Save "NOT" of LSB
01:9A17 7A              	  2170: 		LD		A,D				; Get MSB
01:9A18 2F              	  2171: 		CPL						; Invert MSB
01:9A19 CDF29B          	  2172: 		CALL	ACPASS			; Save AC as current
01:9A1C C1              	  2173: 		POP		BC				; Clean up stack
01:9A1D C35998          	  2174: 		JP		EVAL3			; Continue evaluation
                        	  2175: 
01:9A20 2B              	  2176: DIMRET: DEC		HL				; DEC 'cos GETCHR INCs
01:9A21 CDC893          	  2177: 		CALL	GETCHR			; Get next character
01:9A24 C8              	  2178: 		RET		Z				; End of DIM statement
01:9A25 CD3E92          	  2179: 		CALL	CHKSYN			; Make sure ',' follows
01:9A28 2C              	  2180: 		db	   ','
01:9A29 01209A          	  2181: DIM:	LD		BC,DIMRET		; Return to "DIMRET"
01:9A2C C5              	  2182: 		PUSH	BC				; Save on stack
01:9A2D F6              	  2183: 		db	   0F6H			   ; Flag "Create" variable
01:9A2E AF              	  2184: GETVAR: XOR		A				; Find variable address,to DE
01:9A2F 32AC10          	  2185: 		LD		(LCRFLG),A		; Set locate / create flag
01:9A32 46              	  2186: 		LD		B,(HL)			; Get First byte of name
01:9A33 CD6994          	  2187: GTFNAM: CALL	CHKLTR			; See if a letter
01:9A36 DA708F          	  2188: 		JP		C,SNERR			; ?SN Error if not a letter
01:9A39 AF              	  2189: 		XOR		A
01:9A3A 4F              	  2190: 		LD		C,A				; Clear second byte of name
01:9A3B 32AD10          	  2191: 		LD		(TYPE),A		; Set type to numeric
01:9A3E CDC893          	  2192: 		CALL	GETCHR			; Get next character
01:9A41 DA4A9A          	  2193: 		JP		C,SVNAM2		; Numeric - Save in name
01:9A44 CD6994          	  2194: 		CALL	CHKLTR			; See if a letter
01:9A47 DA579A          	  2195: 		JP		C,CHARTY		; Not a letter - Check type
01:9A4A 4F              	  2196: SVNAM2: LD		C,A				; Save second byte of name
01:9A4B CDC893          	  2197: ENDNAM: CALL	GETCHR			; Get next character
01:9A4E DA4B9A          	  2198: 		JP		C,ENDNAM		; Numeric - Get another
01:9A51 CD6994          	  2199: 		CALL	CHKLTR			; See if a letter
01:9A54 D24B9A          	  2200: 		JP		NC,ENDNAM		; Letter - Get another
01:9A57 D624            	  2201: CHARTY: SUB		'$'				; String variable?
01:9A59 C2669A          	  2202: 		JP		NZ,NOTSTR		; No - Numeric variable
01:9A5C 3C              	  2203: 		INC		A				; A = 1 (string type)
01:9A5D 32AD10          	  2204: 		LD		(TYPE),A		; Set type to string
01:9A60 0F              	  2205: 		RRCA					; A = 80H , Flag for string
01:9A61 81              	  2206: 		ADD		A,C				; 2nd byte of name has bit 7 on
01:9A62 4F              	  2207: 		LD		C,A				; Resave second byte on name
01:9A63 CDC893          	  2208: 		CALL	GETCHR			; Get next character
01:9A66 3ACB10          	  2209: NOTSTR: LD		A,(FORFLG)		; Array name needed ?
01:9A69 3D              	  2210: 		DEC		A
01:9A6A CA139B          	  2211: 		JP		Z,ARLDSV		; Yes - Get array name
01:9A6D F2769A          	  2212: 		JP		P,NSCFOR		; No array with "FOR" or "FN"
01:9A70 7E              	  2213: 		LD		A,(HL)			; Get byte again
01:9A71 D628            	  2214: 		SUB		'('				; Subscripted variable?
01:9A73 CAEB9A          	  2215: 		JP		Z,SBSCPT		; Yes - Sort out subscript
                        	  2216: 
01:9A76 AF              	  2217: NSCFOR: XOR		A				; Simple variable
01:9A77 32CB10          	  2218: 		LD		(FORFLG),A		; Clear "FOR" flag
01:9A7A E5              	  2219: 		PUSH	HL				; Save code string address
01:9A7B 50              	  2220: 		LD		D,B				; DE = Variable name to find
01:9A7C 59              	  2221: 		LD		E,C
01:9A7D 2ADE10          	  2222: 		LD		HL,(FNRGNM)		; FN argument name
01:9A80 CD3892          	  2223: 		CALL	CPDEHL			; Is it the FN argument?
01:9A83 11E010          	  2224: 		LD		DE,FNARG		; Point to argument value
01:9A86 CA5BA1          	  2225: 		JP		Z,POPHRT		; Yes - Return FN argument value
01:9A89 2AD810          	  2226: 		LD		HL,(VAREND)		; End of variables
01:9A8C EB              	  2227: 		EX		DE,HL			; Address of end of search
01:9A8D 2AD610          	  2228: 		LD		HL,(PROGND)		; Start of variables address
01:9A90 CD3892          	  2229: FNDVAR: CALL	CPDEHL			; End of variable list table?
01:9A93 CAA99A          	  2230: 		JP		Z,CFEVAL		; Yes - Called from EVAL?
01:9A96 79              	  2231: 		LD		A,C				; Get second byte of name
01:9A97 96              	  2232: 		SUB		(HL)			; Compare with name in list
01:9A98 23              	  2233: 		INC		HL				; Move on to first byte
01:9A99 C29E9A          	  2234: 		JP		NZ,FNTHR		; Different - Find another
01:9A9C 78              	  2235: 		LD		A,B				; Get first byte of name
01:9A9D 96              	  2236: 		SUB		(HL)			; Compare with name in list
01:9A9E 23              	  2237: FNTHR:	INC		HL				; Move on to LSB of value
01:9A9F CADD9A          	  2238: 		JP		Z,RETADR		; Found - Return address
01:9AA2 23              	  2239: 		INC		HL				; <- Skip
01:9AA3 23              	  2240: 		INC		HL				; <- over
01:9AA4 23              	  2241: 		INC		HL				; <- F.P.
01:9AA5 23              	  2242: 		INC		HL				; <- value
01:9AA6 C3909A          	  2243: 		JP		FNDVAR			; Keep looking
                        	  2244: 
01:9AA9 E1              	  2245: CFEVAL: POP		HL				; Restore code string address
01:9AAA E3              	  2246: 		EX		(SP),HL			; Get return address
01:9AAB D5              	  2247: 		PUSH	DE				; Save address of variable
01:9AAC 112B99          	  2248: 		LD		DE,FRMEVL		; Return address in EVAL
01:9AAF CD3892          	  2249: 		CALL	CPDEHL			; Called from EVAL ?
01:9AB2 D1              	  2250: 		POP		DE				; Restore address of variable
01:9AB3 CAE09A          	  2251: 		JP		Z,RETNUL		; Yes - Return null variable
01:9AB6 E3              	  2252: 		EX		(SP),HL			; Put back return
01:9AB7 E5              	  2253: 		PUSH	HL				; Save code string address
01:9AB8 C5              	  2254: 		PUSH	BC				; Save variable name
01:9AB9 010600          	  2255: 		LD		BC,6			; 2 byte name plus 4 byte data
01:9ABC 2ADA10          	  2256: 		LD		HL,(ARREND)		; End of arrays
01:9ABF E5              	  2257: 		PUSH	HL				; Save end of arrays
01:9AC0 09              	  2258: 		ADD		HL,BC			; Move up 6 bytes
01:9AC1 C1              	  2259: 		POP		BC				; Source address in BC
01:9AC2 E5              	  2260: 		PUSH	HL				; Save new end address
01:9AC3 CD3C8F          	  2261: 		CALL	MOVUP			; Move arrays up
01:9AC6 E1              	  2262: 		POP		HL				; Restore new end address
01:9AC7 22DA10          	  2263: 		LD		(ARREND),HL		; Set new end address
01:9ACA 60              	  2264: 		LD		H,B				; End of variables to HL
01:9ACB 69              	  2265: 		LD		L,C
01:9ACC 22D810          	  2266: 		LD		(VAREND),HL		; Set new end address
                        	  2267: 
01:9ACF 2B              	  2268: ZEROLP: DEC		HL				; Back through to zero variable
01:9AD0 3600            	  2269: 		LD		(HL),0			; Zero byte in variable
01:9AD2 CD3892          	  2270: 		CALL	CPDEHL			; Done them all?
01:9AD5 C2CF9A          	  2271: 		JP		NZ,ZEROLP		; No - Keep on going
01:9AD8 D1              	  2272: 		POP		DE				; Get variable name
01:9AD9 73              	  2273: 		LD		(HL),E			; Store second character
01:9ADA 23              	  2274: 		INC		HL
01:9ADB 72              	  2275: 		LD		(HL),D			; Store first character
01:9ADC 23              	  2276: 		INC		HL
01:9ADD EB              	  2277: RETADR: EX		DE,HL			; Address of variable in DE
01:9ADE E1              	  2278: 		POP		HL				; Restore code string address
01:9ADF C9              	  2279: 		RET
                        	  2280: 
01:9AE0 32E710          	  2281: RETNUL: LD		(FPEXP),A		; Set result to zero
01:9AE3 210C8F          	  2282: 		LD		HL,ZERBYT		; Also set a null string
01:9AE6 22E410          	  2283: 		LD		(FPREG),HL		; Save for EVAL
01:9AE9 E1              	  2284: 		POP		HL				; Restore code string address
01:9AEA C9              	  2285: 		RET
                        	  2286: 
01:9AEB E5              	  2287: SBSCPT: PUSH	HL				; Save code string address
01:9AEC 2AAC10          	  2288: 		LD		HL,(LCRFLG)		; Locate/Create and Type
01:9AEF E3              	  2289: 		EX		(SP),HL			; Save and get code string
01:9AF0 57              	  2290: 		LD		D,A				; Zero number of dimensions
01:9AF1 D5              	  2291: SCPTLP: PUSH	DE				; Save number of dimensions
01:9AF2 C5              	  2292: 		PUSH	BC				; Save array name
01:9AF3 CD7194          	  2293: 		CALL	FPSINT			; Get subscript (0-32767)
01:9AF6 C1              	  2294: 		POP		BC				; Restore array name
01:9AF7 F1              	  2295: 		POP		AF				; Get number of dimensions
01:9AF8 EB              	  2296: 		EX		DE,HL
01:9AF9 E3              	  2297: 		EX		(SP),HL			; Save subscript value
01:9AFA E5              	  2298: 		PUSH	HL				; Save LCRFLG and TYPE
01:9AFB EB              	  2299: 		EX		DE,HL
01:9AFC 3C              	  2300: 		INC		A				; Count dimensions
01:9AFD 57              	  2301: 		LD		D,A				; Save in D
01:9AFE 7E              	  2302: 		LD		A,(HL)			; Get next byte in code string
01:9AFF FE2C            	  2303: 		CP		','				; Comma (more to come)?
01:9B01 CAF19A          	  2304: 		JP		Z,SCPTLP		; Yes - More subscripts
01:9B04 CD3E92          	  2305: 		CALL	CHKSYN			; Make sure ")" follows
01:9B07 29              	  2306: 		db	   ")"
01:9B08 22D010          	  2307: 		LD		(NXTOPR),HL		; Save code string address
01:9B0B E1              	  2308: 		POP		HL				; Get LCRFLG and TYPE
01:9B0C 22AC10          	  2309: 		LD		(LCRFLG),HL		; Restore Locate/create & type
01:9B0F 1E00            	  2310: 		LD		E,0				; Flag not CSAVE* or CLOAD*
01:9B11 D5              	  2311: 		PUSH	DE				; Save number of dimensions (D)
01:9B12 11              	  2312: 		db	   11H			   ; Skip "PUSH HL" and "PUSH AF'
                        	  2313: 
01:9B13 E5              	  2314: ARLDSV: PUSH	HL				; Save code string address
01:9B14 F5              	  2315: 		PUSH	AF				; A = 00 , Flags set = Z,N
01:9B15 2AD810          	  2316: 		LD		HL,(VAREND)		; Start of arrays
01:9B18 3E              	  2317: 		db	   3EH			   ; Skip "ADD HL,DE"
01:9B19 19              	  2318: FNDARY: ADD		HL,DE			; Move to next array start
01:9B1A EB              	  2319: 		EX		DE,HL
01:9B1B 2ADA10          	  2320: 		LD		HL,(ARREND)		; End of arrays
01:9B1E EB              	  2321: 		EX		DE,HL			; Current array pointer
01:9B1F CD3892          	  2322: 		CALL	CPDEHL			; End of arrays found?
01:9B22 CA4B9B          	  2323: 		JP		Z,CREARY		; Yes - Create array
01:9B25 7E              	  2324: 		LD		A,(HL)			; Get second byte of name
01:9B26 B9              	  2325: 		CP		C				; Compare with name given
01:9B27 23              	  2326: 		INC		HL				; Move on
01:9B28 C22D9B          	  2327: 		JP		NZ,NXTARY		; Different - Find next array
01:9B2B 7E              	  2328: 		LD		A,(HL)			; Get first byte of name
01:9B2C B8              	  2329: 		CP		B				; Compare with name given
01:9B2D 23              	  2330: NXTARY: INC		HL				; Move on
01:9B2E 5E              	  2331: 		LD		E,(HL)			; Get LSB of next array address
01:9B2F 23              	  2332: 		INC		HL
01:9B30 56              	  2333: 		LD		D,(HL)			; Get MSB of next array address
01:9B31 23              	  2334: 		INC		HL
01:9B32 C2199B          	  2335: 		JP		NZ,FNDARY		; Not found - Keep looking
01:9B35 3AAC10          	  2336: 		LD		A,(LCRFLG)		; Found Locate or Create it?
01:9B38 B7              	  2337: 		OR		A
01:9B39 C2798F          	  2338: 		JP		NZ,DDERR		; Create - ?DD Error
01:9B3C F1              	  2339: 		POP		AF				; Locate - Get number of dim'ns
01:9B3D 44              	  2340: 		LD		B,H				; BC Points to array dim'ns
01:9B3E 4D              	  2341: 		LD		C,L
01:9B3F CA5BA1          	  2342: 		JP		Z,POPHRT		; Jump if array load/save
01:9B42 96              	  2343: 		SUB		(HL)			; Same number of dimensions?
01:9B43 CAA99B          	  2344: 		JP		Z,FINDEL		; Yes - Find element
01:9B46 1E10            	  2345: BSERR:	LD		E,BS			; ?BS Error
01:9B48 C3848F          	  2346: 		JP		ERROR			; Output error
                        	  2347: 
01:9B4B 110400          	  2348: CREARY: LD		DE,4			; 4 Bytes per entry
01:9B4E F1              	  2349: 		POP		AF				; Array to save or 0 dim'ns?
01:9B4F CA9294          	  2350: 		JP		Z,FCERR			; Yes - ?FC Error
01:9B52 71              	  2351: 		LD		(HL),C			; Save second byte of name
01:9B53 23              	  2352: 		INC		HL
01:9B54 70              	  2353: 		LD		(HL),B			; Save first byte of name
01:9B55 23              	  2354: 		INC		HL
01:9B56 4F              	  2355: 		LD		C,A				; Number of dimensions to C
01:9B57 CD4D8F          	  2356: 		CALL	CHKSTK			; Check if enough memory
01:9B5A 23              	  2357: 		INC		HL				; Point to number of dimensions
01:9B5B 23              	  2358: 		INC		HL
01:9B5C 22C510          	  2359: 		LD		(CUROPR),HL		; Save address of pointer
01:9B5F 71              	  2360: 		LD		(HL),C			; Set number of dimensions
01:9B60 23              	  2361: 		INC		HL
01:9B61 3AAC10          	  2362: 		LD		A,(LCRFLG)		; Locate of Create?
01:9B64 17              	  2363: 		RLA						; Carry set = Create
01:9B65 79              	  2364: 		LD		A,C				; Get number of dimensions
01:9B66 010B00          	  2365: CRARLP: LD		BC,10+1			; Default dimension size 10
01:9B69 D26E9B          	  2366: 		JP		NC,DEFSIZ		; Locate - Set default size
01:9B6C C1              	  2367: 		POP		BC				; Get specified dimension size
01:9B6D 03              	  2368: 		INC		BC				; Include zero element
01:9B6E 71              	  2369: DEFSIZ: LD		(HL),C			; Save LSB of dimension size
01:9B6F 23              	  2370: 		INC		HL
01:9B70 70              	  2371: 		LD		(HL),B			; Save MSB of dimension size
01:9B71 23              	  2372: 		INC		HL
01:9B72 F5              	  2373: 		PUSH	AF				; Save num' of dim'ns an status
01:9B73 E5              	  2374: 		PUSH	HL				; Save address of dim'n size
01:9B74 CD06A3          	  2375: 		CALL	MLDEBC			; Multiply DE by BC to find
01:9B77 EB              	  2376: 		EX		DE,HL			; amount of mem needed (to DE)
01:9B78 E1              	  2377: 		POP		HL				; Restore address of dimension
01:9B79 F1              	  2378: 		POP		AF				; Restore number of dimensions
01:9B7A 3D              	  2379: 		DEC		A				; Count them
01:9B7B C2669B          	  2380: 		JP		NZ,CRARLP		; Do next dimension if more
01:9B7E F5              	  2381: 		PUSH	AF				; Save locate/create flag
01:9B7F 42              	  2382: 		LD		B,D				; MSB of memory needed
01:9B80 4B              	  2383: 		LD		C,E				; LSB of memory needed
01:9B81 EB              	  2384: 		EX		DE,HL
01:9B82 19              	  2385: 		ADD		HL,DE			; Add bytes to array start
01:9B83 DA658F          	  2386: 		JP		C,OMERR			; Too big - Error
01:9B86 CD568F          	  2387: 		CALL	ENFMEM			; See if enough memory
01:9B89 22DA10          	  2388: 		LD		(ARREND),HL		; Save new end of array
                        	  2389: 
01:9B8C 2B              	  2390: ZERARY: DEC		HL				; Back through array data
01:9B8D 3600            	  2391: 		LD		(HL),0			; Set array element to zero
01:9B8F CD3892          	  2392: 		CALL	CPDEHL			; All elements zeroed?
01:9B92 C28C9B          	  2393: 		JP		NZ,ZERARY		; No - Keep on going
01:9B95 03              	  2394: 		INC		BC				; Number of bytes + 1
01:9B96 57              	  2395: 		LD		D,A				; A=0
01:9B97 2AC510          	  2396: 		LD		HL,(CUROPR)		; Get address of array
01:9B9A 5E              	  2397: 		LD		E,(HL)			; Number of dimensions
01:9B9B EB              	  2398: 		EX		DE,HL			; To HL
01:9B9C 29              	  2399: 		ADD		HL,HL			; Two bytes per dimension size
01:9B9D 09              	  2400: 		ADD		HL,BC			; Add number of bytes
01:9B9E EB              	  2401: 		EX		DE,HL			; Bytes needed to DE
01:9B9F 2B              	  2402: 		DEC		HL
01:9BA0 2B              	  2403: 		DEC		HL
01:9BA1 73              	  2404: 		LD		(HL),E			; Save LSB of bytes needed
01:9BA2 23              	  2405: 		INC		HL
01:9BA3 72              	  2406: 		LD		(HL),D			; Save MSB of bytes needed
01:9BA4 23              	  2407: 		INC		HL
01:9BA5 F1              	  2408: 		POP		AF				; Locate / Create?
01:9BA6 DACD9B          	  2409: 		JP		C,ENDDIM		; A is 0 , End if create
01:9BA9 47              	  2410: FINDEL: LD		B,A				; Find array element
01:9BAA 4F              	  2411: 		LD		C,A
01:9BAB 7E              	  2412: 		LD		A,(HL)			; Number of dimensions
01:9BAC 23              	  2413: 		INC		HL
01:9BAD 16              	  2414: 		db	   16H			   ; Skip "POP HL"
01:9BAE E1              	  2415: FNDELP: POP		HL				; Address of next dim' size
01:9BAF 5E              	  2416: 		LD		E,(HL)			; Get LSB of dim'n size
01:9BB0 23              	  2417: 		INC		HL
01:9BB1 56              	  2418: 		LD		D,(HL)			; Get MSB of dim'n size
01:9BB2 23              	  2419: 		INC		HL
01:9BB3 E3              	  2420: 		EX		(SP),HL			; Save address - Get index
01:9BB4 F5              	  2421: 		PUSH	AF				; Save number of dim'ns
01:9BB5 CD3892          	  2422: 		CALL	CPDEHL			; Dimension too large?
01:9BB8 D2469B          	  2423: 		JP		NC,BSERR		; Yes - ?BS Error
01:9BBB E5              	  2424: 		PUSH	HL				; Save index
01:9BBC CD06A3          	  2425: 		CALL	MLDEBC			; Multiply previous by size
01:9BBF D1              	  2426: 		POP		DE				; Index supplied to DE
01:9BC0 19              	  2427: 		ADD		HL,DE			; Add index to pointer
01:9BC1 F1              	  2428: 		POP		AF				; Number of dimensions
01:9BC2 3D              	  2429: 		DEC		A				; Count them
01:9BC3 44              	  2430: 		LD		B,H				; MSB of pointer
01:9BC4 4D              	  2431: 		LD		C,L				; LSB of pointer
01:9BC5 C2AE9B          	  2432: 		JP		NZ,FNDELP		; More - Keep going
01:9BC8 29              	  2433: 		ADD		HL,HL			; 4 Bytes per element
01:9BC9 29              	  2434: 		ADD		HL,HL
01:9BCA C1              	  2435: 		POP		BC				; Start of array
01:9BCB 09              	  2436: 		ADD		HL,BC			; Point to element
01:9BCC EB              	  2437: 		EX		DE,HL			; Address of element to DE
01:9BCD 2AD010          	  2438: ENDDIM: LD		HL,(NXTOPR)		; Got code string address
01:9BD0 C9              	  2439: 		RET
                        	  2440: 
01:9BD1 2ADA10          	  2441: FRE:	LD		HL,(ARREND)		; Start of free memory
01:9BD4 EB              	  2442: 		EX		DE,HL			; To DE
01:9BD5 210000          	  2443: 		LD		HL,0			; End of free memory
01:9BD8 39              	  2444: 		ADD		HL,SP			; Current stack value
01:9BD9 3AAD10          	  2445: 		LD		A,(TYPE)		; Dummy argument type
01:9BDC B7              	  2446: 		OR		A
01:9BDD CAED9B          	  2447: 		JP		Z,FRENUM		; Numeric - Free variable space
01:9BE0 CD549E          	  2448: 		CALL	GSTRCU			; Current string to pool
01:9BE3 CD549D          	  2449: 		CALL	GARBGE			; Garbage collection
01:9BE6 2A5A10          	  2450: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9BE9 EB              	  2451: 		EX		DE,HL			; To DE
01:9BEA 2AC310          	  2452: 		LD		HL,(STRBOT)		; Bottom of string space
01:9BED 7D              	  2453: FRENUM: LD		A,L				; Get LSB of end
01:9BEE 93              	  2454: 		SUB		E				; Subtract LSB of beginning
01:9BEF 4F              	  2455: 		LD		C,A				; Save difference if C
01:9BF0 7C              	  2456: 		LD		A,H				; Get MSB of end
01:9BF1 9A              	  2457: 		SBC		A,D				; Subtract MSB of beginning
01:9BF2 41              	  2458: ACPASS: LD		B,C				; Return integer AC
01:9BF3 50              	  2459: ABPASS: LD		D,B				; Return integer AB
01:9BF4 1E00            	  2460: 		LD		E,0
01:9BF6 21AD10          	  2461: 		LD		HL,TYPE			; Point to type
01:9BF9 73              	  2462: 		LD		(HL),E			; Set type to numeric
01:9BFA 0690            	  2463: 		LD		B,80H+16		; 16 bit integer
01:9BFC C331A2          	  2464: 		JP		RETINT			; Return the integr
                        	  2465: 
01:9BFF 3AAB10          	  2466: POS:	LD		A,(CURPOS)		; Get cursor position
01:9C02 47              	  2467: PASSA:	LD		B,A				; Put A into AB
01:9C03 AF              	  2468: 		XOR		A				; Zero A
01:9C04 C3F39B          	  2469: 		JP		ABPASS			; Return integer AB
                        	  2470: 
01:9C07 CD8A9C          	  2471: DEF:	CALL	CHEKFN			; Get "FN" and name
01:9C0A CD7C9C          	  2472: 		CALL	IDTEST			; Test for illegal direct
01:9C0D 016295          	  2473: 		LD		BC,DATAA			; To get next statement
01:9C10 C5              	  2474: 		PUSH	BC				; Save address for RETurn
01:9C11 D5              	  2475: 		PUSH	DE				; Save address of function ptr
01:9C12 CD3E92          	  2476: 		CALL	CHKSYN			; Make sure "(" follows
01:9C15 28              	  2477: 		db	   "("
01:9C16 CD2E9A          	  2478: 		CALL	GETVAR			; Get argument variable name
01:9C19 E5              	  2479: 		PUSH	HL				; Save code string address
01:9C1A EB              	  2480: 		EX		DE,HL			; Argument address to HL
01:9C1B 2B              	  2481: 		DEC		HL
01:9C1C 56              	  2482: 		LD		D,(HL)			; Get first byte of arg name
01:9C1D 2B              	  2483: 		DEC		HL
01:9C1E 5E              	  2484: 		LD		E,(HL)			; Get second byte of arg name
01:9C1F E1              	  2485: 		POP		HL				; Restore code string address
01:9C20 CD3B98          	  2486: 		CALL	TSTNUM			; Make sure numeric argument
01:9C23 CD3E92          	  2487: 		CALL	CHKSYN			; Make sure ")" follows
01:9C26 29              	  2488: 		db	   ")"
01:9C27 CD3E92          	  2489: 		CALL	CHKSYN			; Make sure "=" follows
01:9C2A B4              	  2490: 		db	   ZEQUAL		   ; "=" token
01:9C2B 44              	  2491: 		LD		B,H				; Code string address to BC
01:9C2C 4D              	  2492: 		LD		C,L
01:9C2D E3              	  2493: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C2E 71              	  2494: 		LD		(HL),C			; Save LSB of FN code string
01:9C2F 23              	  2495: 		INC		HL
01:9C30 70              	  2496: 		LD		(HL),B			; Save MSB of FN code string
01:9C31 C3C99C          	  2497: 		JP		SVSTAD			; Save address and do function
                        	  2498: 
01:9C34 CD8A9C          	  2499: DOFN:	CALL	CHEKFN			; Make sure FN follows
01:9C37 D5              	  2500: 		PUSH	DE				; Save function pointer address
01:9C38 CD0F99          	  2501: 		CALL	EVLPAR			; Evaluate expression in "()"
01:9C3B CD3B98          	  2502: 		CALL	TSTNUM			; Make sure numeric result
01:9C3E E3              	  2503: 		EX		(SP),HL			; Save code str , Get FN ptr
01:9C3F 5E              	  2504: 		LD		E,(HL)			; Get LSB of FN code string
01:9C40 23              	  2505: 		INC		HL
01:9C41 56              	  2506: 		LD		D,(HL)			; Get MSB of FN code string
01:9C42 23              	  2507: 		INC		HL
01:9C43 7A              	  2508: 		LD		A,D				; And function DEFined?
01:9C44 B3              	  2509: 		OR		E
01:9C45 CA7C8F          	  2510: 		JP		Z,UFERR			; No - ?UF Error
01:9C48 7E              	  2511: 		LD		A,(HL)			; Get LSB of argument address
01:9C49 23              	  2512: 		INC		HL
01:9C4A 66              	  2513: 		LD		H,(HL)			; Get MSB of argument address
01:9C4B 6F              	  2514: 		LD		L,A				; HL = Arg variable address
01:9C4C E5              	  2515: 		PUSH	HL				; Save it
01:9C4D 2ADE10          	  2516: 		LD		HL,(FNRGNM)		; Get old argument name
01:9C50 E3              	  2517: 		EX		(SP),HL ;		; Save old , Get new
01:9C51 22DE10          	  2518: 		LD		(FNRGNM),HL		; Set new argument name
01:9C54 2AE210          	  2519: 		LD		HL,(FNARG+2)	; Get LSB,NLSB of old arg value
01:9C57 E5              	  2520: 		PUSH	HL				; Save it
01:9C58 2AE010          	  2521: 		LD		HL,(FNARG)		; Get MSB,EXP of old arg value
01:9C5B E5              	  2522: 		PUSH	HL				; Save it
01:9C5C 21E010          	  2523: 		LD		HL,FNARG		; HL = Value of argument
01:9C5F D5              	  2524: 		PUSH	DE				; Save FN code string address
01:9C60 CD72A2          	  2525: 		CALL	FPTHL			; Move FPREG to argument
01:9C63 E1              	  2526: 		POP		HL				; Get FN code string address
01:9C64 CD3898          	  2527: 		CALL	GETNUM			; Get value from function
01:9C67 2B              	  2528: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9C68 CDC893          	  2529: 		CALL	GETCHR			; Get next character
01:9C6B C2708F          	  2530: 		JP		NZ,SNERR		; Bad character in FN - Error
01:9C6E E1              	  2531: 		POP		HL				; Get MSB,EXP of old arg
01:9C6F 22E010          	  2532: 		LD		(FNARG),HL		; Restore it
01:9C72 E1              	  2533: 		POP		HL				; Get LSB,NLSB of old arg
01:9C73 22E210          	  2534: 		LD		(FNARG+2),HL	; Restore it
01:9C76 E1              	  2535: 		POP		HL				; Get name of old arg
01:9C77 22DE10          	  2536: 		LD		(FNRGNM),HL		; Restore it
01:9C7A E1              	  2537: 		POP		HL				; Restore code string address
01:9C7B C9              	  2538: 		RET
                        	  2539: 
01:9C7C E5              	  2540: IDTEST: PUSH	HL				; Save code string address
01:9C7D 2A5C10          	  2541: 		LD		HL,(LINEAT)		; Get current line number
01:9C80 23              	  2542: 		INC		HL				; -1 means direct statement
01:9C81 7C              	  2543: 		LD		A,H
01:9C82 B5              	  2544: 		OR		L
01:9C83 E1              	  2545: 		POP		HL				; Restore code string address
01:9C84 C0              	  2546: 		RET		NZ				; Return if in program
01:9C85 1E16            	  2547: 		LD		E,ID			; ?ID Error
01:9C87 C3848F          	  2548: 		JP		ERROR
                        	  2549: 
01:9C8A CD3E92          	  2550: CHEKFN: CALL	CHKSYN			; Make sure FN follows
01:9C8D A7              	  2551: 		db	   ZFN			   ; "FN" token
01:9C8E 3E80            	  2552: 		LD		A,80H
01:9C90 32CB10          	  2553: 		LD		(FORFLG),A		; Flag FN name to find
01:9C93 B6              	  2554: 		OR		(HL)			; FN name has bit 7 set
01:9C94 47              	  2555: 		LD		B,A				; in first byte of name
01:9C95 CD339A          	  2556: 		CALL	GTFNAM			; Get FN name
01:9C98 C33B98          	  2557: 		JP		TSTNUM			; Make sure numeric function
                        	  2558: 
01:9C9B CD3B98          	  2559: STRR:	CALL	TSTNUM			; Make sure it's a number
01:9C9E CDBFA3          	  2560: 		CALL	NUMASC			; Turn number into text
01:9CA1 CDCF9C          	  2561: STR1:	CALL	CRTST			; Create string entry for it
01:9CA4 CD549E          	  2562: 		CALL	GSTRCU			; Current string to pool
01:9CA7 01AF9E          	  2563: 		LD		BC,TOPOOL		; Save in string pool
01:9CAA C5              	  2564: 		PUSH	BC				; Save address on stack
                        	  2565: 
01:9CAB 7E              	  2566: SAVSTR: LD		A,(HL)			; Get string length
01:9CAC 23              	  2567: 		INC		HL
01:9CAD 23              	  2568: 		INC		HL
01:9CAE E5              	  2569: 		PUSH	HL				; Save pointer to string
01:9CAF CD2A9D          	  2570: 		CALL	TESTR			; See if enough string space
01:9CB2 E1              	  2571: 		POP		HL				; Restore pointer to string
01:9CB3 4E              	  2572: 		LD		C,(HL)			; Get LSB of address
01:9CB4 23              	  2573: 		INC		HL
01:9CB5 46              	  2574: 		LD		B,(HL)			; Get MSB of address
01:9CB6 CDC39C          	  2575: 		CALL	CRTMST			; Create string entry
01:9CB9 E5              	  2576: 		PUSH	HL				; Save pointer to MSB of addr
01:9CBA 6F              	  2577: 		LD		L,A				; Length of string
01:9CBB CD479E          	  2578: 		CALL	TOSTRA			; Move to string area
01:9CBE D1              	  2579: 		POP		DE				; Restore pointer to MSB
01:9CBF C9              	  2580: 		RET
                        	  2581: 
01:9CC0 CD2A9D          	  2582: MKTMST: CALL	TESTR			; See if enough string space
01:9CC3 21BF10          	  2583: CRTMST: LD		HL,TMPSTR		; Temporary string
01:9CC6 E5              	  2584: 		PUSH	HL				; Save it
01:9CC7 77              	  2585: 		LD		(HL),A			; Save length of string
01:9CC8 23              	  2586: 		INC		HL
01:9CC9 23              	  2587: SVSTAD: INC		HL
01:9CCA 73              	  2588: 		LD		(HL),E			; Save LSB of address
01:9CCB 23              	  2589: 		INC		HL
01:9CCC 72              	  2590: 		LD		(HL),D			; Save MSB of address
01:9CCD E1              	  2591: 		POP		HL				; Restore pointer
01:9CCE C9              	  2592: 		RET
                        	  2593: 
01:9CCF 2B              	  2594: CRTST:	DEC		HL				; DEC - INCed after
01:9CD0 0622            	  2595: QTSTR:	LD		B,'"'			; Terminating quote "
01:9CD2 50              	  2596: 		LD		D,B				; Quote to D
01:9CD3 E5              	  2597: DTSTR:	PUSH	HL				; Save start
01:9CD4 0EFF            	  2598: 		LD		C,-1			; Set counter to -1
01:9CD6 23              	  2599: QTSTLP: INC		HL				; Move on
01:9CD7 7E              	  2600: 		LD		A,(HL)			; Get byte
01:9CD8 0C              	  2601: 		INC		C				; Count bytes
01:9CD9 B7              	  2602: 		OR		A				; End of line?
01:9CDA CAE59C          	  2603: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CDD BA              	  2604: 		CP		D				; Terminator D found?
01:9CDE CAE59C          	  2605: 		JP		Z,CRTSTE		; Yes - Create string entry
01:9CE1 B8              	  2606: 		CP		B				; Terminator B found?
01:9CE2 C2D69C          	  2607: 		JP		NZ,QTSTLP		; No - Keep looking
01:9CE5 FE22            	  2608: CRTSTE: CP		'"'				; End with '"'?
01:9CE7 CCC893          	  2609: 		CALL	Z,GETCHR		; Yes - Get next character
01:9CEA E3              	  2610: 		EX		(SP),HL			; Starting quote
01:9CEB 23              	  2611: 		INC		HL				; First byte of string
01:9CEC EB              	  2612: 		EX		DE,HL			; To DE
01:9CED 79              	  2613: 		LD		A,C				; Get length
01:9CEE CDC39C          	  2614: 		CALL	CRTMST			; Create string entry
01:9CF1 11BF10          	  2615: TSTOPL: LD		DE,TMPSTR		; Temporary string
01:9CF4 2AB110          	  2616: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9CF7 22E410          	  2617: 		LD		(FPREG),HL		; Save address of string ptr
01:9CFA 3E01            	  2618: 		LD		A,1
01:9CFC 32AD10          	  2619: 		LD		(TYPE),A		; Set type to string
01:9CFF CD75A2          	  2620: 		CALL	DETHL4			; Move string to pool
01:9D02 CD3892          	  2621: 		CALL	CPDEHL			; Out of string pool?
01:9D05 22B110          	  2622: 		LD		(TMSTPT),HL		; Save new pointer
01:9D08 E1              	  2623: 		POP		HL				; Restore code string address
01:9D09 7E              	  2624: 		LD		A,(HL)			; Get next code byte
01:9D0A C0              	  2625: 		RET		NZ				; Return if pool OK
01:9D0B 1E1E            	  2626: 		LD		E,ST			; ?ST Error
01:9D0D C3848F          	  2627: 		JP		ERROR			; String pool overflow
                        	  2628: 
01:9D10 23              	  2629: PRNUMS: INC		HL				; Skip leading space
01:9D11 CDCF9C          	  2630: PRS:	CALL	CRTST			; Create string entry for it
01:9D14 CD549E          	  2631: PRS1:	CALL	GSTRCU			; Current string to pool
01:9D17 CD69A2          	  2632: 		CALL	LOADFP			; Move string block to BCDE
01:9D1A 1C              	  2633: 		INC		E				; Length + 1
01:9D1B 1D              	  2634: PRSLP:	DEC		E				; Count characters
01:9D1C C8              	  2635: 		RET		Z				; End of string
01:9D1D 0A              	  2636: 		LD		A,(BC)			; Get byte to output
01:9D1E CD4992          	  2637: 		CALL	OUTC			; Output character in A
01:9D21 FE0D            	  2638: 		CP		CR				; Return?
01:9D23 CC7D96          	  2639: 		CALL	Z,DONULL		; Yes - Do nulls
01:9D26 03              	  2640: 		INC		BC				; Next byte in string
01:9D27 C31B9D          	  2641: 		JP		PRSLP			; More characters to output
                        	  2642: 
01:9D2A B7              	  2643: TESTR:	OR		A				; Test if enough room
01:9D2B 0E              	  2644: 		db	   0EH			   ; No garbage collection done
01:9D2C F1              	  2645: GRBDON: POP		AF				; Garbage collection done
01:9D2D F5              	  2646: 		PUSH	AF				; Save status
01:9D2E 2A5A10          	  2647: 		LD		HL,(STRSPC)		; Bottom of string space in use
01:9D31 EB              	  2648: 		EX		DE,HL			; To DE
01:9D32 2AC310          	  2649: 		LD		HL,(STRBOT)		; Bottom of string area
01:9D35 2F              	  2650: 		CPL						; Negate length (Top down)
01:9D36 4F              	  2651: 		LD		C,A				; -Length to BC
01:9D37 06FF            	  2652: 		LD		B,-1			; BC = -ve length of string
01:9D39 09              	  2653: 		ADD		HL,BC			; Add to bottom of space in use
01:9D3A 23              	  2654: 		INC		HL				; Plus one for 2's complement
01:9D3B CD3892          	  2655: 		CALL	CPDEHL			; Below string RAM area?
01:9D3E DA489D          	  2656: 		JP		C,TESTOS		; Tidy up if not done else err
01:9D41 22C310          	  2657: 		LD		(STRBOT),HL		; Save new bottom of area
01:9D44 23              	  2658: 		INC		HL				; Point to first byte of string
01:9D45 EB              	  2659: 		EX		DE,HL			; Address to DE
01:9D46 F1              	  2660: POPAF:	POP		AF				; Throw away status push
01:9D47 C9              	  2661: 		RET
                        	  2662: 
01:9D48 F1              	  2663: TESTOS: POP		AF				; Garbage collect been done?
01:9D49 1E1A            	  2664: 		LD		E,OS			; ?OS Error
01:9D4B CA848F          	  2665: 		JP		Z,ERROR			; Yes - Not enough string apace
01:9D4E BF              	  2666: 		CP		A				; Flag garbage collect done
01:9D4F F5              	  2667: 		PUSH	AF				; Save status
01:9D50 012C9D          	  2668: 		LD		BC,GRBDON		; Garbage collection done
01:9D53 C5              	  2669: 		PUSH	BC				; Save for RETurn
01:9D54 2AAF10          	  2670: GARBGE: LD		HL,(LSTRAM)		; Get end of RAM pointer
01:9D57 22C310          	  2671: GARBLP: LD		(STRBOT),HL		; Reset string pointer
01:9D5A 210000          	  2672: 		LD		HL,0
01:9D5D E5              	  2673: 		PUSH	HL				; Flag no string found
01:9D5E 2A5A10          	  2674: 		LD		HL,(STRSPC)		; Get bottom of string space
01:9D61 E5              	  2675: 		PUSH	HL				; Save bottom of string space
01:9D62 21B310          	  2676: 		LD		HL,TMSTPL		; Temporary string pool
01:9D65 EB              	  2677: GRBLP:	EX		DE,HL
01:9D66 2AB110          	  2678: 		LD		HL,(TMSTPT)		; Temporary string pool pointer
01:9D69 EB              	  2679: 		EX		DE,HL
01:9D6A CD3892          	  2680: 		CALL	CPDEHL			; Temporary string pool done?
01:9D6D 01659D          	  2681: 		LD		BC,GRBLP		; Loop until string pool done
01:9D70 C2B99D          	  2682: 		JP		NZ,STPOOL		; No - See if in string area
01:9D73 2AD610          	  2683: 		LD		HL,(PROGND)		; Start of simple variables
01:9D76 EB              	  2684: SMPVAR: EX		DE,HL
01:9D77 2AD810          	  2685: 		LD		HL,(VAREND)		; End of simple variables
01:9D7A EB              	  2686: 		EX		DE,HL
01:9D7B CD3892          	  2687: 		CALL	CPDEHL			; All simple strings done?
01:9D7E CA8C9D          	  2688: 		JP		Z,ARRLP			; Yes - Do string arrays
01:9D81 7E              	  2689: 		LD		A,(HL)			; Get type of variable
01:9D82 23              	  2690: 		INC		HL
01:9D83 23              	  2691: 		INC		HL
01:9D84 B7              	  2692: 		OR		A				; "S" flag set if string
01:9D85 CDBC9D          	  2693: 		CALL	STRADD			; See if string in string area
01:9D88 C3769D          	  2694: 		JP		SMPVAR			; Loop until simple ones done
                        	  2695: 
01:9D8B C1              	  2696: GNXARY: POP		BC				; Scrap address of this array
01:9D8C EB              	  2697: ARRLP:	EX		DE,HL
01:9D8D 2ADA10          	  2698: 		LD		HL,(ARREND)		; End of string arrays
01:9D90 EB              	  2699: 		EX		DE,HL
01:9D91 CD3892          	  2700: 		CALL	CPDEHL			; All string arrays done?
01:9D94 CAE29D          	  2701: 		JP		Z,SCNEND		; Yes - Move string if found
01:9D97 CD69A2          	  2702: 		CALL	LOADFP			; Get array name to BCDE
01:9D9A 7B              	  2703: 		LD		A,E				; Get type of array		
01:9D9B E5              	  2704: 		PUSH	HL				; Save address of num of dim'ns
01:9D9C 09              	  2705: 		ADD		HL,BC			; Start of next array
01:9D9D B7              	  2706: 		OR		A				; Test type of array
01:9D9E F28B9D          	  2707: 		JP		P,GNXARY		; Numeric array - Ignore it
01:9DA1 22C510          	  2708: 		LD		(CUROPR),HL		; Save address of next array
01:9DA4 E1              	  2709: 		POP		HL				; Get address of num of dim'ns
01:9DA5 4E              	  2710: 		LD		C,(HL)			; BC = Number of dimensions
01:9DA6 0600            	  2711: 		LD		B,0
01:9DA8 09              	  2712: 		ADD		HL,BC			; Two bytes per dimension size
01:9DA9 09              	  2713: 		ADD		HL,BC
01:9DAA 23              	  2714: 		INC		HL				; Plus one for number of dim'ns
01:9DAB EB              	  2715: GRBARY: EX		DE,HL
01:9DAC 2AC510          	  2716: 		LD		HL,(CUROPR)		; Get address of next array
01:9DAF EB              	  2717: 		EX		DE,HL
01:9DB0 CD3892          	  2718: 		CALL	CPDEHL			; Is this array finished?
01:9DB3 CA8C9D          	  2719: 		JP		Z,ARRLP			; Yes - Get next one
01:9DB6 01AB9D          	  2720: 		LD		BC,GRBARY		; Loop until array all done
01:9DB9 C5              	  2721: STPOOL: PUSH	BC				; Save return address
01:9DBA F680            	  2722: 		OR		80H				; Flag string type
01:9DBC 7E              	  2723: STRADD: LD		A,(HL)			; Get string length
01:9DBD 23              	  2724: 		INC		HL
01:9DBE 23              	  2725: 		INC		HL
01:9DBF 5E              	  2726: 		LD		E,(HL)			; Get LSB of string address
01:9DC0 23              	  2727: 		INC		HL
01:9DC1 56              	  2728: 		LD		D,(HL)			; Get MSB of string address
01:9DC2 23              	  2729: 		INC		HL
01:9DC3 F0              	  2730: 		RET		P				; Not a string - Return
01:9DC4 B7              	  2731: 		OR		A				; Set flags on string length
01:9DC5 C8              	  2732: 		RET		Z				; Null string - Return
01:9DC6 44              	  2733: 		LD		B,H				; Save variable pointer
01:9DC7 4D              	  2734: 		LD		C,L
01:9DC8 2AC310          	  2735: 		LD		HL,(STRBOT)		; Bottom of new area
01:9DCB CD3892          	  2736: 		CALL	CPDEHL			; String been done?
01:9DCE 60              	  2737: 		LD		H,B				; Restore variable pointer
01:9DCF 69              	  2738: 		LD		L,C
01:9DD0 D8              	  2739: 		RET		C				; String done - Ignore
01:9DD1 E1              	  2740: 		POP		HL				; Return address
01:9DD2 E3              	  2741: 		EX		(SP),HL			; Lowest available string area
01:9DD3 CD3892          	  2742: 		CALL	CPDEHL			; String within string area?
01:9DD6 E3              	  2743: 		EX		(SP),HL			; Lowest available string area
01:9DD7 E5              	  2744: 		PUSH	HL				; Re-save return address
01:9DD8 60              	  2745: 		LD		H,B				; Restore variable pointer
01:9DD9 69              	  2746: 		LD		L,C
01:9DDA D0              	  2747: 		RET		NC				; Outside string area - Ignore
01:9DDB C1              	  2748: 		POP		BC				; Get return , Throw 2 away
01:9DDC F1              	  2749: 		POP		AF				; 
01:9DDD F1              	  2750: 		POP		AF				; 
01:9DDE E5              	  2751: 		PUSH	HL				; Save variable pointer
01:9DDF D5              	  2752: 		PUSH	DE				; Save address of current
01:9DE0 C5              	  2753: 		PUSH	BC				; Put back return address
01:9DE1 C9              	  2754: 		RET						; Go to it
                        	  2755: 
01:9DE2 D1              	  2756: SCNEND: POP		DE				; Addresses of strings
01:9DE3 E1              	  2757: 		POP		HL				; 
01:9DE4 7D              	  2758: 		LD		A,L				; HL = 0 if no more to do
01:9DE5 B4              	  2759: 		OR		H
01:9DE6 C8              	  2760: 		RET		Z				; No more to do - Return
01:9DE7 2B              	  2761: 		DEC		HL
01:9DE8 46              	  2762: 		LD		B,(HL)			; MSB of address of string
01:9DE9 2B              	  2763: 		DEC		HL
01:9DEA 4E              	  2764: 		LD		C,(HL)			; LSB of address of string
01:9DEB E5              	  2765: 		PUSH	HL				; Save variable address
01:9DEC 2B              	  2766: 		DEC		HL
01:9DED 2B              	  2767: 		DEC		HL
01:9DEE 6E              	  2768: 		LD		L,(HL)			; HL = Length of string
01:9DEF 2600            	  2769: 		LD		H,0
01:9DF1 09              	  2770: 		ADD		HL,BC			; Address of end of string+1
01:9DF2 50              	  2771: 		LD		D,B				; String address to DE
01:9DF3 59              	  2772: 		LD		E,C
01:9DF4 2B              	  2773: 		DEC		HL				; Last byte in string
01:9DF5 44              	  2774: 		LD		B,H				; Address to BC
01:9DF6 4D              	  2775: 		LD		C,L
01:9DF7 2AC310          	  2776: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9DFA CD3F8F          	  2777: 		CALL	MOVSTR			; Move string to new address
01:9DFD E1              	  2778: 		POP		HL				; Restore variable address
01:9DFE 71              	  2779: 		LD		(HL),C			; Save new LSB of address
01:9DFF 23              	  2780: 		INC		HL
01:9E00 70              	  2781: 		LD		(HL),B			; Save new MSB of address
01:9E01 69              	  2782: 		LD		L,C				; Next string area+1 to HL
01:9E02 60              	  2783: 		LD		H,B
01:9E03 2B              	  2784: 		DEC		HL				; Next string area address
01:9E04 C3579D          	  2785: 		JP		GARBLP			; Look for more strings
                        	  2786: 
01:9E07 C5              	  2787: CONCAT: PUSH	BC				; Save prec' opr & code string
01:9E08 E5              	  2788: 		PUSH	HL				; 
01:9E09 2AE410          	  2789: 		LD		HL,(FPREG)		; Get first string
01:9E0C E3              	  2790: 		EX		(SP),HL			; Save first string
01:9E0D CDC198          	  2791: 		CALL	OPRND			; Get second string
01:9E10 E3              	  2792: 		EX		(SP),HL			; Restore first string
01:9E11 CD3C98          	  2793: 		CALL	TSTSTR			; Make sure it's a string
01:9E14 7E              	  2794: 		LD		A,(HL)			; Get length of second string
01:9E15 E5              	  2795: 		PUSH	HL				; Save first string
01:9E16 2AE410          	  2796: 		LD		HL,(FPREG)		; Get second string
01:9E19 E5              	  2797: 		PUSH	HL				; Save second string
01:9E1A 86              	  2798: 		ADD		A,(HL)			; Add length of second string
01:9E1B 1E1C            	  2799: 		LD		E,LS			; ?LS Error
01:9E1D DA848F          	  2800: 		JP		C,ERROR			; String too long - Error
01:9E20 CDC09C          	  2801: 		CALL	MKTMST			; Make temporary string
01:9E23 D1              	  2802: 		POP		DE				; Get second string to DE
01:9E24 CD589E          	  2803: 		CALL	GSTRDE			; Move to string pool if needed
01:9E27 E3              	  2804: 		EX		(SP),HL			; Get first string
01:9E28 CD579E          	  2805: 		CALL	GSTRHL			; Move to string pool if needed
01:9E2B E5              	  2806: 		PUSH	HL				; Save first string
01:9E2C 2AC110          	  2807: 		LD		HL,(TMPSTR+2)	; Temporary string address
01:9E2F EB              	  2808: 		EX		DE,HL			; To DE
01:9E30 CD3E9E          	  2809: 		CALL	SSTSA			; First string to string area
01:9E33 CD3E9E          	  2810: 		CALL	SSTSA			; Second string to string area
01:9E36 215698          	  2811: 		LD		HL,EVAL2		; Return to evaluation loop
01:9E39 E3              	  2812: 		EX		(SP),HL			; Save return,get code string
01:9E3A E5              	  2813: 		PUSH	HL				; Save code string address
01:9E3B C3F19C          	  2814: 		JP		TSTOPL			; To temporary string to pool
                        	  2815: 
01:9E3E E1              	  2816: SSTSA:	POP		HL				; Return address
01:9E3F E3              	  2817: 		EX		(SP),HL			; Get string block,save return
01:9E40 7E              	  2818: 		LD		A,(HL)			; Get length of string
01:9E41 23              	  2819: 		INC		HL
01:9E42 23              	  2820: 		INC		HL
01:9E43 4E              	  2821: 		LD		C,(HL)			; Get LSB of string address
01:9E44 23              	  2822: 		INC		HL
01:9E45 46              	  2823: 		LD		B,(HL)			; Get MSB of string address
01:9E46 6F              	  2824: 		LD		L,A				; Length to L
01:9E47 2C              	  2825: TOSTRA: INC		L				; INC - DECed after
01:9E48 2D              	  2826: TSALP:	DEC		L				; Count bytes moved
01:9E49 C8              	  2827: 		RET		Z				; End of string - Return
01:9E4A 0A              	  2828: 		LD		A,(BC)			; Get source
01:9E4B 12              	  2829: 		LD		(DE),A			; Save destination
01:9E4C 03              	  2830: 		INC		BC				; Next source
01:9E4D 13              	  2831: 		INC		DE				; Next destination
01:9E4E C3489E          	  2832: 		JP		TSALP			; Loop until string moved
                        	  2833: 
01:9E51 CD3C98          	  2834: GETSTR: CALL	TSTSTR			; Make sure it's a string
01:9E54 2AE410          	  2835: GSTRCU: LD		HL,(FPREG)		; Get current string
01:9E57 EB              	  2836: GSTRHL: EX		DE,HL			; Save DE
01:9E58 CD729E          	  2837: GSTRDE: CALL	BAKTMP			; Was it last tmp-str?
01:9E5B EB              	  2838: 		EX		DE,HL			; Restore DE
01:9E5C C0              	  2839: 		RET		NZ				; No - Return
01:9E5D D5              	  2840: 		PUSH	DE				; Save string
01:9E5E 50              	  2841: 		LD		D,B				; String block address to DE
01:9E5F 59              	  2842: 		LD		E,C
01:9E60 1B              	  2843: 		DEC		DE				; Point to length
01:9E61 4E              	  2844: 		LD		C,(HL)			; Get string length
01:9E62 2AC310          	  2845: 		LD		HL,(STRBOT)		; Current bottom of string area
01:9E65 CD3892          	  2846: 		CALL	CPDEHL			; Last one in string area?
01:9E68 C2709E          	  2847: 		JP		NZ,POPHL		; No - Return
01:9E6B 47              	  2848: 		LD		B,A				; Clear B (A=0)
01:9E6C 09              	  2849: 		ADD		HL,BC			; Remove string from str' area
01:9E6D 22C310          	  2850: 		LD		(STRBOT),HL		; Save new bottom of str' area
01:9E70 E1              	  2851: POPHL:	POP		HL				; Restore string
01:9E71 C9              	  2852: 		RET
                        	  2853: 
01:9E72 2AB110          	  2854: BAKTMP: LD		HL,(TMSTPT)		; Get temporary string pool top
01:9E75 2B              	  2855: 		DEC		HL				; Back
01:9E76 46              	  2856: 		LD		B,(HL)			; Get MSB of address
01:9E77 2B              	  2857: 		DEC		HL				; Back
01:9E78 4E              	  2858: 		LD		C,(HL)			; Get LSB of address
01:9E79 2B              	  2859: 		DEC		HL				; Back
01:9E7A 2B              	  2860: 		DEC		HL				; Back
01:9E7B CD3892          	  2861: 		CALL	CPDEHL			; String last in string pool?
01:9E7E C0              	  2862: 		RET		NZ				; Yes - Leave it
01:9E7F 22B110          	  2863: 		LD		(TMSTPT),HL		; Save new string pool top
01:9E82 C9              	  2864: 		RET
                        	  2865: 
01:9E83 01029C          	  2866: LEN:	LD		BC,PASSA		; To return integer A
01:9E86 C5              	  2867: 		PUSH	BC				; Save address
01:9E87 CD519E          	  2868: GETLEN: CALL	GETSTR			; Get string and its length
01:9E8A AF              	  2869: 		XOR		A
01:9E8B 57              	  2870: 		LD		D,A				; Clear D
01:9E8C 32AD10          	  2871: 		LD		(TYPE),A		; Set type to numeric
01:9E8F 7E              	  2872: 		LD		A,(HL)			; Get length of string
01:9E90 B7              	  2873: 		OR		A				; Set status flags
01:9E91 C9              	  2874: 		RET
                        	  2875: 
01:9E92 01029C          	  2876: ASCC:	LD		BC,PASSA		; To return integer A
01:9E95 C5              	  2877: 		PUSH	BC				; Save address
01:9E96 CD879E          	  2878: GTFLNM: CALL	GETLEN			; Get length of string
01:9E99 CA9294          	  2879: 		JP		Z,FCERR			; Null string - Error
01:9E9C 23              	  2880: 		INC		HL
01:9E9D 23              	  2881: 		INC		HL
01:9E9E 5E              	  2882: 		LD		E,(HL)			; Get LSB of address
01:9E9F 23              	  2883: 		INC		HL
01:9EA0 56              	  2884: 		LD		D,(HL)			; Get MSB of address
01:9EA1 1A              	  2885: 		LD		A,(DE)			; Get first byte of string
01:9EA2 C9              	  2886: 		RET
                        	  2887: 
01:9EA3 3E01            	  2888: CHR:	LD		A,1				; One character string
01:9EA5 CDC09C          	  2889: 		CALL	MKTMST			; Make a temporary string
01:9EA8 CD9C9F          	  2890: 		CALL	MAKINT			; Make it integer A
01:9EAB 2AC110          	  2891: 		LD		HL,(TMPSTR+2)	; Get address of string
01:9EAE 73              	  2892: 		LD		(HL),E			; Save character
01:9EAF C1              	  2893: TOPOOL: POP		BC				; Clean up stack
01:9EB0 C3F19C          	  2894: 		JP		TSTOPL			; Temporary string to pool
                        	  2895: 
01:9EB3 CD4C9F          	  2896: LEFT:	CALL	LFRGNM			; Get number and ending ")"
01:9EB6 AF              	  2897: 		XOR		A				; Start at first byte in string
01:9EB7 E3              	  2898: RIGHT1: EX		(SP),HL			; Save code string,Get string
01:9EB8 4F              	  2899: 		LD		C,A				; Starting position in string
01:9EB9 E5              	  2900: MID1:	PUSH	HL				; Save string block address
01:9EBA 7E              	  2901: 		LD		A,(HL)			; Get length of string
01:9EBB B8              	  2902: 		CP		B				; Compare with number given
01:9EBC DAC19E          	  2903: 		JP		C,ALLFOL		; All following bytes required
01:9EBF 78              	  2904: 		LD		A,B				; Get new length
01:9EC0 11              	  2905: 		db	   11H			   ; Skip "LD C,0"
01:9EC1 0E00            	  2906: ALLFOL: LD		C,0				; First byte of string
01:9EC3 C5              	  2907: 		PUSH	BC				; Save position in string
01:9EC4 CD2A9D          	  2908: 		CALL	TESTR			; See if enough string space
01:9EC7 C1              	  2909: 		POP		BC				; Get position in string
01:9EC8 E1              	  2910: 		POP		HL				; Restore string block address
01:9EC9 E5              	  2911: 		PUSH	HL				; And re-save it
01:9ECA 23              	  2912: 		INC		HL
01:9ECB 23              	  2913: 		INC		HL
01:9ECC 46              	  2914: 		LD		B,(HL)			; Get LSB of address
01:9ECD 23              	  2915: 		INC		HL
01:9ECE 66              	  2916: 		LD		H,(HL)			; Get MSB of address
01:9ECF 68              	  2917: 		LD		L,B				; HL = address of string
01:9ED0 0600            	  2918: 		LD		B,0				; BC = starting address
01:9ED2 09              	  2919: 		ADD		HL,BC			; Point to that byte
01:9ED3 44              	  2920: 		LD		B,H				; BC = source string
01:9ED4 4D              	  2921: 		LD		C,L
01:9ED5 CDC39C          	  2922: 		CALL	CRTMST			; Create a string entry
01:9ED8 6F              	  2923: 		LD		L,A				; Length of new string
01:9ED9 CD479E          	  2924: 		CALL	TOSTRA			; Move string to string area
01:9EDC D1              	  2925: 		POP		DE				; Clear stack
01:9EDD CD589E          	  2926: 		CALL	GSTRDE			; Move to string pool if needed
01:9EE0 C3F19C          	  2927: 		JP		TSTOPL			; Temporary string to pool
                        	  2928: 
01:9EE3 CD4C9F          	  2929: RIGHT:	CALL	LFRGNM			; Get number and ending ")"
01:9EE6 D1              	  2930: 		POP		DE				; Get string length
01:9EE7 D5              	  2931: 		PUSH	DE				; And re-save
01:9EE8 1A              	  2932: 		LD		A,(DE)			; Get length
01:9EE9 90              	  2933: 		SUB		B				; Move back N bytes
01:9EEA C3B79E          	  2934: 		JP		RIGHT1			; Go and get sub-string
                        	  2935: 
01:9EED EB              	  2936: MID:	EX		DE,HL			; Get code string address
01:9EEE 7E              	  2937: 		LD		A,(HL)			; Get next byte ',' or ")"
01:9EEF CD519F          	  2938: 		CALL	MIDNUM			; Get number supplied
01:9EF2 04              	  2939: 		INC		B				; Is it character zero?
01:9EF3 05              	  2940: 		DEC		B
01:9EF4 CA9294          	  2941: 		JP		Z,FCERR			; Yes - Error
01:9EF7 C5              	  2942: 		PUSH	BC				; Save starting position
01:9EF8 1EFF            	  2943: 		LD		E,255			; All of string
01:9EFA FE29            	  2944: 		CP		')'				; Any length given?
01:9EFC CA069F          	  2945: 		JP		Z,RSTSTR		; No - Rest of string
01:9EFF CD3E92          	  2946: 		CALL	CHKSYN			; Make sure ',' follows
01:9F02 2C              	  2947: 		db	   ','
01:9F03 CD999F          	  2948: 		CALL	GETINT			; Get integer 0-255
01:9F06 CD3E92          	  2949: RSTSTR: CALL	CHKSYN			; Make sure ")" follows
01:9F09 29              	  2950: 		db	   ")"
01:9F0A F1              	  2951: 		POP		AF				; Restore starting position
01:9F0B E3              	  2952: 		EX		(SP),HL			; Get string,8ave code string
01:9F0C 01B99E          	  2953: 		LD		BC,MID1			; Continuation of MID$ routine
01:9F0F C5              	  2954: 		PUSH	BC				; Save for return
01:9F10 3D              	  2955: 		DEC		A				; Starting position-1
01:9F11 BE              	  2956: 		CP		(HL)			; Compare with length
01:9F12 0600            	  2957: 		LD		B,0				; Zero bytes length
01:9F14 D0              	  2958: 		RET		NC				; Null string if start past end
01:9F15 4F              	  2959: 		LD		C,A				; Save starting position-1
01:9F16 7E              	  2960: 		LD		A,(HL)			; Get length of string
01:9F17 91              	  2961: 		SUB		C				; Subtract start
01:9F18 BB              	  2962: 		CP		E				; Enough string for it?
01:9F19 47              	  2963: 		LD		B,A				; Save maximum length available
01:9F1A D8              	  2964: 		RET		C				; Truncate string if needed
01:9F1B 43              	  2965: 		LD		B,E				; Set specified length
01:9F1C C9              	  2966: 		RET						; Go and create string
                        	  2967: 
01:9F1D CD879E          	  2968: VAL:	CALL	GETLEN			; Get length of string
01:9F20 CA3AA0          	  2969: 		JP		Z,RESZER		; Result zero
01:9F23 5F              	  2970: 		LD		E,A				; Save length
01:9F24 23              	  2971: 		INC		HL
01:9F25 23              	  2972: 		INC		HL
01:9F26 7E              	  2973: 		LD		A,(HL)			; Get LSB of address
01:9F27 23              	  2974: 		INC		HL
01:9F28 66              	  2975: 		LD		H,(HL)			; Get MSB of address
01:9F29 6F              	  2976: 		LD		L,A				; HL = String address
01:9F2A E5              	  2977: 		PUSH	HL				; Save string address
01:9F2B 19              	  2978: 		ADD		HL,DE
01:9F2C 46              	  2979: 		LD		B,(HL)			; Get end of string+1 byte
01:9F2D 72              	  2980: 		LD		(HL),D			; Zero it to terminate
01:9F2E E3              	  2981: 		EX		(SP),HL			; Save string end,get start
01:9F2F C5              	  2982: 		PUSH	BC				; Save end+1 byte
01:9F30 7E              	  2983: 		LD		A,(HL)			; Get starting byte
01:9F31 FE24            	  2984: 	CP	'$'		; Hex number indicated? [function added]
01:9F33 C23B9F          	  2985: 	JP	NZ,VAL1
01:9F36 CD65A7          	  2986: 	CALL	HEXTFP		; Convert Hex to FPREG
01:9F39 180D            	  2987: 	JR	VAL3
01:9F3B FE25            	  2988: VAL1:	CP	'%'		; Binary number indicated? [function added]
01:9F3D C2459F          	  2989: 	JP	NZ,VAL2
01:9F40 CDD5A7          	  2990: 	CALL	BINTFP		; Convert Bin to FPREG
01:9F43 1803            	  2991: 	JR	VAL3
01:9F45 CD21A3          	  2992: VAL2:	CALL	ASCTFP			; Convert ASCII string to FP
01:9F48 C1              	  2993: VAL3:	POP		BC				; Restore end+1 byte
01:9F49 E1              	  2994: 		POP		HL				; Restore end+1 address
01:9F4A 70              	  2995: 		LD		(HL),B			; Put back original byte
01:9F4B C9              	  2996: 		RET
                        	  2997: 
01:9F4C EB              	  2998: LFRGNM: EX		DE,HL			; Code string address to HL
01:9F4D CD3E92          	  2999: 		CALL	CHKSYN			; Make sure ")" follows
01:9F50 29              	  3000: 		db	   ")"
01:9F51 C1              	  3001: MIDNUM: POP		BC				; Get return address
01:9F52 D1              	  3002: 		POP		DE				; Get number supplied
01:9F53 C5              	  3003: 		PUSH	BC				; Re-save return address
01:9F54 43              	  3004: 		LD		B,E				; Number to B
01:9F55 C9              	  3005: 		RET
                        	  3006: 
01:9F56 CD9C9F          	  3007: INP:	CALL	MAKINT			; Make it integer A
01:9F59 323F10          	  3008: 		LD		(INPORT),A		; Set input port
01:9F5C CD3E10          	  3009: 		CALL	INPSUB			; Get input from port
01:9F5F C3029C          	  3010: 		JP		PASSA			; Return integer A
                        	  3011: 
01:9F62 CD869F          	  3012: POUT:	CALL	SETIO			; Set up port number
01:9F65 C30610          	  3013: 		JP		OUTSUB			; Output data and return
                        	  3014: 
01:9F68 CD869F          	  3015: WAIT:	CALL	SETIO			; Set up port number
01:9F6B F5              	  3016: 		PUSH	AF				; Save AND mask
01:9F6C 1E00            	  3017: 		LD		E,0				; Assume zero if none given
01:9F6E 2B              	  3018: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9F6F CDC893          	  3019: 		CALL	GETCHR			; Get next character
01:9F72 CA7C9F          	  3020: 		JP		Z,NOXOR			; No XOR byte given
01:9F75 CD3E92          	  3021: 		CALL	CHKSYN			; Make sure ',' follows
01:9F78 2C              	  3022: 		db	   ','
01:9F79 CD999F          	  3023: 		CALL	GETINT			; Get integer 0-255 to XOR with
01:9F7C C1              	  3024: NOXOR:	POP		BC				; Restore AND mask
01:9F7D CD3E10          	  3025: WAITLP: CALL	INPSUB			; Get input
01:9F80 AB              	  3026: 		XOR		E				; Flip selected bits
01:9F81 A0              	  3027: 		AND		B				; Result non-zero?
01:9F82 CA7D9F          	  3028: 		JP		Z,WAITLP		; No = keep waiting
01:9F85 C9              	  3029: 		RET
                        	  3030: 
01:9F86 CD999F          	  3031: SETIO:	CALL	GETINT			; Get integer 0-255
01:9F89 323F10          	  3032: 		LD		(INPORT),A		; Set input port
01:9F8C 320710          	  3033: 		LD		(OTPORT),A		; Set output port
01:9F8F CD3E92          	  3034: 		CALL	CHKSYN			; Make sure ',' follows
01:9F92 2C              	  3035: 		db	   ','
01:9F93 C3999F          	  3036: 		JP		GETINT			; Get integer 0-255 and return
                        	  3037: 
01:9F96 CDC893          	  3038: FNDNUM: CALL	GETCHR			; Get next character
01:9F99 CD3898          	  3039: GETINT: CALL	GETNUM			; Get a number from 0 to 255
01:9F9C CD7794          	  3040: MAKINT: CALL	DEPINT			; Make sure value 0 - 255
01:9F9F 7A              	  3041: 		LD		A,D				; Get MSB of number
01:9FA0 B7              	  3042: 		OR		A				; Zero?
01:9FA1 C29294          	  3043: 		JP		NZ,FCERR		; No - Error
01:9FA4 2B              	  3044: 		DEC		HL				; DEC 'cos GETCHR INCs
01:9FA5 CDC893          	  3045: 		CALL	GETCHR			; Get next character
01:9FA8 7B              	  3046: 		LD		A,E				; Get number to A
01:9FA9 C9              	  3047: 		RET
                        	  3048: 
01:9FAA CD7D94          	  3049: PEEK:	CALL	DEINT			; Get memory address
01:9FAD 1A              	  3050: 		LD		A,(DE)			; Get byte in memory
01:9FAE C3029C          	  3051: 		JP		PASSA			; Return integer A
                        	  3052: 
01:9FB1 CD3898          	  3053: POKE:	CALL	GETNUM			; Get memory address
01:9FB4 CD7D94          	  3054: 		CALL	DEINT			; Get integer -32768 to 3276
01:9FB7 D5              	  3055: 		PUSH	DE				; Save memory address
01:9FB8 CD3E92          	  3056: 		CALL	CHKSYN			; Make sure ',' follows
01:9FBB 2C              	  3057: 		db	   ','
01:9FBC CD999F          	  3058: 		CALL	GETINT			; Get integer 0-255
01:9FBF D1              	  3059: 		POP		DE				; Restore memory address
01:9FC0 12              	  3060: 		LD		(DE),A			; Load it into memory
01:9FC1 C9              	  3061: 		RET
                        	  3062: 
01:9FC2 2198A4          	  3063: ROUND:	LD		HL,HALF			; Add 0.5 to FPREG
01:9FC5 CD69A2          	  3064: ADDPHL: CALL	LOADFP			; Load FP at (HL) to BCDE
01:9FC8 C3D49F          	  3065: 		JP		FPADD			; Add BCDE to FPREG
                        	  3066: 
01:9FCB CD69A2          	  3067: SUBPHL: CALL	LOADFP			; FPREG = -FPREG + number at HL
01:9FCE 21              	  3068: 		db	   21H			   ; Skip "POP BC" and "POP DE"
01:9FCF C1              	  3069: PSUB:	POP		BC				; Get FP number from stack
01:9FD0 D1              	  3070: 		POP		DE
01:9FD1 CD43A2          	  3071: SUBCDE: CALL	INVSGN			; Negate FPREG
01:9FD4 78              	  3072: FPADD:	LD		A,B				; Get FP exponent
01:9FD5 B7              	  3073: 		OR		A				; Is number zero?
01:9FD6 C8              	  3074: 		RET		Z				; Yes - Nothing to add
01:9FD7 3AE710          	  3075: 		LD		A,(FPEXP)		; Get FPREG exponent
01:9FDA B7              	  3076: 		OR		A				; Is this number zero?
01:9FDB CA5BA2          	  3077: 		JP		Z,FPBCDE		; Yes - Move BCDE to FPREG
01:9FDE 90              	  3078: 		SUB		B				; BCDE number larger?
01:9FDF D2EE9F          	  3079: 		JP		NC,NOSWAP		; No - Don't swap them
01:9FE2 2F              	  3080: 		CPL						; Two's complement
01:9FE3 3C              	  3081: 		INC		A				;  FP exponent
01:9FE4 EB              	  3082: 		EX		DE,HL
01:9FE5 CD4BA2          	  3083: 		CALL	STAKFP			; Put FPREG on stack
01:9FE8 EB              	  3084: 		EX		DE,HL
01:9FE9 CD5BA2          	  3085: 		CALL	FPBCDE			; Move BCDE to FPREG
01:9FEC C1              	  3086: 		POP		BC				; Restore number from stack
01:9FED D1              	  3087: 		POP		DE
01:9FEE FE19            	  3088: NOSWAP: CP		24+1			; Second number insignificant?
01:9FF0 D0              	  3089: 		RET		NC				; Yes - First number is result
01:9FF1 F5              	  3090: 		PUSH	AF				; Save number of bits to scale
01:9FF2 CD80A2          	  3091: 		CALL	SIGNS			; Set MSBs & sign of result
01:9FF5 67              	  3092: 		LD		H,A				; Save sign of result
01:9FF6 F1              	  3093: 		POP		AF				; Restore scaling factor
01:9FF7 CD99A0          	  3094: 		CALL	SCALE			; Scale BCDE to same exponent
01:9FFA B4              	  3095: 		OR		H				; Result to be positive?
01:9FFB 21E410          	  3096: 		LD		HL,FPREG		; Point to FPREG
01:9FFE F214A0          	  3097: 		JP		P,MINCDE		; No - Subtract FPREG from CDE
01:A001 CD79A0          	  3098: 		CALL	PLUCDE			; Add FPREG to CDE
01:A004 D25AA0          	  3099: 		JP		NC,RONDUP		; No overflow - Round it up
01:A007 23              	  3100: 		INC		HL				; Point to exponent
01:A008 34              	  3101: 		INC		(HL)			; Increment it
01:A009 CA7F8F          	  3102: 		JP		Z,OVERR			; Number overflowed - Error
01:A00C 2E01            	  3103: 		LD		L,1				; 1 bit to shift right
01:A00E CDAFA0          	  3104: 		CALL	SHRT1			; Shift result right
01:A011 C35AA0          	  3105: 		JP		RONDUP			; Round it up
                        	  3106: 
01:A014 AF              	  3107: MINCDE: XOR		A				; Clear A and carry
01:A015 90              	  3108: 		SUB		B				; Negate exponent
01:A016 47              	  3109: 		LD		B,A				; Re-save exponent
01:A017 7E              	  3110: 		LD		A,(HL)			; Get LSB of FPREG
01:A018 9B              	  3111: 		SBC		A, E			; Subtract LSB of BCDE
01:A019 5F              	  3112: 		LD		E,A				; Save LSB of BCDE
01:A01A 23              	  3113: 		INC		HL
01:A01B 7E              	  3114: 		LD		A,(HL)			; Get NMSB of FPREG
01:A01C 9A              	  3115: 		SBC		A,D				; Subtract NMSB of BCDE
01:A01D 57              	  3116: 		LD		D,A				; Save NMSB of BCDE
01:A01E 23              	  3117: 		INC		HL
01:A01F 7E              	  3118: 		LD		A,(HL)			; Get MSB of FPREG
01:A020 99              	  3119: 		SBC		A,C				; Subtract MSB of BCDE
01:A021 4F              	  3120: 		LD		C,A				; Save MSB of BCDE
01:A022 DC85A0          	  3121: CONPOS: CALL	C,COMPL			; Overflow - Make it positive
                        	  3122: 
01:A025 68              	  3123: BNORM:	LD		L,B				; L = Exponent
01:A026 63              	  3124: 		LD		H,E				; H = LSB
01:A027 AF              	  3125: 		XOR		A
01:A028 47              	  3126: BNRMLP: LD		B,A				; Save bit count
01:A029 79              	  3127: 		LD		A,C				; Get MSB
01:A02A B7              	  3128: 		OR		A				; Is it zero?
01:A02B C247A0          	  3129: 		JP		NZ,PNORM		; No - Do it bit at a time
01:A02E 4A              	  3130: 		LD		C,D				; MSB = NMSB
01:A02F 54              	  3131: 		LD		D,H				; NMSB= LSB
01:A030 65              	  3132: 		LD		H,L				; LSB = VLSB
01:A031 6F              	  3133: 		LD		L,A				; VLSB= 0
01:A032 78              	  3134: 		LD		A,B				; Get exponent
01:A033 D608            	  3135: 		SUB		8				; Count 8 bits
01:A035 FEE0            	  3136: 		CP		-24-8			; Was number zero?
01:A037 C228A0          	  3137: 		JP		NZ,BNRMLP		; No - Keep normalising
01:A03A AF              	  3138: RESZER: XOR		A				; Result is zero
01:A03B 32E710          	  3139: SAVEXP: LD		(FPEXP),A		; Save result as zero
01:A03E C9              	  3140: 		RET
                        	  3141: 
01:A03F 05              	  3142: NORMAL: DEC		B				; Count bits
01:A040 29              	  3143: 		ADD		HL,HL			; Shift HL left
01:A041 7A              	  3144: 		LD		A,D				; Get NMSB
01:A042 17              	  3145: 		RLA						; Shift left with last bit
01:A043 57              	  3146: 		LD		D,A				; Save NMSB
01:A044 79              	  3147: 		LD		A,C				; Get MSB
01:A045 8F              	  3148: 		ADC		A,A				; Shift left with last bit
01:A046 4F              	  3149: 		LD		C,A				; Save MSB
01:A047 F23FA0          	  3150: PNORM:	JP		P,NORMAL		; Not done - Keep going
01:A04A 78              	  3151: 		LD		A,B				; Number of bits shifted
01:A04B 5C              	  3152: 		LD		E,H				; Save HL in EB
01:A04C 45              	  3153: 		LD		B,L
01:A04D B7              	  3154: 		OR		A				; Any shifting done?
01:A04E CA5AA0          	  3155: 		JP		Z,RONDUP		; No - Round it up
01:A051 21E710          	  3156: 		LD		HL,FPEXP		; Point to exponent
01:A054 86              	  3157: 		ADD		A,(HL)			; Add shifted bits
01:A055 77              	  3158: 		LD		(HL),A			; Re-save exponent
01:A056 D23AA0          	  3159: 		JP		NC,RESZER		; Underflow - Result is zero
01:A059 C8              	  3160: 		RET		Z				; Result is zero
01:A05A 78              	  3161: RONDUP: LD		A,B				; Get VLSB of number
01:A05B 21E710          	  3162: RONDB:	LD		HL,FPEXP		; Point to exponent
01:A05E B7              	  3163: 		OR		A				; Any rounding?
01:A05F FC6CA0          	  3164: 		CALL	M,FPROND		; Yes - Round number up
01:A062 46              	  3165: 		LD		B,(HL)			; B = Exponent
01:A063 23              	  3166: 		INC		HL
01:A064 7E              	  3167: 		LD		A,(HL)			; Get sign of result
01:A065 E680            	  3168: 		AND		10000000B		; Only bit 7 needed
01:A067 A9              	  3169: 		XOR		C				; Set correct sign
01:A068 4F              	  3170: 		LD		C,A				; Save correct sign in number
01:A069 C35BA2          	  3171: 		JP		FPBCDE			; Move BCDE to FPREG
                        	  3172: 
01:A06C 1C              	  3173: FPROND: INC		E				; Round LSB
01:A06D C0              	  3174: 		RET		NZ				; Return if ok
01:A06E 14              	  3175: 		INC		D				; Round NMSB
01:A06F C0              	  3176: 		RET		NZ				; Return if ok
01:A070 0C              	  3177: 		INC		C				; Round MSB
01:A071 C0              	  3178: 		RET		NZ				; Return if ok
01:A072 0E80            	  3179: 		LD		C,80H			; Set normal value
01:A074 34              	  3180: 		INC		(HL)			; Increment exponent
01:A075 C0              	  3181: 		RET		NZ				; Return if ok
01:A076 C37F8F          	  3182: 		JP		OVERR			; Overflow error
                        	  3183: 
01:A079 7E              	  3184: PLUCDE: LD		A,(HL)			; Get LSB of FPREG
01:A07A 83              	  3185: 		ADD		A,E				; Add LSB of BCDE
01:A07B 5F              	  3186: 		LD		E,A				; Save LSB of BCDE
01:A07C 23              	  3187: 		INC		HL
01:A07D 7E              	  3188: 		LD		A,(HL)			; Get NMSB of FPREG
01:A07E 8A              	  3189: 		ADC		A,D				; Add NMSB of BCDE
01:A07F 57              	  3190: 		LD		D,A				; Save NMSB of BCDE
01:A080 23              	  3191: 		INC		HL
01:A081 7E              	  3192: 		LD		A,(HL)			; Get MSB of FPREG
01:A082 89              	  3193: 		ADC		A,C				; Add MSB of BCDE
01:A083 4F              	  3194: 		LD		C,A				; Save MSB of BCDE
01:A084 C9              	  3195: 		RET
                        	  3196: 
01:A085 21E810          	  3197: COMPL:	LD		HL,SGNRES		; Sign of result
01:A088 7E              	  3198: 		LD		A,(HL)			; Get sign of result
01:A089 2F              	  3199: 		CPL						; Negate it
01:A08A 77              	  3200: 		LD		(HL),A			; Put it back
01:A08B AF              	  3201: 		XOR		A
01:A08C 6F              	  3202: 		LD		L,A				; Set L to zero
01:A08D 90              	  3203: 		SUB		B				; Negate exponent,set carry
01:A08E 47              	  3204: 		LD		B,A				; Re-save exponent
01:A08F 7D              	  3205: 		LD		A,L				; Load zero
01:A090 9B              	  3206: 		SBC		A,E				; Negate LSB
01:A091 5F              	  3207: 		LD		E,A				; Re-save LSB
01:A092 7D              	  3208: 		LD		A,L				; Load zero
01:A093 9A              	  3209: 		SBC		A,D				; Negate NMSB
01:A094 57              	  3210: 		LD		D,A				; Re-save NMSB
01:A095 7D              	  3211: 		LD		A,L				; Load zero
01:A096 99              	  3212: 		SBC		A,C				; Negate MSB
01:A097 4F              	  3213: 		LD		C,A				; Re-save MSB
01:A098 C9              	  3214: 		RET
                        	  3215: 
01:A099 0600            	  3216: SCALE:	LD		B,0				; Clear underflow
01:A09B D608            	  3217: SCALLP: SUB		8				; 8 bits (a whole byte)?
01:A09D DAA8A0          	  3218: 		JP		C,SHRITE		; No - Shift right A bits
01:A0A0 43              	  3219: 		LD		B,E				; <- Shift
01:A0A1 5A              	  3220: 		LD		E,D				; <- right
01:A0A2 51              	  3221: 		LD		D,C				; <- eight
01:A0A3 0E00            	  3222: 		LD		C,0				; <- bits
01:A0A5 C39BA0          	  3223: 		JP		SCALLP			; More bits to shift
                        	  3224: 
01:A0A8 C609            	  3225: SHRITE: ADD		A,8+1			; Adjust count
01:A0AA 6F              	  3226: 		LD		L,A				; Save bits to shift
01:A0AB AF              	  3227: SHRLP:	XOR		A				; Flag for all done
01:A0AC 2D              	  3228: 		DEC		L				; All shifting done?
01:A0AD C8              	  3229: 		RET		Z				; Yes - Return
01:A0AE 79              	  3230: 		LD		A,C				; Get MSB
01:A0AF 1F              	  3231: SHRT1:	RRA						; Shift it right
01:A0B0 4F              	  3232: 		LD		C,A				; Re-save
01:A0B1 7A              	  3233: 		LD		A,D				; Get NMSB
01:A0B2 1F              	  3234: 		RRA						; Shift right with last bit
01:A0B3 57              	  3235: 		LD		D,A				; Re-save it
01:A0B4 7B              	  3236: 		LD		A,E				; Get LSB
01:A0B5 1F              	  3237: 		RRA						; Shift right with last bit
01:A0B6 5F              	  3238: 		LD		E,A				; Re-save it
01:A0B7 78              	  3239: 		LD		A,B				; Get underflow
01:A0B8 1F              	  3240: 		RRA						; Shift right with last bit
01:A0B9 47              	  3241: 		LD		B,A				; Re-save underflow
01:A0BA C3ABA0          	  3242: 		JP		SHRLP			; More bits to do
                        	  3243: 
01:A0BD 00              	  3244: UNITY:	db		000H,000H,000H,081H	   ; 1.00000
01:A0BE 00
01:A0BF 00
01:A0C0 81
                        	  3245: 
01:A0C1 03              	  3246: LOGTAB: db	   3					   ; Table used by LOG
01:A0C2 AA              	  3247: 		db	   0AAH,056H,019H,080H	   ; 0.59898
01:A0C3 56
01:A0C4 19
01:A0C5 80
01:A0C6 F1              	  3248: 		db	   0F1H,022H,076H,080H	   ; 0.96147
01:A0C7 22
01:A0C8 76
01:A0C9 80
01:A0CA 45              	  3249: 		db	   045H,0AAH,038H,082H	   ; 2.88539
01:A0CB AA
01:A0CC 38
01:A0CD 82
                        	  3250: 
01:A0CE CD1AA2          	  3251: LOG:	CALL	TSTSGN			; Test sign of value
01:A0D1 B7              	  3252: 		OR		A
01:A0D2 EA9294          	  3253: 		JP		PE,FCERR		; ?FC Error if <= zero
01:A0D5 21E710          	  3254: 		LD		HL,FPEXP		; Point to exponent
01:A0D8 7E              	  3255: 		LD		A,(HL)			; Get exponent
01:A0D9 013580          	  3256: 		LD		BC,8035H		; BCDE = SQR(1/2)
01:A0DC 11F304          	  3257: 		LD		DE,04F3H
01:A0DF 90              	  3258: 		SUB		B				; Scale value to be < 1
01:A0E0 F5              	  3259: 		PUSH	AF				; Save scale factor
01:A0E1 70              	  3260: 		LD		(HL),B			; Save new exponent
01:A0E2 D5              	  3261: 		PUSH	DE				; Save SQR(1/2)
01:A0E3 C5              	  3262: 		PUSH	BC
01:A0E4 CDD49F          	  3263: 		CALL	FPADD			; Add SQR(1/2) to value
01:A0E7 C1              	  3264: 		POP		BC				; Restore SQR(1/2)
01:A0E8 D1              	  3265: 		POP		DE
01:A0E9 04              	  3266: 		INC		B				; Make it SQR(2)
01:A0EA CD70A1          	  3267: 		CALL	DVBCDE			; Divide by SQR(2)
01:A0ED 21BDA0          	  3268: 		LD		HL,UNITY		; Point to 1.
01:A0F0 CDCB9F          	  3269: 		CALL	SUBPHL			; Subtract FPREG from 1
01:A0F3 21C1A0          	  3270: 		LD		HL,LOGTAB		; Coefficient table
01:A0F6 CD62A5          	  3271: 		CALL	SUMSER			; Evaluate sum of series
01:A0F9 018080          	  3272: 		LD		BC,8080H		; BCDE = -0.5
01:A0FC 110000          	  3273: 		LD		DE,0000H
01:A0FF CDD49F          	  3274: 		CALL	FPADD			; Subtract 0.5 from FPREG
01:A102 F1              	  3275: 		POP		AF				; Restore scale factor
01:A103 CD95A3          	  3276: 		CALL	RSCALE			; Re-scale number
01:A106 013180          	  3277: MULLN2: LD		BC,8031H		; BCDE = Ln(2)
01:A109 111872          	  3278: 		LD		DE,7218H
01:A10C 21              	  3279: 		db	   21H			   ; Skip "POP BC" and "POP DE"
                        	  3280: 
01:A10D C1              	  3281: MULTT:	POP		BC				; Get number from stack
01:A10E D1              	  3282: 		POP		DE
01:A10F CD1AA2          	  3283: FPMULT: CALL	TSTSGN			; Test sign of FPREG
01:A112 C8              	  3284: 		RET		Z				; Return zero if zero
01:A113 2E00            	  3285: 		LD		L,0				; Flag add exponents
01:A115 CDD8A1          	  3286: 		CALL	ADDEXP			; Add exponents
01:A118 79              	  3287: 		LD		A,C				; Get MSB of multiplier
01:A119 32F610          	  3288: 		LD		(MULVAL),A		; Save MSB of multiplier
01:A11C EB              	  3289: 		EX		DE,HL
01:A11D 22F710          	  3290: 		LD		(MULVAL+1),HL	; Save rest of multiplier
01:A120 010000          	  3291: 		LD		BC,0			; Partial product (BCDE) = zero
01:A123 50              	  3292: 		LD		D,B
01:A124 58              	  3293: 		LD		E,B
01:A125 2125A0          	  3294: 		LD		HL,BNORM		; Address of normalise
01:A128 E5              	  3295: 		PUSH	HL				; Save for return
01:A129 2131A1          	  3296: 		LD		HL,MULT8		; Address of 8 bit multiply
01:A12C E5              	  3297: 		PUSH	HL				; Save for NMSB,MSB
01:A12D E5              	  3298: 		PUSH	HL				; 
01:A12E 21E410          	  3299: 		LD		HL,FPREG		; Point to number
01:A131 7E              	  3300: MULT8:	LD		A,(HL)			; Get LSB of number
01:A132 23              	  3301: 		INC		HL				; Point to NMSB
01:A133 B7              	  3302: 		OR		A				; Test LSB
01:A134 CA5DA1          	  3303: 		JP		Z,BYTSFT		; Zero - shift to next byte
01:A137 E5              	  3304: 		PUSH	HL				; Save address of number
01:A138 2E08            	  3305: 		LD		L,8				; 8 bits to multiply by
01:A13A 1F              	  3306: MUL8LP: RRA						; Shift LSB right
01:A13B 67              	  3307: 		LD		H,A				; Save LSB
01:A13C 79              	  3308: 		LD		A,C				; Get MSB
01:A13D D24BA1          	  3309: 		JP		NC,NOMADD		; Bit was zero - Don't add
01:A140 E5              	  3310: 		PUSH	HL				; Save LSB and count
01:A141 2AF710          	  3311: 		LD		HL,(MULVAL+1)	; Get LSB and NMSB
01:A144 19              	  3312: 		ADD		HL,DE			; Add NMSB and LSB
01:A145 EB              	  3313: 		EX		DE,HL			; Leave sum in DE
01:A146 E1              	  3314: 		POP		HL				; Restore MSB and count
01:A147 3AF610          	  3315: 		LD		A,(MULVAL)		; Get MSB of multiplier
01:A14A 89              	  3316: 		ADC		A,C				; Add MSB
01:A14B 1F              	  3317: NOMADD: RRA						; Shift MSB right
01:A14C 4F              	  3318: 		LD		C,A				; Re-save MSB
01:A14D 7A              	  3319: 		LD		A,D				; Get NMSB
01:A14E 1F              	  3320: 		RRA						; Shift NMSB right
01:A14F 57              	  3321: 		LD		D,A				; Re-save NMSB
01:A150 7B              	  3322: 		LD		A,E				; Get LSB
01:A151 1F              	  3323: 		RRA						; Shift LSB right
01:A152 5F              	  3324: 		LD		E,A				; Re-save LSB
01:A153 78              	  3325: 		LD		A,B				; Get VLSB
01:A154 1F              	  3326: 		RRA						; Shift VLSB right
01:A155 47              	  3327: 		LD		B,A				; Re-save VLSB
01:A156 2D              	  3328: 		DEC		L				; Count bits multiplied
01:A157 7C              	  3329: 		LD		A,H				; Get LSB of multiplier
01:A158 C23AA1          	  3330: 		JP		NZ,MUL8LP		; More - Do it
01:A15B E1              	  3331: POPHRT: POP		HL				; Restore address of number
01:A15C C9              	  3332: 		RET
                        	  3333: 
01:A15D 43              	  3334: BYTSFT: LD		B,E				; Shift partial product left
01:A15E 5A              	  3335: 		LD		E,D
01:A15F 51              	  3336: 		LD		D,C
01:A160 4F              	  3337: 		LD		C,A
01:A161 C9              	  3338: 		RET
                        	  3339: 
01:A162 CD4BA2          	  3340: DIV10:	CALL	STAKFP			; Save FPREG on stack
01:A165 012084          	  3341: 		LD		BC,8420H		; BCDE = 10.
01:A168 110000          	  3342: 		LD		DE,0000H
01:A16B CD5BA2          	  3343: 		CALL	FPBCDE			; Move 10 to FPREG
                        	  3344: 
01:A16E C1              	  3345: DIV:	POP		BC				; Get number from stack
01:A16F D1              	  3346: 		POP		DE
01:A170 CD1AA2          	  3347: DVBCDE: CALL	TSTSGN			; Test sign of FPREG
01:A173 CA738F          	  3348: 		JP		Z,DZERR			; Error if division by zero
01:A176 2EFF            	  3349: 		LD		L,-1			; Flag subtract exponents
01:A178 CDD8A1          	  3350: 		CALL	ADDEXP			; Subtract exponents
01:A17B 34              	  3351: 		INC		(HL)			; Add 2 to exponent to adjust
01:A17C 34              	  3352: 		INC		(HL)
01:A17D 2B              	  3353: 		DEC		HL				; Point to MSB
01:A17E 7E              	  3354: 		LD		A,(HL)			; Get MSB of dividend
01:A17F 321210          	  3355: 		LD		(DIV3),A		; Save for subtraction
01:A182 2B              	  3356: 		DEC		HL
01:A183 7E              	  3357: 		LD		A,(HL)			; Get NMSB of dividend
01:A184 320E10          	  3358: 		LD		(DIV2),A		; Save for subtraction
01:A187 2B              	  3359: 		DEC		HL
01:A188 7E              	  3360: 		LD		A,(HL)			; Get MSB of dividend
01:A189 320A10          	  3361: 		LD		(DIV1),A		; Save for subtraction
01:A18C 41              	  3362: 		LD		B,C				; Get MSB
01:A18D EB              	  3363: 		EX		DE,HL			; NMSB,LSB to HL
01:A18E AF              	  3364: 		XOR		A
01:A18F 4F              	  3365: 		LD		C,A				; Clear MSB of quotient
01:A190 57              	  3366: 		LD		D,A				; Clear NMSB of quotient
01:A191 5F              	  3367: 		LD		E,A				; Clear LSB of quotient
01:A192 321510          	  3368: 		LD		(DIV4),A		; Clear overflow count
01:A195 E5              	  3369: DIVLP:	PUSH	HL				; Save divisor
01:A196 C5              	  3370: 		PUSH	BC
01:A197 7D              	  3371: 		LD		A,L				; Get LSB of number
01:A198 CD0910          	  3372: 		CALL	DIVSUP			; Subt' divisor from dividend
01:A19B DE00            	  3373: 		SBC		A,0				; Count for overflows
01:A19D 3F              	  3374: 		CCF
01:A19E D2A8A1          	  3375: 		JP		NC,RESDIV		; Restore divisor if borrow
01:A1A1 321510          	  3376: 		LD		(DIV4),A		; Re-save overflow count
01:A1A4 F1              	  3377: 		POP		AF				; Scrap divisor
01:A1A5 F1              	  3378: 		POP		AF
01:A1A6 37              	  3379: 		SCF						; Set carry to
01:A1A7 D2              	  3380: 		db	   0D2H			   ; Skip "POP BC" and "POP HL"
                        	  3381: 
01:A1A8 C1              	  3382: RESDIV: POP		BC				; Restore divisor
01:A1A9 E1              	  3383: 		POP		HL
01:A1AA 79              	  3384: 		LD		A,C				; Get MSB of quotient
01:A1AB 3C              	  3385: 		INC		A
01:A1AC 3D              	  3386: 		DEC		A
01:A1AD 1F              	  3387: 		RRA						; Bit 0 to bit 7
01:A1AE FA5BA0          	  3388: 		JP		M,RONDB			; Done - Normalise result
01:A1B1 17              	  3389: 		RLA						; Restore carry
01:A1B2 7B              	  3390: 		LD		A,E				; Get LSB of quotient
01:A1B3 17              	  3391: 		RLA						; Double it
01:A1B4 5F              	  3392: 		LD		E,A				; Put it back
01:A1B5 7A              	  3393: 		LD		A,D				; Get NMSB of quotient
01:A1B6 17              	  3394: 		RLA						; Double it
01:A1B7 57              	  3395: 		LD		D,A				; Put it back
01:A1B8 79              	  3396: 		LD		A,C				; Get MSB of quotient
01:A1B9 17              	  3397: 		RLA						; Double it
01:A1BA 4F              	  3398: 		LD		C,A				; Put it back
01:A1BB 29              	  3399: 		ADD		HL,HL			; Double NMSB,LSB of divisor
01:A1BC 78              	  3400: 		LD		A,B				; Get MSB of divisor
01:A1BD 17              	  3401: 		RLA						; Double it
01:A1BE 47              	  3402: 		LD		B,A				; Put it back
01:A1BF 3A1510          	  3403: 		LD		A,(DIV4)		; Get VLSB of quotient
01:A1C2 17              	  3404: 		RLA						; Double it
01:A1C3 321510          	  3405: 		LD		(DIV4),A		; Put it back
01:A1C6 79              	  3406: 		LD		A,C				; Get MSB of quotient
01:A1C7 B2              	  3407: 		OR		D				; Merge NMSB
01:A1C8 B3              	  3408: 		OR		E				; Merge LSB
01:A1C9 C295A1          	  3409: 		JP		NZ,DIVLP		; Not done - Keep dividing
01:A1CC E5              	  3410: 		PUSH	HL				; Save divisor
01:A1CD 21E710          	  3411: 		LD		HL,FPEXP		; Point to exponent
01:A1D0 35              	  3412: 		DEC		(HL)			; Divide by 2
01:A1D1 E1              	  3413: 		POP		HL				; Restore divisor
01:A1D2 C295A1          	  3414: 		JP		NZ,DIVLP		; Ok - Keep going
01:A1D5 C37F8F          	  3415: 		JP		OVERR			; Overflow error
                        	  3416: 
01:A1D8 78              	  3417: ADDEXP: LD		A,B				; Get exponent of dividend
01:A1D9 B7              	  3418: 		OR		A				; Test it
01:A1DA CAFCA1          	  3419: 		JP		Z,OVTST3		; Zero - Result zero
01:A1DD 7D              	  3420: 		LD		A,L				; Get add/subtract flag
01:A1DE 21E710          	  3421: 		LD		HL,FPEXP		; Point to exponent
01:A1E1 AE              	  3422: 		XOR		(HL)			; Add or subtract it
01:A1E2 80              	  3423: 		ADD		A,B				; Add the other exponent
01:A1E3 47              	  3424: 		LD		B,A				; Save new exponent
01:A1E4 1F              	  3425: 		RRA						; Test exponent for overflow
01:A1E5 A8              	  3426: 		XOR		B
01:A1E6 78              	  3427: 		LD		A,B				; Get exponent
01:A1E7 F2FBA1          	  3428: 		JP		P,OVTST2		; Positive - Test for overflow
01:A1EA C680            	  3429: 		ADD		A,80H			; Add excess 128
01:A1EC 77              	  3430: 		LD		(HL),A			; Save new exponent
01:A1ED CA5BA1          	  3431: 		JP		Z,POPHRT		; Zero - Result zero
01:A1F0 CD80A2          	  3432: 		CALL	SIGNS			; Set MSBs and sign of result
01:A1F3 77              	  3433: 		LD		(HL),A			; Save new exponent
01:A1F4 2B              	  3434: 		DEC		HL				; Point to MSB
01:A1F5 C9              	  3435: 		RET
                        	  3436: 
01:A1F6 CD1AA2          	  3437: OVTST1: CALL	TSTSGN			; Test sign of FPREG
01:A1F9 2F              	  3438: 		CPL						; Invert sign
01:A1FA E1              	  3439: 		POP		HL				; Clean up stack
01:A1FB B7              	  3440: OVTST2: OR		A				; Test if new exponent zero
01:A1FC E1              	  3441: OVTST3: POP		HL				; Clear off return address
01:A1FD F23AA0          	  3442: 		JP		P,RESZER		; Result zero
01:A200 C37F8F          	  3443: 		JP		OVERR			; Overflow error
                        	  3444: 
01:A203 CD66A2          	  3445: MLSP10: CALL	BCDEFP			; Move FPREG to BCDE
01:A206 78              	  3446: 		LD		A,B				; Get exponent
01:A207 B7              	  3447: 		OR		A				; Is it zero?
01:A208 C8              	  3448: 		RET		Z				; Yes - Result is zero
01:A209 C602            	  3449: 		ADD		A,2				; Multiply by 4
01:A20B DA7F8F          	  3450: 		JP		C,OVERR			; Overflow - ?OV Error
01:A20E 47              	  3451: 		LD		B,A				; Re-save exponent
01:A20F CDD49F          	  3452: 		CALL	FPADD			; Add BCDE to FPREG (Times 5)
01:A212 21E710          	  3453: 		LD		HL,FPEXP		; Point to exponent
01:A215 34              	  3454: 		INC		(HL)			; Double number (Times 10)
01:A216 C0              	  3455: 		RET		NZ				; Ok - Return
01:A217 C37F8F          	  3456: 		JP		OVERR			; Overflow error
                        	  3457: 
01:A21A 3AE710          	  3458: TSTSGN: LD		A,(FPEXP)		; Get sign of FPREG
01:A21D B7              	  3459: 		OR		A
01:A21E C8              	  3460: 		RET		Z				; RETurn if number is zero
01:A21F 3AE610          	  3461: 		LD		A,(FPREG+2)		; Get MSB of FPREG
01:A222 FE              	  3462: 		db	   0FEH			   ; Test sign
01:A223 2F              	  3463: RETREL: CPL						; Invert sign
01:A224 17              	  3464: 		RLA						; Sign bit to carry
01:A225 9F              	  3465: FLGDIF: SBC		A,A				; Carry to all bits of A
01:A226 C0              	  3466: 		RET		NZ				; Return -1 if negative
01:A227 3C              	  3467: 		INC		A				; Bump to +1
01:A228 C9              	  3468: 		RET						; Positive - Return +1
                        	  3469: 
01:A229 CD1AA2          	  3470: SGN:	CALL	TSTSGN			; Test sign of FPREG
01:A22C 0688            	  3471: FLGREL: LD		B,80H+8			; 8 bit integer in exponent
01:A22E 110000          	  3472: 		LD		DE,0			; Zero NMSB and LSB
01:A231 21E710          	  3473: RETINT: LD		HL,FPEXP		; Point to exponent
01:A234 4F              	  3474: 		LD		C,A				; CDE = MSB,NMSB and LSB
01:A235 70              	  3475: 		LD		(HL),B			; Save exponent
01:A236 0600            	  3476: 		LD		B,0				; CDE = integer to normalise
01:A238 23              	  3477: 		INC		HL				; Point to sign of result
01:A239 3680            	  3478: 		LD		(HL),80H		; Set sign of result
01:A23B 17              	  3479: 		RLA						; Carry = sign of integer
01:A23C C322A0          	  3480: 		JP		CONPOS			; Set sign of result
                        	  3481: 
01:A23F CD1AA2          	  3482: ABS:	CALL	TSTSGN			; Test sign of FPREG
01:A242 F0              	  3483: 		RET		P				; Return if positive
01:A243 21E610          	  3484: INVSGN: LD		HL,FPREG+2		; Point to MSB
01:A246 7E              	  3485: 		LD		A,(HL)			; Get sign of mantissa
01:A247 EE80            	  3486: 		XOR		80H				; Invert sign of mantissa
01:A249 77              	  3487: 		LD		(HL),A			; Re-save sign of mantissa
01:A24A C9              	  3488: 		RET
                        	  3489: 
01:A24B EB              	  3490: STAKFP: EX		DE,HL			; Save code string address
01:A24C 2AE410          	  3491: 		LD		HL,(FPREG)		; LSB,NLSB of FPREG
01:A24F E3              	  3492: 		EX		(SP),HL			; Stack them,get return
01:A250 E5              	  3493: 		PUSH	HL				; Re-save return
01:A251 2AE610          	  3494: 		LD		HL,(FPREG+2)	; MSB and exponent of FPREG
01:A254 E3              	  3495: 		EX		(SP),HL			; Stack them,get return
01:A255 E5              	  3496: 		PUSH	HL				; Re-save return
01:A256 EB              	  3497: 		EX		DE,HL			; Restore code string address
01:A257 C9              	  3498: 		RET
                        	  3499: 
01:A258 CD69A2          	  3500: PHLTFP: CALL	LOADFP			; Number at HL to BCDE
01:A25B EB              	  3501: FPBCDE: EX		DE,HL			; Save code string address
01:A25C 22E410          	  3502: 		LD		(FPREG),HL		; Save LSB,NLSB of number
01:A25F 60              	  3503: 		LD		H,B				; Exponent of number
01:A260 69              	  3504: 		LD		L,C				; MSB of number
01:A261 22E610          	  3505: 		LD		(FPREG+2),HL	; Save MSB and exponent
01:A264 EB              	  3506: 		EX		DE,HL			; Restore code string address
01:A265 C9              	  3507: 		RET
                        	  3508: 
01:A266 21E410          	  3509: BCDEFP: LD		HL,FPREG		; Point to FPREG
01:A269 5E              	  3510: LOADFP: LD		E,(HL)			; Get LSB of number
01:A26A 23              	  3511: 		INC		HL
01:A26B 56              	  3512: 		LD		D,(HL)			; Get NMSB of number
01:A26C 23              	  3513: 		INC		HL
01:A26D 4E              	  3514: 		LD		C,(HL)			; Get MSB of number
01:A26E 23              	  3515: 		INC		HL
01:A26F 46              	  3516: 		LD		B,(HL)			; Get exponent of number
01:A270 23              	  3517: INCHL:	INC		HL				; Used for conditional "INC HL"
01:A271 C9              	  3518: 		RET
                        	  3519: 
01:A272 11E410          	  3520: FPTHL:	LD		DE,FPREG		; Point to FPREG
01:A275 0604            	  3521: DETHL4: LD		B,4				; 4 bytes to move
01:A277 1A              	  3522: DETHLB: LD		A,(DE)			; Get source
01:A278 77              	  3523: 		LD		(HL),A			; Save destination
01:A279 13              	  3524: 		INC		DE				; Next source
01:A27A 23              	  3525: 		INC		HL				; Next destination
01:A27B 05              	  3526: 		DEC		B				; Count bytes
01:A27C C277A2          	  3527: 		JP		NZ,DETHLB		; Loop if more
01:A27F C9              	  3528: 		RET
                        	  3529: 
01:A280 21E610          	  3530: SIGNS:	LD		HL,FPREG+2		; Point to MSB of FPREG
01:A283 7E              	  3531: 		LD		A,(HL)			; Get MSB
01:A284 07              	  3532: 		RLCA					; Old sign to carry
01:A285 37              	  3533: 		SCF						; Set MSBit
01:A286 1F              	  3534: 		RRA						; Set MSBit of MSB
01:A287 77              	  3535: 		LD		(HL),A			; Save new MSB
01:A288 3F              	  3536: 		CCF						; Complement sign
01:A289 1F              	  3537: 		RRA						; Old sign to carry
01:A28A 23              	  3538: 		INC		HL
01:A28B 23              	  3539: 		INC		HL
01:A28C 77              	  3540: 		LD		(HL),A			; Set sign of result
01:A28D 79              	  3541: 		LD		A,C				; Get MSB
01:A28E 07              	  3542: 		RLCA					; Old sign to carry
01:A28F 37              	  3543: 		SCF						; Set MSBit
01:A290 1F              	  3544: 		RRA						; Set MSBit of MSB
01:A291 4F              	  3545: 		LD		C,A				; Save MSB
01:A292 1F              	  3546: 		RRA
01:A293 AE              	  3547: 		XOR		(HL)			; New sign of result
01:A294 C9              	  3548: 		RET
                        	  3549: 
01:A295 78              	  3550: CMPNUM: LD		A,B				; Get exponent of number
01:A296 B7              	  3551: 		OR		A
01:A297 CA1AA2          	  3552: 		JP		Z,TSTSGN		; Zero - Test sign of FPREG
01:A29A 2123A2          	  3553: 		LD		HL,RETREL		; Return relation routine
01:A29D E5              	  3554: 		PUSH	HL				; Save for return
01:A29E CD1AA2          	  3555: 		CALL	TSTSGN			; Test sign of FPREG
01:A2A1 79              	  3556: 		LD		A,C				; Get MSB of number
01:A2A2 C8              	  3557: 		RET		Z				; FPREG zero - Number's MSB
01:A2A3 21E610          	  3558: 		LD		HL,FPREG+2		; MSB of FPREG
01:A2A6 AE              	  3559: 		XOR		(HL)			; Combine signs
01:A2A7 79              	  3560: 		LD		A,C				; Get MSB of number
01:A2A8 F8              	  3561: 		RET		M				; Exit if signs different
01:A2A9 CDAFA2          	  3562: 		CALL	CMPFP			; Compare FP numbers
01:A2AC 1F              	  3563: 		RRA						; Get carry to sign
01:A2AD A9              	  3564: 		XOR		C				; Combine with MSB of number
01:A2AE C9              	  3565: 		RET
                        	  3566: 
01:A2AF 23              	  3567: CMPFP:	INC		HL				; Point to exponent
01:A2B0 78              	  3568: 		LD		A,B				; Get exponent
01:A2B1 BE              	  3569: 		CP		(HL)			; Compare exponents
01:A2B2 C0              	  3570: 		RET		NZ				; Different
01:A2B3 2B              	  3571: 		DEC		HL				; Point to MBS
01:A2B4 79              	  3572: 		LD		A,C				; Get MSB
01:A2B5 BE              	  3573: 		CP		(HL)			; Compare MSBs
01:A2B6 C0              	  3574: 		RET		NZ				; Different
01:A2B7 2B              	  3575: 		DEC		HL				; Point to NMSB
01:A2B8 7A              	  3576: 		LD		A,D				; Get NMSB
01:A2B9 BE              	  3577: 		CP		(HL)			; Compare NMSBs
01:A2BA C0              	  3578: 		RET		NZ				; Different
01:A2BB 2B              	  3579: 		DEC		HL				; Point to LSB
01:A2BC 7B              	  3580: 		LD		A,E				; Get LSB
01:A2BD 96              	  3581: 		SUB		(HL)			; Compare LSBs
01:A2BE C0              	  3582: 		RET		NZ				; Different
01:A2BF E1              	  3583: 		POP		HL				; Drop RETurn
01:A2C0 E1              	  3584: 		POP		HL				; Drop another RETurn
01:A2C1 C9              	  3585: 		RET
                        	  3586: 
01:A2C2 47              	  3587: FPINT:	LD		B,A				; <- Move
01:A2C3 4F              	  3588: 		LD		C,A				; <- exponent
01:A2C4 57              	  3589: 		LD		D,A				; <- to all
01:A2C5 5F              	  3590: 		LD		E,A				; <- bits
01:A2C6 B7              	  3591: 		OR		A				; Test exponent
01:A2C7 C8              	  3592: 		RET		Z				; Zero - Return zero
01:A2C8 E5              	  3593: 		PUSH	HL				; Save pointer to number
01:A2C9 CD66A2          	  3594: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A2CC CD80A2          	  3595: 		CALL	SIGNS			; Set MSBs & sign of result
01:A2CF AE              	  3596: 		XOR		(HL)			; Combine with sign of FPREG
01:A2D0 67              	  3597: 		LD		H,A				; Save combined signs
01:A2D1 FCE6A2          	  3598: 		CALL	M,DCBCDE		; Negative - Decrement BCDE
01:A2D4 3E98            	  3599: 		LD		A,80H+24		; 24 bits
01:A2D6 90              	  3600: 		SUB		B				; Bits to shift
01:A2D7 CD99A0          	  3601: 		CALL	SCALE			; Shift BCDE
01:A2DA 7C              	  3602: 		LD		A,H				; Get combined sign
01:A2DB 17              	  3603: 		RLA						; Sign to carry
01:A2DC DC6CA0          	  3604: 		CALL	C,FPROND		; Negative - Round number up
01:A2DF 0600            	  3605: 		LD		B,0				; Zero exponent
01:A2E1 DC85A0          	  3606: 		CALL	C,COMPL			; If negative make positive
01:A2E4 E1              	  3607: 		POP		HL				; Restore pointer to number
01:A2E5 C9              	  3608: 		RET
                        	  3609: 
01:A2E6 1B              	  3610: DCBCDE: DEC		DE				; Decrement BCDE
01:A2E7 7A              	  3611: 		LD		A,D				; Test LSBs
01:A2E8 A3              	  3612: 		AND		E
01:A2E9 3C              	  3613: 		INC		A
01:A2EA C0              	  3614: 		RET		NZ				; Exit if LSBs not FFFF
01:A2EB 0B              	  3615: 		DEC		BC				; Decrement MSBs
01:A2EC C9              	  3616: 		RET
                        	  3617: 
01:A2ED 21E710          	  3618: INT:	LD		HL,FPEXP		; Point to exponent
01:A2F0 7E              	  3619: 		LD		A,(HL)			; Get exponent
01:A2F1 FE98            	  3620: 		CP		80H+24			; Integer accuracy only?
01:A2F3 3AE410          	  3621: 		LD		A,(FPREG)		; Get LSB
01:A2F6 D0              	  3622: 		RET		NC				; Yes - Already integer
01:A2F7 7E              	  3623: 		LD		A,(HL)			; Get exponent
01:A2F8 CDC2A2          	  3624: 		CALL	FPINT			; F.P to integer
01:A2FB 3698            	  3625: 		LD		(HL),80H+24		; Save 24 bit integer
01:A2FD 7B              	  3626: 		LD		A,E				; Get LSB of number
01:A2FE F5              	  3627: 		PUSH	AF				; Save LSB
01:A2FF 79              	  3628: 		LD		A,C				; Get MSB of number
01:A300 17              	  3629: 		RLA						; Sign to carry
01:A301 CD22A0          	  3630: 		CALL	CONPOS			; Set sign of result
01:A304 F1              	  3631: 		POP		AF				; Restore LSB of number
01:A305 C9              	  3632: 		RET
                        	  3633: 
01:A306 210000          	  3634: MLDEBC: LD		HL,0			; Clear partial product
01:A309 78              	  3635: 		LD		A,B				; Test multiplier
01:A30A B1              	  3636: 		OR		C
01:A30B C8              	  3637: 		RET		Z				; Return zero if zero
01:A30C 3E10            	  3638: 		LD		A,16			; 16 bits
01:A30E 29              	  3639: MLDBLP: ADD		HL,HL			; Shift P.P left
01:A30F DA469B          	  3640: 		JP		C,BSERR			; ?BS Error if overflow
01:A312 EB              	  3641: 		EX		DE,HL
01:A313 29              	  3642: 		ADD		HL,HL			; Shift multiplier left
01:A314 EB              	  3643: 		EX		DE,HL
01:A315 D21CA3          	  3644: 		JP		NC,NOMLAD		; Bit was zero - No add
01:A318 09              	  3645: 		ADD		HL,BC			; Add multiplicand
01:A319 DA469B          	  3646: 		JP		C,BSERR			; ?BS Error if overflow
01:A31C 3D              	  3647: NOMLAD: DEC		A				; Count bits
01:A31D C20EA3          	  3648: 		JP		NZ,MLDBLP		; More
01:A320 C9              	  3649: 		RET
                        	  3650: 
01:A321 FE2D            	  3651: ASCTFP: CP		'-'				; Negative?
01:A323 F5              	  3652: 		PUSH	AF				; Save it and flags
01:A324 CA2DA3          	  3653: 		JP		Z,CNVNUM		; Yes - Convert number
01:A327 FE2B            	  3654: 		CP		'+'				; Positive?
01:A329 CA2DA3          	  3655: 		JP		Z,CNVNUM		; Yes - Convert number
01:A32C 2B              	  3656: 		DEC		HL				; DEC 'cos GETCHR INCs
01:A32D CD3AA0          	  3657: CNVNUM: CALL	RESZER			; Set result to zero
01:A330 47              	  3658: 		LD		B,A				; Digits after point counter
01:A331 57              	  3659: 		LD		D,A				; Sign of exponent
01:A332 5F              	  3660: 		LD		E,A				; Exponent of ten
01:A333 2F              	  3661: 		CPL
01:A334 4F              	  3662: 		LD		C,A				; Before or after point flag
01:A335 CDC893          	  3663: MANLP:	CALL	GETCHR			; Get next character
01:A338 DA7EA3          	  3664: 		JP		C,ADDIG			; Digit - Add to number
01:A33B FE2E            	  3665: 		CP		'.'
01:A33D CA59A3          	  3666: 		JP		Z,DPOINT		; '.' - Flag point
01:A340 FE45            	  3667: 		CP		'E'
01:A342 C25DA3          	  3668: 		JP		NZ,CONEXP		; Not 'E' - Scale number
01:A345 CDC893          	  3669: 		CALL	GETCHR			; Get next character
01:A348 CD7199          	  3670: 		CALL	SGNEXP			; Get sign of exponent
01:A34B CDC893          	  3671: EXPLP:	CALL	GETCHR			; Get next character
01:A34E DAA0A3          	  3672: 		JP		C,EDIGIT		; Digit - Add to exponent
01:A351 14              	  3673: 		INC		D				; Is sign negative?
01:A352 C25DA3          	  3674: 		JP		NZ,CONEXP		; No - Scale number
01:A355 AF              	  3675: 		XOR		A
01:A356 93              	  3676: 		SUB		E				; Negate exponent
01:A357 5F              	  3677: 		LD		E,A				; And re-save it
01:A358 0C              	  3678: 		INC		C				; Flag end of number
01:A359 0C              	  3679: DPOINT: INC		C				; Flag point passed
01:A35A CA35A3          	  3680: 		JP		Z,MANLP			; Zero - Get another digit
01:A35D E5              	  3681: CONEXP: PUSH	HL				; Save code string address
01:A35E 7B              	  3682: 		LD		A,E				; Get exponent
01:A35F 90              	  3683: 		SUB		B				; Subtract digits after point
01:A360 F476A3          	  3684: SCALMI: CALL	P,SCALPL		; Positive - Multiply number
01:A363 F26CA3          	  3685: 		JP		P,ENDCON		; Positive - All done
01:A366 F5              	  3686: 		PUSH	AF				; Save number of times to /10
01:A367 CD62A1          	  3687: 		CALL	DIV10			; Divide by 10
01:A36A F1              	  3688: 		POP		AF				; Restore count
01:A36B 3C              	  3689: 		INC		A				; Count divides
                        	  3690: 
01:A36C C260A3          	  3691: ENDCON: JP		NZ,SCALMI		; More to do
01:A36F D1              	  3692: 		POP		DE				; Restore code string address
01:A370 F1              	  3693: 		POP		AF				; Restore sign of number
01:A371 CC43A2          	  3694: 		CALL	Z,INVSGN		; Negative - Negate number
01:A374 EB              	  3695: 		EX		DE,HL			; Code string address to HL
01:A375 C9              	  3696: 		RET
                        	  3697: 
01:A376 C8              	  3698: SCALPL: RET		Z				; Exit if no scaling needed
01:A377 F5              	  3699: MULTEN: PUSH	AF				; Save count
01:A378 CD03A2          	  3700: 		CALL	MLSP10			; Multiply number by 10
01:A37B F1              	  3701: 		POP		AF				; Restore count
01:A37C 3D              	  3702: 		DEC		A				; Count multiplies
01:A37D C9              	  3703: 		RET
                        	  3704: 
01:A37E D5              	  3705: ADDIG:	PUSH	DE				; Save sign of exponent
01:A37F 57              	  3706: 		LD		D,A				; Save digit
01:A380 78              	  3707: 		LD		A,B				; Get digits after point
01:A381 89              	  3708: 		ADC		A,C				; Add one if after point
01:A382 47              	  3709: 		LD		B,A				; Re-save counter
01:A383 C5              	  3710: 		PUSH	BC				; Save point flags
01:A384 E5              	  3711: 		PUSH	HL				; Save code string address
01:A385 D5              	  3712: 		PUSH	DE				; Save digit
01:A386 CD03A2          	  3713: 		CALL	MLSP10			; Multiply number by 10
01:A389 F1              	  3714: 		POP		AF				; Restore digit
01:A38A D630            	  3715: 		SUB		'0'				; Make it absolute
01:A38C CD95A3          	  3716: 		CALL	RSCALE			; Re-scale number
01:A38F E1              	  3717: 		POP		HL				; Restore code string address
01:A390 C1              	  3718: 		POP		BC				; Restore point flags
01:A391 D1              	  3719: 		POP		DE				; Restore sign of exponent
01:A392 C335A3          	  3720: 		JP		MANLP			; Get another digit
                        	  3721: 
01:A395 CD4BA2          	  3722: RSCALE: CALL	STAKFP			; Put number on stack
01:A398 CD2CA2          	  3723: 		CALL	FLGREL			; Digit to add to FPREG
01:A39B C1              	  3724: PADD:	POP		BC				; Restore number
01:A39C D1              	  3725: 		POP		DE
01:A39D C3D49F          	  3726: 		JP		FPADD			; Add BCDE to FPREG and return
                        	  3727: 
01:A3A0 7B              	  3728: EDIGIT: LD		A,E				; Get digit
01:A3A1 07              	  3729: 		RLCA					; Times 2
01:A3A2 07              	  3730: 		RLCA					; Times 4
01:A3A3 83              	  3731: 		ADD		A,E				; Times 5
01:A3A4 07              	  3732: 		RLCA					; Times 10
01:A3A5 86              	  3733: 		ADD		A,(HL)			; Add next digit
01:A3A6 D630            	  3734: 		SUB		'0'				; Make it absolute
01:A3A8 5F              	  3735: 		LD		E,A				; Save new digit
01:A3A9 C34BA3          	  3736: 		JP		EXPLP			; Look for another digit
                        	  3737: 
01:A3AC E5              	  3738: LINEIN: PUSH	HL				; Save code string address
01:A3AD 21088F          	  3739: 		LD		HL,INMSG		; Output " in "
01:A3B0 CD119D          	  3740: 		CALL	PRS				; Output string at HL
01:A3B3 E1              	  3741: 		POP		HL				; Restore code string address
01:A3B4 EB              	  3742: PRNTHL: EX		DE,HL			; Code string address to DE
01:A3B5 AF              	  3743: 		XOR		A
01:A3B6 0698            	  3744: 		LD		B,80H+24		; 24 bits
01:A3B8 CD31A2          	  3745: 		CALL	RETINT			; Return the integer
01:A3BB 21109D          	  3746: 		LD		HL,PRNUMS		; Print number string
01:A3BE E5              	  3747: 		PUSH	HL				; Save for return
01:A3BF 21E910          	  3748: NUMASC: LD		HL,PBUFF		; Convert number to ASCII
01:A3C2 E5              	  3749: 		PUSH	HL				; Save for return
01:A3C3 CD1AA2          	  3750: 		CALL	TSTSGN			; Test sign of FPREG
01:A3C6 3620            	  3751: 		LD		(HL),' '		; Space at start
01:A3C8 F2CDA3          	  3752: 		JP		P,SPCFST		; Positive - Space to start
01:A3CB 362D            	  3753: 		LD		(HL),'-'		; '-' sign at start
01:A3CD 23              	  3754: SPCFST: INC		HL				; First byte of number
01:A3CE 3630            	  3755: 		LD		(HL),'0'		; '0' if zero
01:A3D0 CA83A4          	  3756: 		JP		Z,JSTZER		; Return '0' if zero
01:A3D3 E5              	  3757: 		PUSH	HL				; Save buffer address
01:A3D4 FC43A2          	  3758: 		CALL	M,INVSGN		; Negate FPREG if negative
01:A3D7 AF              	  3759: 		XOR		A				; Zero A
01:A3D8 F5              	  3760: 		PUSH	AF				; Save it
01:A3D9 CD89A4          	  3761: 		CALL	RNGTST			; Test number is in range
01:A3DC 014391          	  3762: SIXDIG: LD		BC,9143H		; BCDE - 99999.9
01:A3DF 11F84F          	  3763: 		LD		DE,4FF8H
01:A3E2 CD95A2          	  3764: 		CALL	CMPNUM			; Compare numbers
01:A3E5 B7              	  3765: 		OR		A
01:A3E6 E2FAA3          	  3766: 		JP		PO,INRNG		; > 99999.9 - Sort it out
01:A3E9 F1              	  3767: 		POP		AF				; Restore count
01:A3EA CD77A3          	  3768: 		CALL	MULTEN			; Multiply by ten
01:A3ED F5              	  3769: 		PUSH	AF				; Re-save count
01:A3EE C3DCA3          	  3770: 		JP		SIXDIG			; Test it again
                        	  3771: 
01:A3F1 CD62A1          	  3772: GTSIXD: CALL	DIV10			; Divide by 10
01:A3F4 F1              	  3773: 		POP		AF				; Get count
01:A3F5 3C              	  3774: 		INC		A				; Count divides
01:A3F6 F5              	  3775: 		PUSH	AF				; Re-save count
01:A3F7 CD89A4          	  3776: 		CALL	RNGTST			; Test number is in range
01:A3FA CDC29F          	  3777: INRNG:	CALL	ROUND			; Add 0.5 to FPREG
01:A3FD 3C              	  3778: 		INC		A
01:A3FE CDC2A2          	  3779: 		CALL	FPINT			; F.P to integer
01:A401 CD5BA2          	  3780: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A404 010603          	  3781: 		LD		BC,0306H		; 1E+06 to 1E-03 range
01:A407 F1              	  3782: 		POP		AF				; Restore count
01:A408 81              	  3783: 		ADD		A,C				; 6 digits before point
01:A409 3C              	  3784: 		INC		A				; Add one
01:A40A FA16A4          	  3785: 		JP		M,MAKNUM		; Do it in 'E' form if < 1E-02
01:A40D FE08            	  3786: 		CP		6+1+1			; More than 999999 ?
01:A40F D216A4          	  3787: 		JP		NC,MAKNUM		; Yes - Do it in 'E' form
01:A412 3C              	  3788: 		INC		A				; Adjust for exponent
01:A413 47              	  3789: 		LD		B,A				; Exponent of number
01:A414 3E02            	  3790: 		LD		A,2				; Make it zero after
                        	  3791: 
01:A416 3D              	  3792: MAKNUM: DEC		A				; Adjust for digits to do
01:A417 3D              	  3793: 		DEC		A
01:A418 E1              	  3794: 		POP		HL				; Restore buffer address
01:A419 F5              	  3795: 		PUSH	AF				; Save count
01:A41A 119CA4          	  3796: 		LD		DE,POWERS		; Powers of ten
01:A41D 05              	  3797: 		DEC		B				; Count digits before point
01:A41E C227A4          	  3798: 		JP		NZ,DIGTXT		; Not zero - Do number
01:A421 362E            	  3799: 		LD		(HL),'.'		; Save point
01:A423 23              	  3800: 		INC		HL				; Move on
01:A424 3630            	  3801: 		LD		(HL),'0'		; Save zero
01:A426 23              	  3802: 		INC		HL				; Move on
01:A427 05              	  3803: DIGTXT: DEC		B				; Count digits before point
01:A428 362E            	  3804: 		LD		(HL),'.'		; Save point in case
01:A42A CC70A2          	  3805: 		CALL	Z,INCHL			; Last digit - move on
01:A42D C5              	  3806: 		PUSH	BC				; Save digits before point
01:A42E E5              	  3807: 		PUSH	HL				; Save buffer address
01:A42F D5              	  3808: 		PUSH	DE				; Save powers of ten
01:A430 CD66A2          	  3809: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A433 E1              	  3810: 		POP		HL				; Powers of ten table
01:A434 062F            	  3811: 		LD		B, '0'-1		; ASCII '0' - 1
01:A436 04              	  3812: TRYAGN: INC		B				; Count subtractions
01:A437 7B              	  3813: 		LD		A,E				; Get LSB
01:A438 96              	  3814: 		SUB		(HL)			; Subtract LSB
01:A439 5F              	  3815: 		LD		E,A				; Save LSB
01:A43A 23              	  3816: 		INC		HL
01:A43B 7A              	  3817: 		LD		A,D				; Get NMSB
01:A43C 9E              	  3818: 		SBC		A,(HL)			; Subtract NMSB
01:A43D 57              	  3819: 		LD		D,A				; Save NMSB
01:A43E 23              	  3820: 		INC		HL
01:A43F 79              	  3821: 		LD		A,C				; Get MSB
01:A440 9E              	  3822: 		SBC		A,(HL)			; Subtract MSB
01:A441 4F              	  3823: 		LD		C,A				; Save MSB
01:A442 2B              	  3824: 		DEC		HL				; Point back to start
01:A443 2B              	  3825: 		DEC		HL
01:A444 D236A4          	  3826: 		JP		NC,TRYAGN		; No overflow - Try again
01:A447 CD79A0          	  3827: 		CALL	PLUCDE			; Restore number
01:A44A 23              	  3828: 		INC		HL				; Start of next number
01:A44B CD5BA2          	  3829: 		CALL	FPBCDE			; Move BCDE to FPREG
01:A44E EB              	  3830: 		EX		DE,HL			; Save point in table
01:A44F E1              	  3831: 		POP		HL				; Restore buffer address
01:A450 70              	  3832: 		LD		(HL),B			; Save digit in buffer
01:A451 23              	  3833: 		INC		HL				; And move on
01:A452 C1              	  3834: 		POP		BC				; Restore digit count
01:A453 0D              	  3835: 		DEC		C				; Count digits
01:A454 C227A4          	  3836: 		JP		NZ,DIGTXT		; More - Do them
01:A457 05              	  3837: 		DEC		B				; Any decimal part?
01:A458 CA67A4          	  3838: 		JP		Z,DOEBIT		; No - Do 'E' bit
01:A45B 2B              	  3839: SUPTLZ: DEC		HL				; Move back through buffer
01:A45C 7E              	  3840: 		LD		A,(HL)			; Get character
01:A45D FE30            	  3841: 		CP		'0'				; '0' character?
01:A45F CA5BA4          	  3842: 		JP		Z,SUPTLZ		; Yes - Look back for more
01:A462 FE2E            	  3843: 		CP		'.'				; A decimal point?
01:A464 C470A2          	  3844: 		CALL	NZ,INCHL		; Move back over digit
                        	  3845: 
01:A467 F1              	  3846: DOEBIT: POP		AF				; Get 'E' flag
01:A468 CA86A4          	  3847: 		JP		Z,NOENED		; No 'E' needed - End buffer
01:A46B 3645            	  3848: 		LD		(HL),'E'		; Put 'E' in buffer
01:A46D 23              	  3849: 		INC		HL				; And move on
01:A46E 362B            	  3850: 		LD		(HL),'+'		; Put '+' in buffer
01:A470 F277A4          	  3851: 		JP		P,OUTEXP		; Positive - Output exponent
01:A473 362D            	  3852: 		LD		(HL),'-'		; Put '-' in buffer
01:A475 2F              	  3853: 		CPL						; Negate exponent
01:A476 3C              	  3854: 		INC		A
01:A477 062F            	  3855: OUTEXP: LD		B,'0'-1			; ASCII '0' - 1
01:A479 04              	  3856: EXPTEN: INC		B				; Count subtractions
01:A47A D60A            	  3857: 		SUB		10				; Tens digit
01:A47C D279A4          	  3858: 		JP		NC,EXPTEN		; More to do
01:A47F C63A            	  3859: 		ADD		A,'0'+10		; Restore and make ASCII
01:A481 23              	  3860: 		INC		HL				; Move on
01:A482 70              	  3861: 		LD		(HL),B			; Save MSB of exponent
01:A483 23              	  3862: JSTZER: INC		HL				;
01:A484 77              	  3863: 		LD		(HL),A			; Save LSB of exponent
01:A485 23              	  3864: 		INC		HL
01:A486 71              	  3865: NOENED: LD		(HL),C			; Mark end of buffer
01:A487 E1              	  3866: 		POP		HL				; Restore code string address
01:A488 C9              	  3867: 		RET
                        	  3868: 
01:A489 017494          	  3869: RNGTST: LD		BC,9474H		; BCDE = 999999.
01:A48C 11F723          	  3870: 		LD		DE,23F7H
01:A48F CD95A2          	  3871: 		CALL	CMPNUM			; Compare numbers
01:A492 B7              	  3872: 		OR		A
01:A493 E1              	  3873: 		POP		HL				; Return address to HL
01:A494 E2F1A3          	  3874: 		JP		PO,GTSIXD		; Too big - Divide by ten
01:A497 E9              	  3875: 		JP		(HL)			; Otherwise return to caller
                        	  3876: 
01:A498 00              	  3877: HALF:	db	   00H,00H,00H,80H ; 0.5
01:A499 00
01:A49A 00
01:A49B 80
                        	  3878: 
01:A49C A0              	  3879: POWERS: db	   0A0H,086H,001H  ; 100000
01:A49D 86
01:A49E 01
01:A49F 10              	  3880: 		db	   010H,027H,000H  ;  10000
01:A4A0 27
01:A4A1 00
01:A4A2 E8              	  3881: 		db	   0E8H,003H,000H  ;   1000
01:A4A3 03
01:A4A4 00
01:A4A5 64              	  3882: 		db	   064H,000H,000H  ;	100
01:A4A6 00
01:A4A7 00
01:A4A8 0A              	  3883: 		db	   00AH,000H,000H  ;	 10
01:A4A9 00
01:A4AA 00
01:A4AB 01              	  3884: 		db	   001H,000H,000H  ;	  1
01:A4AC 00
01:A4AD 00
                        	  3885: 
01:A4AE 2143A2          	  3886: NEGAFT: LD	HL,INVSGN			; Negate result
01:A4B1 E3              	  3887: 		EX		(SP),HL			; To be done after caller
01:A4B2 E9              	  3888: 		JP		(HL)			; Return to caller
                        	  3889: 
01:A4B3 CD4BA2          	  3890: SQR:	CALL	STAKFP			; Put value on stack
01:A4B6 2198A4          	  3891: 		LD		HL,HALF			; Set power to 1/2
01:A4B9 CD58A2          	  3892: 		CALL	PHLTFP			; Move 1/2 to FPREG
                        	  3893: 
01:A4BC C1              	  3894: POWER:	POP		BC				; Get base
01:A4BD D1              	  3895: 		POP		DE
01:A4BE CD1AA2          	  3896: 		CALL	TSTSGN			; Test sign of power
01:A4C1 78              	  3897: 		LD		A,B				; Get exponent of base
01:A4C2 CA01A5          	  3898: 		JP		Z,EXPP			; Make result 1 if zero
01:A4C5 F2CCA4          	  3899: 		JP		P,POWER1		; Positive base - Ok
01:A4C8 B7              	  3900: 		OR		A				; Zero to negative power?
01:A4C9 CA738F          	  3901: 		JP		Z,DZERR			; Yes - ?/0 Error
01:A4CC B7              	  3902: POWER1: OR		A				; Base zero?
01:A4CD CA3BA0          	  3903: 		JP		Z,SAVEXP		; Yes - Return zero
01:A4D0 D5              	  3904: 		PUSH	DE				; Save base
01:A4D1 C5              	  3905: 		PUSH	BC
01:A4D2 79              	  3906: 		LD		A,C				; Get MSB of base
01:A4D3 F67F            	  3907: 		OR		01111111B		; Get sign status
01:A4D5 CD66A2          	  3908: 		CALL	BCDEFP			; Move power to BCDE
01:A4D8 F2E9A4          	  3909: 		JP		P,POWER2		; Positive base - Ok
01:A4DB D5              	  3910: 		PUSH	DE				; Save power
01:A4DC C5              	  3911: 		PUSH	BC
01:A4DD CDEDA2          	  3912: 		CALL	INT				; Get integer of power
01:A4E0 C1              	  3913: 		POP		BC				; Restore power
01:A4E1 D1              	  3914: 		POP		DE
01:A4E2 F5              	  3915: 		PUSH	AF				; MSB of base
01:A4E3 CD95A2          	  3916: 		CALL	CMPNUM			; Power an integer?
01:A4E6 E1              	  3917: 		POP		HL				; Restore MSB of base
01:A4E7 7C              	  3918: 		LD		A,H				; but don't affect flags
01:A4E8 1F              	  3919: 		RRA						; Exponent odd or even?
01:A4E9 E1              	  3920: POWER2: POP		HL				; Restore MSB and exponent
01:A4EA 22E610          	  3921: 		LD		(FPREG+2),HL	; Save base in FPREG
01:A4ED E1              	  3922: 		POP		HL				; LSBs of base
01:A4EE 22E410          	  3923: 		LD		(FPREG),HL		; Save in FPREG
01:A4F1 DCAEA4          	  3924: 		CALL	C,NEGAFT		; Odd power - Negate result
01:A4F4 CC43A2          	  3925: 		CALL	Z,INVSGN		; Negative base - Negate it
01:A4F7 D5              	  3926: 		PUSH	DE				; Save power
01:A4F8 C5              	  3927: 		PUSH	BC
01:A4F9 CDCEA0          	  3928: 		CALL	LOG				; Get LOG of base
01:A4FC C1              	  3929: 		POP		BC				; Restore power
01:A4FD D1              	  3930: 		POP		DE
01:A4FE CD0FA1          	  3931: 		CALL	FPMULT			; Multiply LOG by power
                        	  3932: 
01:A501 CD4BA2          	  3933: EXPP:	CALL	STAKFP			; Put value on stack
01:A504 013881          	  3934: 		LD		BC,08138H		; BCDE = 1/Ln(2)
01:A507 113BAA          	  3935: 		LD		DE,0AA3BH
01:A50A CD0FA1          	  3936: 		CALL	FPMULT			; Multiply value by 1/LN(2)
01:A50D 3AE710          	  3937: 		LD		A,(FPEXP)		; Get exponent
01:A510 FE88            	  3938: 		CP		80H+8			; Is it in range?
01:A512 D2F6A1          	  3939: 		JP		NC,OVTST1		; No - Test for overflow
01:A515 CDEDA2          	  3940: 		CALL	INT				; Get INT of FPREG
01:A518 C680            	  3941: 		ADD		A,80H			; For excess 128
01:A51A C602            	  3942: 		ADD		A,2				; Exponent > 126?
01:A51C DAF6A1          	  3943: 		JP		C,OVTST1		; Yes - Test for overflow
01:A51F F5              	  3944: 		PUSH	AF				; Save scaling factor
01:A520 21BDA0          	  3945: 		LD		HL,UNITY		; Point to 1.
01:A523 CDC59F          	  3946: 		CALL	ADDPHL			; Add 1 to FPREG
01:A526 CD06A1          	  3947: 		CALL	MULLN2			; Multiply by LN(2)
01:A529 F1              	  3948: 		POP		AF				; Restore scaling factor
01:A52A C1              	  3949: 		POP		BC				; Restore exponent
01:A52B D1              	  3950: 		POP		DE
01:A52C F5              	  3951: 		PUSH	AF				; Save scaling factor
01:A52D CDD19F          	  3952: 		CALL	SUBCDE			; Subtract exponent from FPREG
01:A530 CD43A2          	  3953: 		CALL	INVSGN			; Negate result
01:A533 2141A5          	  3954: 		LD		HL,EXPTAB		; Coefficient table
01:A536 CD71A5          	  3955: 		CALL	SMSER1			; Sum the series
01:A539 110000          	  3956: 		LD		DE,0			; Zero LSBs
01:A53C C1              	  3957: 		POP		BC				; Scaling factor
01:A53D 4A              	  3958: 		LD		C,D				; Zero MSB
01:A53E C30FA1          	  3959: 		JP		FPMULT			; Scale result to correct value
                        	  3960: 
01:A541 08              	  3961: EXPTAB: db	   8					   ; Table used by EXP
01:A542 40              	  3962: 		db	   040H,02EH,094H,074H	   ; -1/7! (-1/5040)
01:A543 2E
01:A544 94
01:A545 74
01:A546 70              	  3963: 		db	   070H,04FH,02EH,077H	   ;  1/6! ( 1/720)
01:A547 4F
01:A548 2E
01:A549 77
01:A54A 6E              	  3964: 		db	   06EH,002H,088H,07AH	   ; -1/5! (-1/120)
01:A54B 02
01:A54C 88
01:A54D 7A
01:A54E E6              	  3965: 		db	   0E6H,0A0H,02AH,07CH	   ;  1/4! ( 1/24)
01:A54F A0
01:A550 2A
01:A551 7C
01:A552 50              	  3966: 		db	   050H,0AAH,0AAH,07EH	   ; -1/3! (-1/6)
01:A553 AA
01:A554 AA
01:A555 7E
01:A556 FF              	  3967: 		db	   0FFH,0FFH,07FH,07FH	   ;  1/2! ( 1/2)
01:A557 FF
01:A558 7F
01:A559 7F
01:A55A 00              	  3968: 		db	   000H,000H,080H,081H	   ; -1/1! (-1/1)
01:A55B 00
01:A55C 80
01:A55D 81
01:A55E 00              	  3969: 		db	   000H,000H,000H,081H	   ;  1/0! ( 1/1)
01:A55F 00
01:A560 00
01:A561 81
                        	  3970: 
01:A562 CD4BA2          	  3971: SUMSER: CALL	STAKFP			; Put FPREG on stack
01:A565 110DA1          	  3972: 		LD		DE,MULTT			; Multiply by "X"
01:A568 D5              	  3973: 		PUSH	DE				; To be done after
01:A569 E5              	  3974: 		PUSH	HL				; Save address of table
01:A56A CD66A2          	  3975: 		CALL	BCDEFP			; Move FPREG to BCDE
01:A56D CD0FA1          	  3976: 		CALL	FPMULT			; Square the value
01:A570 E1              	  3977: 		POP		HL				; Restore address of table
01:A571 CD4BA2          	  3978: SMSER1: CALL	STAKFP			; Put value on stack
01:A574 7E              	  3979: 		LD		A,(HL)			; Get number of coefficients
01:A575 23              	  3980: 		INC		HL				; Point to start of table
01:A576 CD58A2          	  3981: 		CALL	PHLTFP			; Move coefficient to FPREG
01:A579 06              	  3982: 		db	   06H			   ; Skip "POP AF"
01:A57A F1              	  3983: SUMLP:	POP		AF				; Restore count
01:A57B C1              	  3984: 		POP		BC				; Restore number
01:A57C D1              	  3985: 		POP		DE
01:A57D 3D              	  3986: 		DEC		A				; Cont coefficients
01:A57E C8              	  3987: 		RET		Z				; All done
01:A57F D5              	  3988: 		PUSH	DE				; Save number
01:A580 C5              	  3989: 		PUSH	BC
01:A581 F5              	  3990: 		PUSH	AF				; Save count
01:A582 E5              	  3991: 		PUSH	HL				; Save address in table
01:A583 CD0FA1          	  3992: 		CALL	FPMULT			; Multiply FPREG by BCDE
01:A586 E1              	  3993: 		POP		HL				; Restore address in table
01:A587 CD69A2          	  3994: 		CALL	LOADFP			; Number at HL to BCDE
01:A58A E5              	  3995: 		PUSH	HL				; Save address in table
01:A58B CDD49F          	  3996: 		CALL	FPADD			; Add coefficient to FPREG
01:A58E E1              	  3997: 		POP		HL				; Restore address in table
01:A58F C37AA5          	  3998: 		JP		SUMLP			; More coefficients
                        	  3999: 
01:A592 CD1AA2          	  4000: RND:	CALL	TSTSGN			; Test sign of FPREG
01:A595 211910          	  4001: 		LD		HL,SEED+2		; Random number seed
01:A598 FAF3A5          	  4002: 		JP		M,RESEED		; Negative - Re-seed
01:A59B 213A10          	  4003: 		LD		HL,LSTRND		; Last random number
01:A59E CD58A2          	  4004: 		CALL	PHLTFP			; Move last RND to FPREG
01:A5A1 211910          	  4005: 		LD		HL,SEED+2		; Random number seed
01:A5A4 C8              	  4006: 		RET		Z				; Return if RND(0)
01:A5A5 86              	  4007: 		ADD		A,(HL)			; Add (SEED)+2)
01:A5A6 E607            	  4008: 		AND		00000111B		; 0 to 7
01:A5A8 0600            	  4009: 		LD		B,0
01:A5AA 77              	  4010: 		LD		(HL),A			; Re-save seed
01:A5AB 23              	  4011: 		INC		HL				; Move to coefficient table
01:A5AC 87              	  4012: 		ADD		A,A				; 4 bytes
01:A5AD 87              	  4013: 		ADD		A,A				; per entry
01:A5AE 4F              	  4014: 		LD		C,A				; BC = Offset into table
01:A5AF 09              	  4015: 		ADD		HL,BC			; Point to coefficient
01:A5B0 CD69A2          	  4016: 		CALL	LOADFP			; Coefficient to BCDE
01:A5B3 CD0FA1          	  4017: 		CALL	FPMULT	;		; Multiply FPREG by coefficient
01:A5B6 3A1810          	  4018: 		LD		A,(SEED+1)		; Get (SEED+1)
01:A5B9 3C              	  4019: 		INC		A				; Add 1
01:A5BA E603            	  4020: 		AND		00000011B		; 0 to 3
01:A5BC 0600            	  4021: 		LD		B,0
01:A5BE FE01            	  4022: 		CP		1				; Is it zero?
01:A5C0 88              	  4023: 		ADC		A,B				; Yes - Make it 1
01:A5C1 321810          	  4024: 		LD		(SEED+1),A		; Re-save seed
01:A5C4 21F7A5          	  4025: 		LD		HL,RNDTAB-4		; Addition table
01:A5C7 87              	  4026: 		ADD		A,A				; 4 bytes
01:A5C8 87              	  4027: 		ADD		A,A				; per entry
01:A5C9 4F              	  4028: 		LD		C,A				; BC = Offset into table
01:A5CA 09              	  4029: 		ADD		HL,BC			; Point to value
01:A5CB CDC59F          	  4030: 		CALL	ADDPHL			; Add value to FPREG
01:A5CE CD66A2          	  4031: RND1:	CALL	BCDEFP			; Move FPREG to BCDE
01:A5D1 7B              	  4032: 		LD		A,E				; Get LSB
01:A5D2 59              	  4033: 		LD		E,C				; LSB = MSB
01:A5D3 EE4F            	  4034: 		XOR		01001111B		; Fiddle around
01:A5D5 4F              	  4035: 		LD		C,A				; New MSB
01:A5D6 3680            	  4036: 		LD		(HL),80H		; Set exponent
01:A5D8 2B              	  4037: 		DEC		HL				; Point to MSB
01:A5D9 46              	  4038: 		LD		B,(HL)			; Get MSB
01:A5DA 3680            	  4039: 		LD		(HL),80H		; Make value -0.5
01:A5DC 211710          	  4040: 		LD		HL,SEED			; Random number seed
01:A5DF 34              	  4041: 		INC		(HL)			; Count seed
01:A5E0 7E              	  4042: 		LD		A,(HL)			; Get seed
01:A5E1 D6AB            	  4043: 		SUB		171				; Do it modulo 171
01:A5E3 C2EAA5          	  4044: 		JP		NZ,RND2			; Non-zero - Ok
01:A5E6 77              	  4045: 		LD		(HL),A			; Zero seed
01:A5E7 0C              	  4046: 		INC		C				; Fillde about
01:A5E8 15              	  4047: 		DEC		D				; with the
01:A5E9 1C              	  4048: 		INC		E				; number
01:A5EA CD25A0          	  4049: RND2:	CALL	BNORM			; Normalise number
01:A5ED 213A10          	  4050: 		LD		HL,LSTRND		; Save random number
01:A5F0 C372A2          	  4051: 		JP		FPTHL			; Move FPREG to last and return
                        	  4052: 
01:A5F3 77              	  4053: RESEED: LD		(HL),A			; Re-seed random numbers
01:A5F4 2B              	  4054: 		DEC		HL
01:A5F5 77              	  4055: 		LD		(HL),A
01:A5F6 2B              	  4056: 		DEC		HL
01:A5F7 77              	  4057: 		LD		(HL),A
01:A5F8 C3CEA5          	  4058: 		JP		RND1			; Return RND seed
                        	  4059: 
01:A5FB 68              	  4060: RNDTAB: db	068H,0B1H,046H,068H		; Table used by RND
01:A5FC B1
01:A5FD 46
01:A5FE 68
01:A5FF 99              	  4061: 		db	099H,0E9H,092H,069H
01:A600 E9
01:A601 92
01:A602 69
01:A603 10              	  4062: 		db	010H,0D1H,075H,068H
01:A604 D1
01:A605 75
01:A606 68
                        	  4063: 
01:A607 2151A6          	  4064: COS:	LD		HL,HALFPI		; Point to PI/2
01:A60A CDC59F          	  4065: 		CALL	ADDPHL			; Add it to PPREG
01:A60D CD4BA2          	  4066: SIN:	CALL	STAKFP			; Put angle on stack
01:A610 014983          	  4067: 		LD		BC,8349H		; BCDE = 2 PI
01:A613 11DB0F          	  4068: 		LD		DE,0FDBH
01:A616 CD5BA2          	  4069: 		CALL	FPBCDE			; Move 2 PI to FPREG
01:A619 C1              	  4070: 		POP		BC				; Restore angle
01:A61A D1              	  4071: 		POP		DE
01:A61B CD70A1          	  4072: 		CALL	DVBCDE			; Divide angle by 2 PI
01:A61E CD4BA2          	  4073: 		CALL	STAKFP			; Put it on stack
01:A621 CDEDA2          	  4074: 		CALL	INT				; Get INT of result
01:A624 C1              	  4075: 		POP		BC				; Restore number
01:A625 D1              	  4076: 		POP		DE
01:A626 CDD19F          	  4077: 		CALL	SUBCDE			; Make it 0 <= value < 1
01:A629 2155A6          	  4078: 		LD		HL,QUARTR		; Point to 0.25
01:A62C CDCB9F          	  4079: 		CALL	SUBPHL			; Subtract value from 0.25
01:A62F CD1AA2          	  4080: 		CALL	TSTSGN			; Test sign of value
01:A632 37              	  4081: 		SCF						; Flag positive
01:A633 F23DA6          	  4082: 		JP		P,SIN1			; Positive - Ok
01:A636 CDC29F          	  4083: 		CALL	ROUND			; Add 0.5 to value
01:A639 CD1AA2          	  4084: 		CALL	TSTSGN			; Test sign of value
01:A63C B7              	  4085: 		OR		A				; Flag negative
01:A63D F5              	  4086: SIN1:	PUSH	AF				; Save sign
01:A63E F443A2          	  4087: 		CALL	P,INVSGN		; Negate value if positive
01:A641 2155A6          	  4088: 		LD		HL,QUARTR		; Point to 0.25
01:A644 CDC59F          	  4089: 		CALL	ADDPHL			; Add 0.25 to value
01:A647 F1              	  4090: 		POP		AF				; Restore sign
01:A648 D443A2          	  4091: 		CALL	NC,INVSGN		; Negative - Make positive
01:A64B 2159A6          	  4092: 		LD		HL,SINTAB		; Coefficient table
01:A64E C362A5          	  4093: 		JP		SUMSER			; Evaluate sum of series
                        	  4094: 
01:A651 DB              	  4095: HALFPI: db	0DBH,00FH,049H,081H		; 1.5708 (PI/2)
01:A652 0F
01:A653 49
01:A654 81
                        	  4096: 
01:A655 00              	  4097: QUARTR: db	000H,000H,000H,07FH		; 0.25
01:A656 00
01:A657 00
01:A658 7F
                        	  4098: 
01:A659 05              	  4099: SINTAB: db	5						; Table used by SIN
01:A65A BA              	  4100: 		db	0BAH,0D7H,01EH,086H		; 39.711
01:A65B D7
01:A65C 1E
01:A65D 86
01:A65E 64              	  4101: 		db	064H,026H,099H,087H		;-76.575
01:A65F 26
01:A660 99
01:A661 87
01:A662 58              	  4102: 		db	058H,034H,023H,087H		; 81.602
01:A663 34
01:A664 23
01:A665 87
01:A666 E0              	  4103: 		db	0E0H,05DH,0A5H,086H		;-41.342
01:A667 5D
01:A668 A5
01:A669 86
01:A66A DA              	  4104: 		db	0DAH,00FH,049H,083H		;  6.2832
01:A66B 0F
01:A66C 49
01:A66D 83
                        	  4105: 
01:A66E CD4BA2          	  4106: TAN:	CALL	STAKFP			; Put angle on stack
01:A671 CD0DA6          	  4107: 		CALL	SIN				; Get SIN of angle
01:A674 C1              	  4108: 		POP		BC				; Restore angle
01:A675 E1              	  4109: 		POP		HL
01:A676 CD4BA2          	  4110: 		CALL	STAKFP			; Save SIN of angle
01:A679 EB              	  4111: 		EX		DE,HL			; BCDE = Angle
01:A67A CD5BA2          	  4112: 		CALL	FPBCDE			; Angle to FPREG
01:A67D CD07A6          	  4113: 		CALL	COS				; Get COS of angle
01:A680 C36EA1          	  4114: 		JP		DIV				; TAN = SIN / COS
                        	  4115: 
01:A683 CD1AA2          	  4116: ATN:	CALL	TSTSGN			; Test sign of value
01:A686 FCAEA4          	  4117: 		CALL	M,NEGAFT		; Negate result after if -ve
01:A689 FC43A2          	  4118: 		CALL	M,INVSGN		; Negate value if -ve
01:A68C 3AE710          	  4119: 		LD		A,(FPEXP)		; Get exponent
01:A68F FE81            	  4120: 		CP		81H				; Number less than 1?
01:A691 DAA0A6          	  4121: 		JP		C,ATN1			; Yes - Get arc tangnt
01:A694 010081          	  4122: 		LD		BC,8100H		; BCDE = 1
01:A697 51              	  4123: 		LD		D,C
01:A698 59              	  4124: 		LD		E,C
01:A699 CD70A1          	  4125: 		CALL	DVBCDE			; Get reciprocal of number
01:A69C 21CB9F          	  4126: 		LD		HL,SUBPHL		; Sub angle from PI/2
01:A69F E5              	  4127: 		PUSH	HL				; Save for angle > 1
01:A6A0 21AAA6          	  4128: ATN1:	LD		HL,ATNTAB		; Coefficient table
01:A6A3 CD62A5          	  4129: 		CALL	SUMSER			; Evaluate sum of series
01:A6A6 2151A6          	  4130: 		LD		HL,HALFPI		; PI/2 - angle in case > 1
01:A6A9 C9              	  4131: 		RET						; Number > 1 - Sub from PI/2
                        	  4132: 
01:A6AA 09              	  4133: ATNTAB: db	9						; Table used by ATN
01:A6AB 4A              	  4134: 		db	04AH,0D7H,03BH,078H		; 1/17
01:A6AC D7
01:A6AD 3B
01:A6AE 78
01:A6AF 02              	  4135: 		db	002H,06EH,084H,07BH		;-1/15
01:A6B0 6E
01:A6B1 84
01:A6B2 7B
01:A6B3 FE              	  4136: 		db	0FEH,0C1H,02FH,07CH		; 1/13
01:A6B4 C1
01:A6B5 2F
01:A6B6 7C
01:A6B7 74              	  4137: 		db	074H,031H,09AH,07DH		;-1/11
01:A6B8 31
01:A6B9 9A
01:A6BA 7D
01:A6BB 84              	  4138: 		db	084H,03DH,05AH,07DH		; 1/9
01:A6BC 3D
01:A6BD 5A
01:A6BE 7D
01:A6BF C8              	  4139: 		db	0C8H,07FH,091H,07EH		;-1/7
01:A6C0 7F
01:A6C1 91
01:A6C2 7E
01:A6C3 E4              	  4140: 		db	0E4H,0BBH,04CH,07EH		; 1/5
01:A6C4 BB
01:A6C5 4C
01:A6C6 7E
01:A6C7 6C              	  4141: 		db	06CH,0AAH,0AAH,07FH		;-1/3
01:A6C8 AA
01:A6C9 AA
01:A6CA 7F
01:A6CB 00              	  4142: 		db	000H,000H,000H,081H		; 1/1
01:A6CC 00
01:A6CD 00
01:A6CE 81
                        	  4143: 
                        	  4144: 
01:A6CF C9              	  4145: ARET:	RET						; A RETurn instruction
                        	  4146: 
01:A6D0 CDC780          	  4147: GETINP: call	ReadChar				;input a character
01:A6D3 C9              	  4148: 		RET
                        	  4149: 
                        	  4150: CLS:
01:A6D4 C3AA82          	  4151: 		jp		ClearScreen
                        	  4152: ;		LD		A,CS			; ASCII Clear screen
                        	  4153: ;		JP		MONOUT			; Output character
                        	  4154: 
01:A6D7 CD999F          	  4155: WIDTH:	CALL	GETINT			; Get integer 0-255
01:A6DA 7B              	  4156: 		LD		A,E				; Width to A
01:A6DB 324210          	  4157: 		LD		(LWIDTH),A		; Set width
01:A6DE C9              	  4158: 		RET
                        	  4159: 
01:A6DF CD3898          	  4160: LINES:	CALL	GETNUM			; Get a number
01:A6E2 CD7D94          	  4161: 		CALL	DEINT			; Get integer -32768 to 32767
01:A6E5 ED534610        	  4162: 		LD		(LINESC),DE		; Set lines counter
01:A6E9 ED534810        	  4163: 		LD		(LINESN),DE		; Set lines number
01:A6ED C9              	  4164: 		RET
                        	  4165: 
01:A6EE CD7D94          	  4166: DEEK:	CALL	DEINT			; Get integer -32768 to 32767
01:A6F1 D5              	  4167: 		PUSH	DE				; Save number
01:A6F2 E1              	  4168: 		POP		HL				; Number to HL
01:A6F3 46              	  4169: 		LD		B,(HL)			; Get LSB of contents
01:A6F4 23              	  4170: 		INC		HL
01:A6F5 7E              	  4171: 		LD		A,(HL)			; Get MSB of contents
01:A6F6 C3F39B          	  4172: 		JP		ABPASS			; Return integer AB
                        	  4173: 
01:A6F9 CD3898          	  4174: DOKE:	CALL	GETNUM			; Get a number
01:A6FC CD7D94          	  4175: 		CALL	DEINT			; Get integer -32768 to 32767
01:A6FF D5              	  4176: 		PUSH	DE				; Save address
01:A700 CD3E92          	  4177: 		CALL	CHKSYN			; Make sure ',' follows
01:A703 2C              	  4178: 		db	   ','
01:A704 CD3898          	  4179: 		CALL	GETNUM			; Get a number
01:A707 CD7D94          	  4180: 		CALL	DEINT			; Get integer -32768 to 32767
01:A70A E3              	  4181: 		EX		(SP),HL			; Save value,get address
01:A70B 73              	  4182: 		LD		(HL),E			; Save LSB of value
01:A70C 23              	  4183: 		INC		HL
01:A70D 72              	  4184: 		LD		(HL),D			; Save MSB of value
01:A70E E1              	  4185: 		POP		HL				; Restore code string address
01:A70F C9              	  4186: 		RET
                        	  4187: 
                        	  4188: 
                        	  4189: ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        	  4190: 
01:A710 CD3B98          	  4191: HEX:	CALL	TSTNUM			; Verify it's a number
01:A713 CD7D94          	  4192: 		CALL	DEINT			; Get integer -32768 to 32767
01:A716 C5              	  4193: 		PUSH	BC				; Save contents of BC
01:A717 21E910          	  4194: 		LD		HL,PBUFF
01:A71A 7A              	  4195: 		LD		A,D				; Get high order into A
01:A71B FE00            	  4196: 		CP		$0
01:A71D 280C            	  4197: 		JR		Z,HEX2			; Skip output if both high digits are zero
01:A71F CD48A7          	  4198: 		CALL	BYT2ASC			; Convert D to ASCII
01:A722 78              	  4199: 		LD		A,B
01:A723 FE30            	  4200: 		CP		'0'
01:A725 2802            	  4201: 		JR		Z,HEX1			; Don't store high digit if zero
01:A727 70              	  4202: 		LD		(HL),B			; Store it to PBUFF
01:A728 23              	  4203: 		INC		HL				; Next location
01:A729 71              	  4204: HEX1:	LD		(HL),C			; Store C to PBUFF+1
01:A72A 23              	  4205: 		INC		HL				; Next location
01:A72B 7B              	  4206: HEX2:	LD		A,E				; Get lower byte
01:A72C CD48A7          	  4207: 		CALL	BYT2ASC			; Convert E to ASCII
01:A72F 7A              	  4208: 		LD		A,D
01:A730 FE00            	  4209: 		CP		$0
01:A732 2005            	  4210: 		JR		NZ,HEX3			; If upper byte was not zero then always print lower byte
01:A734 78              	  4211: 		LD		A,B
01:A735 FE30            	  4212: 		CP		'0'				; If high digit of lower byte is zero then don't print
01:A737 2802            	  4213: 		JR		Z,HEX4
01:A739 70              	  4214: HEX3:	LD		(HL),B			; to PBUFF+2
01:A73A 23              	  4215: 		INC		HL				; Next location
01:A73B 71              	  4216: HEX4:	LD		(HL),C			; to PBUFF+3
01:A73C 23              	  4217: 		INC		HL				; PBUFF+4 to zero
01:A73D AF              	  4218: 		XOR		A				; Terminating character
01:A73E 77              	  4219: 		LD		(HL),A			; Store zero to terminate
01:A73F 23              	  4220: 		INC		HL				; Make sure PBUFF is terminated
01:A740 77              	  4221: 		LD		(HL),A			; Store the double zero there
01:A741 C1              	  4222: 		POP		BC				; Get BC back
01:A742 21E910          	  4223: 		LD		HL,PBUFF		; Reset to start of PBUFF
01:A745 C3A19C          	  4224: 		JP		STR1			; Convert the PBUFF to a string and return it
                        	  4225: 
01:A748 47              	  4226: BYT2ASC	LD		B,A				; Save original value
01:A749 E60F            	  4227: 		AND		$0F				; Strip off upper nybble
01:A74B FE0A            	  4228: 		CP		$0A				; 0-9?
01:A74D 3802            	  4229: 		JR		C,ADD30			; If A-F, add 7 more
01:A74F C607            	  4230: 		ADD		A,$07			; Bring value up to ASCII A-F
01:A751 C630            	  4231: ADD30	ADD		A,$30			; And make ASCII
01:A753 4F              	  4232: 		LD		C,A				; Save converted char to C
01:A754 78              	  4233: 		LD		A,B				; Retrieve original value
01:A755 0F              	  4234: 		RRCA					; and Rotate it right
01:A756 0F              	  4235: 		RRCA
01:A757 0F              	  4236: 		RRCA
01:A758 0F              	  4237: 		RRCA
01:A759 E60F            	  4238: 		AND		$0F				; Mask off upper nybble
01:A75B FE0A            	  4239: 		CP		$0A				; 0-9? < A hex?
01:A75D 3802            	  4240: 		JR		C,ADD301		; Skip Add 7
01:A75F C607            	  4241: 		ADD		A,$07			; Bring it up to ASCII A-F
01:A761 C630            	  4242: ADD301	ADD		A,$30			; And make it full ASCII
01:A763 47              	  4243: 		LD		B,A				; Store high order byte
01:A764 C9              	  4244: 		RET	
                        	  4245: 
                        	  4246: ; Convert "&Hnnnn" to FPREG
                        	  4247: ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        	  4248: ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
01:A765 EB              	  4249: HEXTFP	EX		DE,HL			; Move code string pointer to DE
01:A766 210000          	  4250: 		LD		HL,$0000		; Zero out the value
01:A769 CD7EA7          	  4251: 		CALL	GETHEX			; Check the number for valid hex
01:A76C DA9EA7          	  4252: 		JP		C,HXERR			; First value wasn't hex, HX error
01:A76F 1805            	  4253: 		JR		HEXLP1			; Convert first character
01:A771 CD7EA7          	  4254: HEXLP	CALL	GETHEX			; Get second and addtional characters
01:A774 381F            	  4255: 		JR		C,HEXIT			; Exit if not a hex character
01:A776 29              	  4256: HEXLP1	ADD		HL,HL			; Rotate 4 bits to the left
01:A777 29              	  4257: 		ADD		HL,HL
01:A778 29              	  4258: 		ADD		HL,HL
01:A779 29              	  4259: 		ADD		HL,HL
01:A77A B5              	  4260: 		OR		L				; Add in D0-D3 into L
01:A77B 6F              	  4261: 		LD		L,A				; Save new value
01:A77C 18F3            	  4262: 		JR		HEXLP			; And continue until all hex characters are in
                        	  4263: 
01:A77E 13              	  4264: GETHEX	INC		DE				; Next location
01:A77F 1A              	  4265: 		LD		A,(DE)			; Load character at pointer
01:A780 FE20            	  4266: 		CP		' '
01:A782 CA7EA7          	  4267: 		JP		Z,GETHEX		; Skip spaces
01:A785 D630            	  4268: 		SUB		$30				; Get absolute value
01:A787 D8              	  4269: 		RET		C				; < "0", error
01:A788 FE0A            	  4270: 		CP		$0A
01:A78A 3805            	  4271: 		JR		C,NOSUB7		; Is already in the range 0-9
01:A78C D607            	  4272: 		SUB		$07				; Reduce to A-F
01:A78E FE0A            	  4273: 		CP		$0A				; Value should be $0A-$0F at this point
01:A790 D8              	  4274: 		RET		C				; CY set if was :			 ; < = > ? @
01:A791 FE10            	  4275: NOSUB7	CP		$10				; > Greater than "F"?
01:A793 3F              	  4276: 		CCF
01:A794 C9              	  4277: 		RET						; CY set if it wasn't valid hex
                        	  4278: 	
01:A795 EB              	  4279: HEXIT	EX		DE,HL			; Value into DE, Code string into HL
01:A796 7A              	  4280: 		LD		A,D				; Load DE into AC
01:A797 4B              	  4281: 		LD		C,E				; For prep to 
01:A798 E5              	  4282: 		PUSH	HL
01:A799 CDF29B          	  4283: 		CALL	ACPASS			; ACPASS to set AC as integer into FPREG
01:A79C E1              	  4284: 		POP		HL
01:A79D C9              	  4285: 		RET
                        	  4286: 
01:A79E 1E26            	  4287: HXERR:	LD		E,HX			; ?HEX Error
01:A7A0 C3848F          	  4288: 		JP		ERROR
                        	  4289: 
                        	  4290: ; BIN$(NN) Convert integer to a 1-16 char binary string
01:A7A3 CD3B98          	  4291: BIN:	CALL	TSTNUM			; Verify it's a number
01:A7A6 CD7D94          	  4292: 		CALL	DEINT			; Get integer -32768 to 32767
01:A7A9 C5              	  4293: BIN2:	PUSH	BC				; Save contents of BC
01:A7AA 21E910          	  4294: 		LD		HL,PBUFF
01:A7AD 0611            	  4295: 		LD		B,17			; One higher than max char count
                        	  4296: ZEROSUP:						; Suppress leading zeros
01:A7AF 05              	  4297: 		DEC		B				; Max 16 chars
01:A7B0 78              	  4298: 		LD		A,B
01:A7B1 FE01            	  4299: 		CP		$01
01:A7B3 2808            	  4300: 		JR		Z,BITOUT		; Always output at least one character
01:A7B5 CB13            	  4301: 		RL		E
01:A7B7 CB12            	  4302: 		RL		D
01:A7B9 30F4            	  4303: 		JR		NC,ZEROSUP
01:A7BB 1804            	  4304: 		JR		BITOUT2
                        	  4305: BITOUT:		 
01:A7BD CB13            	  4306: 		RL		E
01:A7BF CB12            	  4307: 		RL		D				; Top bit now in carry
                        	  4308: BITOUT2:
01:A7C1 3E30            	  4309: 		LD		A,'0'			; Char for '0'
01:A7C3 CE00            	  4310: 		ADC		A,0				; If carry set then '0' --> '1'
01:A7C5 77              	  4311: 		LD		(HL),A
01:A7C6 23              	  4312: 		INC		HL
01:A7C7 05              	  4313: 		DEC		B
01:A7C8 20F3            	  4314: 		JR		NZ,BITOUT
01:A7CA AF              	  4315: 		XOR		A				; Terminating character
01:A7CB 77              	  4316: 		LD		(HL),A			; Store zero to terminate
01:A7CC 23              	  4317: 		INC		HL				; Make sure PBUFF is terminated
01:A7CD 77              	  4318: 		LD		(HL),A			; Store the double zero there
01:A7CE C1              	  4319: 		POP		BC
01:A7CF 21E910          	  4320: 		LD		HL,PBUFF
01:A7D2 C3A19C          	  4321: 		JP		STR1
                        	  4322: 
                        	  4323: ; Convert "&Bnnnn" to FPREG
                        	  4324: ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
01:A7D5 EB              	  4325: BINTFP: EX		DE,HL			; Move code string pointer to DE
01:A7D6 210000          	  4326: 		LD		HL,$0000		; Zero out the value
01:A7D9 CDF2A7          	  4327: 		CALL	CHKBIN			; Check the number for valid bin
01:A7DC DA00A8          	  4328: 		JP		C,BINERR		; First value wasn't bin, HX error
01:A7DF D630            	  4329: BINIT:	SUB		'0'
01:A7E1 29              	  4330: 		ADD		HL,HL			; Rotate HL left
01:A7E2 B5              	  4331: 		OR		L
01:A7E3 6F              	  4332: 		LD		L,A
01:A7E4 CDF2A7          	  4333: 		CALL	CHKBIN			; Get second and addtional characters
01:A7E7 30F6            	  4334: 		JR		NC,BINIT		; Process if a bin character
01:A7E9 EB              	  4335: 		EX		DE,HL			; Value into DE, Code string into HL
01:A7EA 7A              	  4336: 		LD		A,D				; Load DE into AC
01:A7EB 4B              	  4337: 		LD		C,E				; For prep to 
01:A7EC E5              	  4338: 		PUSH	HL
01:A7ED CDF29B          	  4339: 		CALL	ACPASS			; ACPASS to set AC as integer into FPREG
01:A7F0 E1              	  4340: 		POP		HL
01:A7F1 C9              	  4341: 		RET
                        	  4342: 
                        	  4343: ; Char is in A, NC if char is 0 or 1
01:A7F2 13              	  4344: CHKBIN: INC		DE
01:A7F3 1A              	  4345: 		LD		A,(DE)
01:A7F4 FE20            	  4346: 		CP		' '
01:A7F6 CAF2A7          	  4347: 		JP		Z,CHKBIN		; Skip spaces
01:A7F9 FE30            	  4348: 		CP		'0'				; Set C if < '0'
01:A7FB D8              	  4349: 		RET		C
01:A7FC FE32            	  4350: 		CP		'2'
01:A7FE 3F              	  4351: 		CCF						; Set C if > '1'
01:A7FF C9              	  4352: 		RET
                        	  4353: 
01:A800 1E28            	  4354: BINERR: LD		E,BN			; ?BIN Error
01:A802 C3848F          	  4355: 		JP		ERROR
                        	  4356: 
                        	  4357: 
                        	  4358: JJUMP1: 
01:A805 DD21FFFF        	  4359: 		LD		IX,-1			; Flag cold start
01:A809 C3D58B          	  4360: 		JP		CSTART			; Go and initialise
                        	  4361: 
                        	  4362: MONOUT: 
                        	  4363: ;		JP		$0008			; output a char
01:A80C C37480          	  4364: 		JP		PrintChar				; output a char
                        	  4365: 
                        	  4366: 
                        	  4367: MONITR: 
                        	  4368: ;		JP		$0000			; Restart (Normally Monitor Start)
01:A80F C30080          	  4369: 		JP		$8000			; Restart (Normally Monitor Start)
                        	  4370: 
                        	  4371: 
01:A812 3E00            	  4372: INITST: LD		A,0				; Clear break flag
01:A814 324D10          	  4373: 		LD		(BRKFLG),A
01:A817 C3DC8B          	  4374: 		JP		INIT
                        	  4375: 
01:A81A ED45            	  4376: ARETN:	RETN					; Return from NMI
                        	  4377: 
                        	  4378: 
01:A81C F5              	  4379: TSTBIT: PUSH	AF				; Save bit mask
01:A81D A0              	  4380: 		AND		B				; Get common bits
01:A81E C1              	  4381: 		POP		BC				; Restore bit mask
01:A81F B8              	  4382: 		CP		B				; Same bit set?
01:A820 3E00            	  4383: 		LD		A,0				; Return 0 in A
01:A822 C9              	  4384: 		RET
                        	  4385: 
01:A823 CD4992          	  4386: OUTNCR: CALL	OUTC			; Output character in A
01:A826 C37396          	  4387: 		JP		PRNTCRLF		; Output CRLF
                        	  4388: 
                        	  4389: ;.end
                        	  4390: 
                        	  4391: 

Source: "main.asm"
                        	   274: 	.include	"data.asm"			; Various data and text messages. Keep last in list of includes

Source: "data.asm"
                        	     1: ;  ____            _           
                        	     2: ; |  _ \    __ _  | |_    __ _ 
                        	     3: ; | | | |  / _` | | __|  / _` |
                        	     4: ; | |_| | | (_| | | |_  | (_| |
                        	     5: ; |____/   \__,_|  \__|  \__,_|
                        	     6: ;
                        	     7: ; ---------------------------------------------------------------------------------------------------------------------
                        	     8: 
                        	     9: BootMsg:
01:A829 5A65644569676874	    10: 	db		"ZedEighty Project by Frederic Segard",CR,LF
01:A831 792050726F6A6563
01:A839 7420627920467265
01:A841 6465726963205365
01:A849 67617264
01:A84D 0D
01:A84E 0A
01:A84F 7777772E796F7574	    11: 	db		"www.youtube.com/@microhobbyist",CR,LF
01:A857 7562652E636F6D2F
01:A85F 406D6963726F686F
01:A867 626279697374
01:A86D 0D
01:A86E 0A
01:A86F 7777772E67697468	    12: 	db		"www.github.com/FredericSegard",CR,LF,0
01:A877 75622E636F6D2F46
01:A87F 7265646572696353
01:A887 6567617264
01:A88C 0D
01:A88D 0A
01:A88E 00
01:A88F 42494F5320302E37	    13: 	db		"BIOS 0.7  (c)2023  ",0," bytes free",CR,LF,LF,0
01:A897 2020286329323032
01:A89F 332020
01:A8A2 00
01:A8A3 2062797465732066
01:A8AB 726565
01:A8AE 0D
01:A8AF 0A
01:A8B0 0A
01:A8B1 00
                        	    14: 
                        	    15: CommandList:						; Commands must be in uppercase, and the jp opcode also acts as a delimiter
01:A8B2 41444452        	    16: 	db		"ADDR"					; Sets current address
01:A8B6 C39B87          	    17: 	jp		SetAddress				;
01:A8B9 42414E4B        	    18: 	db		"BANK"					; Sets current bank
01:A8BD C3BC87          	    19: 	jp		SetBank					;
01:A8C0 4241534943      	    20: 	db		"BASIC"					; Tiny Basic
01:A8C5 C3458B          	    21: 	jp		BASIC					;
01:A8C8 434C53          	    22: 	db		"CLS"					; Clear screen command
01:A8CB C3AA82          	    23: 	jp		ClearScreen				;
01:A8CE 434F5059        	    24: 	db		"COPY"					; Copy data from one place to another (destructive)
01:A8D2 C3B382          	    25: 	jp		CopyBlock				;
01:A8D5 44494147        	    26: 	db		"DIAG"					; Test RAM (and eventually other system components)
01:A8D9 C31883          	    27: 	jp		Diagnostics				;
01:A8DC 46494C4C        	    28: 	db		"FILL"					; Fill a region of memory with a byte of data 
01:A8E0 C3E883          	    29: 	jp		FillMemory				;
                        	    30: ;	db		"FORTH"					; Camel Forth
                        	    31: ;	jp		FORTH					;
01:A8E3 44554D50        	    32: 	db		"DUMP"					; Hex dump command
01:A8E7 C38784          	    33: 	jp		HexDump					;
01:A8EA 4C495354        	    34: 	db		"LIST"					; List of commands
01:A8EE C3D385          	    35: 	jp		ListCmd					;
01:A8F1 4C4F4144        	    36: 	db		"LOAD"					; Intel Hex load command
01:A8F5 C30385          	    37: 	jp		IntelHex				;
01:A8F8 5045454B        	    38: 	db		"PEEK"					; Read a byte of memory
01:A8FC C3E285          	    39: 	jp		PeekCmd					;
01:A8FF 504F4B45        	    40: 	db		"POKE"					; Write a byte of memory (destructive)
01:A903 C31186          	    41: 	jp		PokeCmd					;
01:A906 524547          	    42: 	db		"REG"					; Prints the content of the registers
01:A909 C34E86          	    43: 	jp		Registers				;
01:A90C 52554E          	    44: 	db		"RUN"					; Execute a program in RAM
01:A90F C38887          	    45: 	jp		RunCode					;
01:A912 535953494E464F  	    46: 	db		"SYSINFO"				; Info command
01:A919 C3ED87          	    47: 	jp		SysInfo					;
01:A91C 5752495445      	    48: 	db		"WRITE"					; Write up to 8 bytes of data
01:A921 C30A88          	    49: 	jp		Write					;
01:A924 5A45524F        	    50: 	db		"ZERO"					; Zero all memory, including banks
01:A928 C35A88          	    51: 	jp		ZeroAllRam				;
01:A92B FF              	    52: 	db		EOT
                        	    53: 
                        	    54: ListOfCommands:
                        	    55: 	;		"                                        "
01:A92C 0A              	    56: 	db		LF
01:A92D 4D6F6E69746F7220	    57: 	db		"Monitor Commands",CR,LF,0
01:A935 436F6D6D616E6473
01:A93D 0D
01:A93E 0A
01:A93F 00
01:A940 2D2041444452205B	    58: 	db		"- ADDR [AAAA]: Sets current address",CR,LF
01:A948 414141415D3A2053
01:A950 6574732063757272
01:A958 656E742061646472
01:A960 657373
01:A963 0D
01:A964 0A
01:A965 2D2042414E4B205B	    59: 	db		"- BANK [N]: Sets current bank",CR,LF
01:A96D 4E5D3A2053657473
01:A975 2063757272656E74
01:A97D 2062616E6B
01:A982 0D
01:A983 0A
01:A984 2D2042415349433A	    60: 	db		"- BASIC: Nascom MS BASIC",CR,LF
01:A98C 204E6173636F6D20
01:A994 4D53204241534943
01:A99C 0D
01:A99D 0A
01:A99E 2D20434C533A2043	    61: 	db		"- CLS: Clear screen",CR,LF
01:A9A6 6C65617220736372
01:A9AE 65656E
01:A9B1 0D
01:A9B2 0A
01:A9B3 2D20434F50592053	    62: 	db		"- COPY SSSS DDDD BBBB: Copy memory block"
01:A9BB 5353532044444444
01:A9C3 20424242423A2043
01:A9CB 6F7079206D656D6F
01:A9D3 727920626C6F636B
01:A9DB 2D20444941473A20	    63: 	db		"- DIAG: Diagnostics (RAM)",CR,LF
01:A9E3 446961676E6F7374
01:A9EB 696373202852414D
01:A9F3 29
01:A9F4 0D
01:A9F5 0A
01:A9F6 2D2044554D50205B	    64: 	db		"- DUMP [AAAA] [LL]: Memory hex dump",CR,LF
01:A9FE 414141415D205B4C
01:AA06 4C5D3A204D656D6F
01:AA0E 7279206865782064
01:AA16 756D70
01:AA19 0D
01:AA1A 0A
01:AA1B 2D2046494C4C2053	    65: 	db		"- FILL SSSS EEEE BB: Fill memory",CR,LF
01:AA23 5353532045454545
01:AA2B 2042423A2046696C
01:AA33 6C206D656D6F7279
01:AA3B 0D
01:AA3C 0A
                        	    66: ;	db		"- FORTH: Camel Forth, by Brad Rodriguez",CR,LF
01:AA3D 2D204C4953543A20	    67: 	db		"- LIST: List of commands",CR,LF
01:AA45 4C697374206F6620
01:AA4D 636F6D6D616E6473
01:AA55 0D
01:AA56 0A
01:AA57 2D204C4F41443A20	    68: 	db		"- LOAD: Intel Hex loader",CR,LF
01:AA5F 496E74656C204865
01:AA67 78206C6F61646572
01:AA6F 0D
01:AA70 0A
01:AA71 2D205045454B3A20	    69: 	db		"- PEEK: Read a byte of memory",CR,LF
01:AA79 5265616420612062
01:AA81 797465206F66206D
01:AA89 656D6F7279
01:AA8E 0D
01:AA8F 0A
01:AA90 2D20504F4B453A20	    70: 	db		"- POKE: Write a byte in memory",CR,LF
01:AA98 5772697465206120
01:AAA0 6279746520696E20
01:AAA8 6D656D6F7279
01:AAAE 0D
01:AAAF 0A
01:AAB0 2D205245473A205A	    71: 	db		"- REG: Z80 registers",CR,LF
01:AAB8 3830207265676973
01:AAC0 74657273
01:AAC4 0D
01:AAC5 0A
01:AAC6 2D2052554E205B41	    72: 	db		"- RUN [AAAA]: Esecute a program",CR,LF
01:AACE 4141415D3A204573
01:AAD6 6563757465206120
01:AADE 70726F6772616D
01:AAE5 0D
01:AAE6 0A
01:AAE7 2D20535953494E46	    73: 	db		"- SYSINFO: System information",CR,LF
01:AAEF 4F3A205379737465
01:AAF7 6D20696E666F726D
01:AAFF 6174696F6E
01:AB04 0D
01:AB05 0A
01:AB06 2D20575249544520	    74: 	db		"- WRITE AAAA BB [BB]...: Write x bytes",CR,LF
01:AB0E 4141414120424220
01:AB16 5B42425D2E2E2E3A
01:AB1E 2057726974652078
01:AB26 206279746573
01:AB2C 0D
01:AB2D 0A
01:AB2E 2D205A45524F3A20	    75: 	db		"- ZERO: Zero free RAM, banks included",CR,LF
01:AB36 5A65726F20667265
01:AB3E 652052414D2C2062
01:AB46 616E6B7320696E63
01:AB4E 6C75646564
01:AB53 0D
01:AB54 0A
01:AB55 0A              	    76: 	db		LF
01:AB56 202A205479706520	    77: 	db		" * Type ? in command parameter for help",CR,LF
01:AB5E 3F20696E20636F6D
01:AB66 6D616E6420706172
01:AB6E 616D657465722066
01:AB76 6F722068656C70
01:AB7D 0D
01:AB7E 0A
01:AB7F 0A              	    78: 	db		LF,0
01:AB80 00
                        	    79: 
                        	    80: FlagBits:
01:AB81 737A68766E63    	    81: 	db		"szhvnc"				; Flag short hand. Use UpperCase to indicate set, else lowercase indicated clear
                        	    82: 	
                        	    83: ClearScreenSeq:
01:AB87 1B              	    84: 	db		ESC, "[", "2", "J"		; Clears the screen
01:AB88 5B
01:AB89 32
01:AB8A 4A
01:AB8B 1B              	    85: 	db		ESC, "[", "0", "1", ";", "0", "1", "H", 0 ; Sets to home position
01:AB8C 5B
01:AB8D 30
01:AB8E 31
01:AB8F 3B
01:AB90 30
01:AB91 31
01:AB92 48
01:AB93 00
                        	    86: 	
                        	    87: SysInfoMsg:
                        	    88: 	;		"                                        "
01:AB94 0A              	    89: 	db		LF
01:AB95 5A65644569676874	    90: 	db		"ZedEighty System Information",CR,LF,0
01:AB9D 792053797374656D
01:ABA5 20496E666F726D61
01:ABAD 74696F6E
01:ABB1 0D
01:ABB2 0A
01:ABB3 00
01:ABB4 2D204350553A2020	    91: 	db		"- CPU:   Z84C00 Z80 @",0,"7.3728 MHz",CR,LF
01:ABBC 205A383443303020
01:ABC4 5A38302040
01:ABC9 00
01:ABCA 372E33373238204D
01:ABD2 487A
01:ABD4 0D
01:ABD5 0A
01:ABD6 2D20524F4D3A2020	    92: 	db		"- ROM:   64KB FLASH (Shadow ROM)",CR,LF
01:ABDE 2036344B4220464C
01:ABE6 4153482028536861
01:ABEE 646F7720524F4D29
01:ABF6 0D
01:ABF7 0A
01:ABF8 2D2052414D3A2020	    93: 	db		"- RAM:   64KB SRAM, ",0," bytes free",CR,LF
01:AC00 2036344B42205352
01:AC08 414D2C20
01:AC0C 00
01:AC0D 2062797465732066
01:AC15 726565
01:AC18 0D
01:AC19 0A
01:AC1A 2D2042414E4B533A	    94: 	db		"- BANKS: 480KB (15x 32KB in low RAM)",CR,LF
01:AC22 203438304B422028
01:AC2A 3135782033324B42
01:AC32 20696E206C6F7720
01:AC3A 52414D29
01:AC3E 0D
01:AC3F 0A
01:AC40 2D20554152543A20	    95: 	db		"- UART:  Z84C40 SIO/0",CR,LF
01:AC48 205A383443343020
01:AC50 53494F2F30
01:AC55 0D
01:AC56 0A
01:AC57 0A              	    96: 	db		LF,0
01:AC58 00
                        	    97: 
                        	    98: 
                        	    99: ;  __  __                                                 
                        	   100: ; |  \/  |   ___   ___   ___    __ _    __ _    ___   ___ 
                        	   101: ; | |\/| |  / _ \ / __| / __|  / _` |  / _` |  / _ \ / __|
                        	   102: ; | |  | | |  __/ \__ \ \__ \ | (_| | | (_| | |  __/ \__ \
                        	   103: ; |_|  |_|  \___| |___/ |___/  \__,_|  \__, |  \___| |___/
                        	   104: ;                                      |___/
                        	   105: ; ---------------------------------------------------------------------------------------------------------------------
                        	   106: ; SYSTEM MESSAGES, AND ERROR MESSAGES
                        	   107: 
                        	   108: 
01:AC59 436F6D6D616E6420	   109: ParseInvalidErr:		db	"Command not found or invalid syntax",CR,LF,0
01:AC61 6E6F7420666F756E
01:AC69 64206F7220696E76
01:AC71 616C69642073796E
01:AC79 746178
01:AC7C 0D
01:AC7D 0A
01:AC7E 00
01:AC7F 496E76616C696420	   110: InvalidHexDigitErr:		db	"Invalid hexadecimal digit in parameter",CR,LF,0
01:AC87 6865786164656369
01:AC8F 6D616C2064696769
01:AC97 7420696E20706172
01:AC9F 616D65746572
01:ACA5 0D
01:ACA6 0A
01:ACA7 00
01:ACA8 546F6F206D616E79	   111: TooManyDigitsErr:		db	"Too many number of digits in parameter",CR,LF,0
01:ACB0 206E756D62657220
01:ACB8 6F66206469676974
01:ACC0 7320696E20706172
01:ACC8 616D65746572
01:ACCE 0D
01:ACCF 0A
01:ACD0 00
01:ACD1 4D697373696E6720	   112: MissingParameterErr:	db	"Missing Parameter(s)",CR,LF,0
01:ACD9 506172616D657465
01:ACE1 72287329
01:ACE5 0D
01:ACE6 0A
01:ACE7 00
01:ACE8 556E7265636F676E	   113: UnrecognizedParamErr:	db	"Unrecognized parameter",CR,LF,0
01:ACF0 697A656420706172
01:ACF8 616D65746572
01:ACFE 0D
01:ACFF 0A
01:AD00 00
01:AD01 5374617274206772	   114: StartGreaterEndErr:		db	"Start greater than end address",CR,LF,0
01:AD09 6561746572207468
01:AD11 616E20656E642061
01:AD19 646472657373
01:AD1F 0D
01:AD20 0A
01:AD21 00
01:AD22 5265636F72642074	   115: IntelHexUnsupportedErr:	db	"Record type unsupported: ",0
01:AD2A 79706520756E7375
01:AD32 70706F727465643A
01:AD3A 20
01:AD3B 00
01:AD3C 5265736572766564	   116: InvalidVectorRangeErr:	db	"Reserved vector/stack area",CR,LF,0
01:AD44 20766563746F722F
01:AD4C 737461636B206172
01:AD54 6561
01:AD56 0D
01:AD57 0A
01:AD58 00
01:AD59 5265736572766564	   117: ReservedBiosAreaErr:	db	"Reserved BIOS range",CR,LF,0
01:AD61 2042494F53207261
01:AD69 6E6765
01:AD6C 0D
01:AD6D 0A
01:AD6E 00
01:AD6F 52616E6765206973	   118: RangeTooSmallErr:		db	"Range is null or too small",CR,LF,0
01:AD77 206E756C6C206F72
01:AD7F 20746F6F20736D61
01:AD87 6C6C
01:AD89 0D
01:AD8A 0A
01:AD8B 00
01:AD8C 496E76616C696420	   119: InvalidBankNumberErr:	db	"Invalid bank number ($0-$E)",CR,LF,0
01:AD94 62616E6B206E756D
01:AD9C 626572202824302D
01:ADA4 244529
01:ADA7 0D
01:ADA8 0A
01:ADA9 00
01:ADAA 496E76616C696420	   120: InvalidDecimalNumberErr	db	"Invalid decimal number",CR,LF,0
01:ADB2 646563696D616C20
01:ADBA 6E756D626572
01:ADC0 0D
01:ADC1 0A
01:ADC2 00
01:ADC3 4E756D6265722069	   121: NumberOutOfRangeErr		db	"Number is out of range",CR,LF,0
01:ADCB 73206F7574206F66
01:ADD3 2072616E6765
01:ADD9 0D
01:ADDA 0A
01:ADDB 00
01:ADDC 4572726F72206174	   122: BadMemory1Err:			db	"Error at ",0
01:ADE4 20
01:ADE5 00
01:ADE6 2C20676F7420    	   123: BadMemory2Err:			db	", got ",0,", expected ",0
01:ADEC 00
01:ADED 2C20657870656374
01:ADF5 656420
01:ADF8 00
01:ADF9 4E6F7468696E6720	   124: NothingToCopyErr:		db	"Nothing to copy",CR,LF,0
01:AE01 746F20636F7079
01:AE08 0D
01:AE09 0A
01:AE0A 00
                        	   125: 
01:AE0B 54657374696E6720	   126: TestingBankNumberMsg:	db	"Testing Bank RAM #",0
01:AE13 42616E6B2052414D
01:AE1B 2023
01:AE1D 00
01:AE1E 54657374696E6720	   127: TestingHighRamMsg:		db	"Testing High RAM",CR,LF,0
01:AE26 486967682052414D
01:AE2E 0D
01:AE2F 0A
01:AE30 00
01:AE31 4D656D6F72792074	   128: MemoryTestPassedMsg:	db	"Memory test Passed",CR,LF,0
01:AE39 6573742050617373
01:AE41 6564
01:AE43 0D
01:AE44 0A
01:AE45 00
01:AE46 4164647265737320	   129: RangeMsg:				db	"Address range:",0
01:AE4E 72616E67653A
01:AE54 00
01:AE55 46696C6520747261	   130: IntelHexFinishedMsg:	db	"File transfer: ",0
01:AE5D 6E736665723A20
01:AE64 00
01:AE65 756E737563636573	   131: IntelHexSuccessMsg:		db	"unsuccessful",CR,LF,0
01:AE6D 7366756C
01:AE71 0D
01:AE72 0A
01:AE73 00
01:AE74 4C6F616420612070	   132: IntelHexLoadMsg:		db	"Load a program using Intel Hex format",CR,LF,"Press ESC to cancel",CR,LF,0
01:AE7C 726F6772616D2075
01:AE84 73696E6720496E74
01:AE8C 656C204865782066
01:AE94 6F726D6174
01:AE99 0D
01:AE9A 0A
01:AE9B 5072657373204553
01:AEA3 4320746F2063616E
01:AEAB 63656C
01:AEAE 0D
01:AEAF 0A
01:AEB0 00
01:AEB1 5472616E73666572	   133: IntelHexAbortedMsg:		db	"Transfer aborted by user",CR,LF,0
01:AEB9 2061626F72746564
01:AEC1 2062792075736572
01:AEC9 0D
01:AECA 0A
01:AECB 00
01:AECC 2062797465732074	   134: DownloadedBytesMsg:		db	" bytes transfered",CR,LF,0
01:AED4 72616E7366657265
01:AEDC 64
01:AEDD 0D
01:AEDE 0A
01:AEDF 00
                        	   135: 
                        	   136: ;					"                                        "
01:AEE0 46696C6C73206120	   137: FillHelp:		db	"Fills a range of memory with a byte.",CR,LF
01:AEE8 72616E6765206F66
01:AEF0 206D656D6F727920
01:AEF8 7769746820612062
01:AF00 7974652E
01:AF04 0D
01:AF05 0A
01:AF06 50726F7465637473	   138: 				db	"Protects the vector areas and the BIOS.",CR,LF
01:AF0E 2074686520766563
01:AF16 746F722061726561
01:AF1E 7320616E64207468
01:AF26 652042494F532E
01:AF2D 0D
01:AF2E 0A
01:AF2F 55736167653A2046	   139: 				db	"Usage: Fill 2400 A400 8A",CR,LF,LF,0
01:AF37 696C6C2032343030
01:AF3F 2041343030203841
01:AF47 0D
01:AF48 0A
01:AF49 0A
01:AF4A 00
                        	   140: 
01:AF4B 446973706C617973	   141: HexDumpHelp:	db	"Displays the content of memory. The",CR,LF
01:AF53 2074686520636F6E
01:AF5B 74656E74206F6620
01:AF63 6D656D6F72792E20
01:AF6B 546865
01:AF6E 0D
01:AF6F 0A
01:AF70 7365636F6E642070	   142: 				db	"second parameter is the number of lines.",CR,LF
01:AF78 6172616D65746572
01:AF80 2069732074686520
01:AF88 6E756D626572206F
01:AF90 66206C696E65732E
01:AF98 0D
01:AF99 0A
01:AF9A 55736167653A2044	   143: 				db	"Usage: DUMP 1000 4",CR,LF,LF,0
01:AFA2 554D502031303030
01:AFAA 2034
01:AFAC 0D
01:AFAD 0A
01:AFAE 0A
01:AFAF 00
                        	   144: 
01:AFB0 4C6F616420496E74	   145: IntelHexHelp:	db	"Load IntelHex binary programs via the",CR,LF
01:AFB8 656C486578206269
01:AFC0 6E6172792070726F
01:AFC8 6772616D73207669
01:AFD0 6120746865
01:AFD5 0D
01:AFD6 0A
01:AFD7 53494F20506F7274	   146: 				db	"SIO Port A.",CR,LF
01:AFDF 20412E
01:AFE2 0D
01:AFE3 0A
01:AFE4 55736167653A204C	   147: 				db	"Usage: LOAD",CR,LF,LF,0
01:AFEC 4F4144
01:AFEF 0D
01:AFF0 0A
01:AFF1 0A
01:AFF2 00
                        	   148: 
                        	   149: Range:
01:AFF3 E5              	   150: 	push	HL
01:AFF4 2146AE          	   151: 	ld		HL,RangeMsg
01:AFF7 CDAE80          	   152: 	call	PrintString
01:AFFA E1              	   153: 	pop		HL
01:AFFB C9              	   154: 	ret
                        	   155: 
                        	   156: InvalidVectorRange:
01:AFFC E5              	   157: 	push	HL
01:AFFD 213CAD          	   158: 	ld		HL,InvalidVectorRangeErr
01:B000 CDAE80          	   159: 	call	PrintString
01:B003 E1              	   160: 	pop		HL
01:B004 C9              	   161: 	ret
                        	   162: 
                        	   163: RangeTooSmall:
01:B005 E5              	   164: 	push	HL
01:B006 216FAD          	   165: 	ld		HL,RangeTooSmallErr
01:B009 CDAE80          	   166: 	call	PrintString
01:B00C E1              	   167: 	pop		HL
01:B00D C9              	   168: 	ret
                        	   169: 
                        	   170: BiosRange:
01:B00E E5              	   171: 	push	HL
01:B00F 2159AD          	   172: 	ld		HL,ReservedBiosAreaErr
01:B012 CDAE80          	   173: 	call	PrintString
01:B015 E1              	   174: 	pop		HL
01:B016 C9              	   175: 	ret
                        	   176: 
                        	   177: RangeInverted:
01:B017 E5              	   178: 	push	HL
01:B018 2101AD          	   179: 	ld		HL,StartGreaterEndErr
01:B01B CDAE80          	   180: 	call	PrintString
01:B01E E1              	   181: 	pop		HL
01:B01F C9              	   182: 	ret
                        	   183: 
                        	   184: NoParameter:
01:B020 E5              	   185: 	push	HL
01:B021 CDBC89          	   186: 	call	PrintErrorPointer
01:B024 21D1AC          	   187: 	ld		HL,MissingParameterErr
01:B027 CDAE80          	   188: 	call	PrintString
01:B02A E1              	   189: 	pop		HL
01:B02B C9              	   190: 	ret
                        	   191: 
                        	   192: InvalidBank:
01:B02C E5              	   193: 	push	HL
01:B02D 218CAD          	   194: 	ld		HL,InvalidBankNumberErr
01:B030 CDAE80          	   195: 	call	PrintString
01:B033 E1              	   196: 	pop		HL
01:B034 C9              	   197: 	ret
                        	   198: 
                        	   199: TooManyDigits:
01:B035 E5              	   200: 	push	HL
01:B036 21A8AC          	   201: 	ld		HL,TooManyDigitsErr
01:B039 CDAE80          	   202: 	call	PrintString
01:B03C E1              	   203: 	pop		HL
01:B03D C9              	   204: 	ret
                        	   205: 
                        	   206: InvalidHexDigit:
01:B03E E5              	   207: 	push	HL
01:B03F 217FAC          	   208: 	ld		HL,InvalidHexDigitErr
01:B042 CDAE80          	   209: 	call	PrintString
01:B045 E1              	   210: 	pop		HL
01:B046 C9              	   211: 	ret
                        	   212: 
                        	   213: NumberOutOfRange:
01:B047 E5              	   214: 	push	HL
01:B048 21C3AD          	   215: 	ld		HL,NumberOutOfRangeErr
01:B04B CDAE80          	   216: 	call	PrintString
01:B04E E1              	   217: 	pop		HL
01:B04F C9              	   218: 	ret
                        	   219: 
                        	   220: InvalidDecimalNumber:
01:B050 E5              	   221: 	push	HL
01:B051 21AAAD          	   222: 	ld		HL,InvalidDecimalNumberErr
01:B054 CDAE80          	   223: 	call	PrintString
01:B057 E1              	   224: 	pop		HL
01:B058 C9              	   225: 	ret
                        	   226: 
                        	   227: NothingToCopy:
01:B059 E5              	   228: 	push	HL
01:B05A CDBF88          	   229: 	call	DecErrorPointer
01:B05D CDBC89          	   230: 	call	PrintErrorPointer
01:B060 21F9AD          	   231: 	ld		HL,NothingToCopyErr
01:B063 CDAE80          	   232: 	call	PrintString
01:B066 E1              	   233: 	pop		HL
01:B067 C9              	   234: 	ret
                        	   235: 	

Source: "main.asm"
                        	   275: 
                        	   276: 
                        	   277: ; __     __                 _           _       _              
                        	   278: ; \ \   / /   __ _   _ __  (_)   __ _  | |__   | |   ___   ___ 
                        	   279: ;  \ \ / /   / _` | | '__| | |  / _` | | '_ \  | |  / _ \ / __|
                        	   280: ;   \ V /   | (_| | | |    | | | (_| | | |_) | | | |  __/ \__ \
                        	   281: ;    \_/     \__,_| |_|    |_|  \__,_| |_.__/  |_|  \___| |___/
                        	   282: ;
                        	   283: ; ---------------------------------------------------------------------------------------------------------------------
                        	   284: ; VARIABLES ARE DECLARED IN BYTE SIZE
                        	   285: 
01:B068 00              	   286: CommandBuffer:		ds	HorizTextRes-10	; Command prompt buffer
01:B069 *
01:B086 00              	   287: BufferPointer:		ds	2			; Buffer pointer
01:B087 *
01:B088 00              	   288: CmdErrorPointer:	ds	1			; Command line error pointer
01:B089 00              	   289: CurrentBank:		ds	1			; Keep track of current bank
01:B08A 00              	   290: CurrentAddress:		ds	2			; Current Address for prompt
01:B08B *
01:B08C 00              	   291: DigitString			ds	9			; Digit string for numeric conversions (so they are printable with PrintString)
01:B08D *
01:B095 0200            	   292: ParseSaveHL			dw	2			; Saves the HL, as HL is used to call routines, and interferes with registers
01:B097 00              	   293: RegA:				ds	1			; Register A
01:B098 00              	   294: RegBC:				ds	2			; Register BC
01:B099 *
01:B09A 00              	   295: RegDE:				ds	2			; Register DE
01:B09B *
01:B09C 00              	   296: RegHL:				ds	2			; Register HL
01:B09D *
01:B09E 00              	   297: RegIX:				ds	2			; Index IX
01:B09F *
01:B0A0 00              	   298: RegIY:				ds	2			; Index IY
01:B0A1 *
01:B0A2 00              	   299: StackPtr:			ds	2			; Index SP
01:B0A3 *
01:B0A4 00              	   300: FlagsReg:			ds	1			; Status flags
                        	   301: ;RegI:				ds	1			; 
                        	   302: ;RegR:				ds	1			; 
01:B0A5 00              	   303: StartAddress:		ds	2			; Original start or source address
01:B0A6 *
01:B0A7 00              	   304: EndAddress:			ds	2			; Original end or destination address
01:B0A8 *
01:B0A9 00              	   305: StartAddressAlt:	ds	2			; Original start or source address
01:B0AA *
01:B0AB 00              	   306: EndAddressAlt: 		ds	2			; Original end or destination address
01:B0AC *
01:B0AD 00              	   307: ByteTransfer:		ds	1			; Byte to copy/transfer
01:B0AE 00              	   308: UserCodeSize		ds	2			; Size of uploaded user code 
01:B0AF *
01:B0B0 00              	   309: SREM				ds	1			; Signed remainder
01:B0B1 00              	   310: SQUOT				ds	1			; Signed quotient
                        	   311: 
                        	   312: EndOfCode:
01:B0B2 FF              	   313: 	ds	VectorTable-$,$FF			; Fill gap with $FF to optimize speed when programming the FLASH/EEPROM
01:B0B3 *
                        	   314: 
                        	   315: 
                        	   316: ; __     __                _                      _____           _       _        
                        	   317: ; \ \   / /   ___    ___  | |_    ___    _ __    |_   _|   __ _  | |__   | |   ___ 
                        	   318: ;  \ \ / /   / _ \  / __| | __|  / _ \  | '__|     | |    / _` | | '_ \  | |  / _ \
                        	   319: ;   \ V /   |  __/ | (__  | |_  | (_) | | |        | |   | (_| | | |_) | | | |  __/
                        	   320: ;    \_/     \___|  \___|  \__|  \___/  |_|        |_|    \__,_| |_.__/  |_|  \___|
                        	   321: ;
                        	   322: ; ---------------------------------------------------------------------------------------------------------------------
                        	   323: ; CONSTANT VALUES SO EXTERNALLY LOADED PROGRAMS CAN ACCESS SPECIFIC INFORMATION
                        	   324: 	.org	$FD00
                        	   325: 
                        	   326: VectorTable:
                        	   327: 
02:FD00 8000            	   328: IntVectorEnd:		dw	InterruptVectorEnd	;= $FD00			; End of interrupt vector table
02:FD02 00FD            	   329: VectorTableStart:	dw	VectorTable			;= $FD02			; Start of vector and jump tables
02:FD04 0080            	   330: CodeStartAddr:		dw	StartOfCode			;= $FD04			; Start of code address
02:FD06 B2B0            	   331: CodeEndAddr:		dw	EndOfCode			;= $FD06			; End of code address
                        	   332: 
02:FD08 FF              	   333: 	ds	JumpTable-$,$FF				; $FF up to the jump table
02:FD09 *
                        	   334: 
                        	   335: 
                        	   336: ;      _                                 _____           _       _        
                        	   337: ;     | |  _   _   _ __ ___    _ __     |_   _|   __ _  | |__   | |   ___ 
                        	   338: ;  _  | | | | | | | '_ ` _ \  | '_ \      | |    / _` | | '_ \  | |  / _ \
                        	   339: ; | |_| | | |_| | | | | | | | | |_) |     | |   | (_| | | |_) | | | |  __/
                        	   340: ;  \___/   \__,_| |_| |_| |_| | .__/      |_|    \__,_| |_.__/  |_|  \___|
                        	   341: ;                             |_|                                         
                        	   342: ; ---------------------------------------------------------------------------------------------------------------------
                        	   343: ; JUMP TABLE TO CALL ROUTINES FROM AN EXTERNAL PROGRAM
                        	   344: 
                        	   345: 	.org	$FE00
                        	   346: 	
                        	   347: JumpTable:
03:FE00 C36981          	   348: 	jp		Ascii2HexNibble		;= $FE00				; [A -> A][A -> A]
03:FE03 C38D81          	   349: 	jp		Ascii2HexByte		;= $FE03				; [(HL) -> A][(HL) -> A]
03:FE06 C3AC81          	   350: 	jp		Ascii2HexWord		;= $FE06				; [(HL) -> BC][(HL) -> BC]
03:FE09 C3AA82          	   351: 	jp		ClearScreen			;= $FE09				; [][]
03:FE0C C3C988          	   352: 	jp		GetHexParameter		;= $FE0C				; [(HL) -> BC,A,(HL)][(HL) -> BC,A,(HL)]
03:FE0F C37480          	   353: 	jp		PrintChar			;= $FE0F				; [A ->][A ->]
03:FE12 C3AE80          	   354: 	jp		PrintString			;= $FE12				; [HL ->][HL ->]
03:FE15 C37F80          	   355: 	jp		PrintCRLF			;= $FE15				; [][]
03:FE18 C39E80          	   356: 	jp		PrintNibble			;= $FE18				; [A ->][A ->]
03:FE1B C36180          	   357: 	jp		PrintByte			;= $FE1B				; [A ->][A ->]
03:FE1E C3BC80          	   358: 	jp		PrintWord			;= $FE1E				; [HL ->][HL ->]
03:FE21 C3D489          	   359: 	jp		RangeValidation		;= $FE21				; Start&EndAddress -> C, Start&EndAddress, Start&EndAddressAlt)
03:FE24 C3C780          	   360: 	jp		ReadChar			;= $FE24				; [-> A][-> A]
03:FE27 C3D080          	   361: 	jp		ReadCharNoWait		;= $FE27
03:FE2A C3EE80          	   362: 	jp		ReadString			;= $FE2A				; [HL ->][HL ->]
03:FE2D C3DB80          	   363: 	jp		ReadByte			;= $FE2D				; [-> A][-> A]
03:FE30 C33D81          	   364: 	jp		ReadWord			;= $FE30				; [-> HL][-> HL]
03:FE33 C3378B          	   365: 	jp		SkipSpaces			;= $FE33				; [HL -> HL][HL -> HL]
03:FE36 C39F82          	   366: 	jp		UpperCase			;= $FE36				; [A -> A][A -> A]
03:FE39 C34E86          	   367: 	jp		Registers			;= $FE39				; [][]
03:FE3C C3BF81          	   368: 	jp		Dec2Hex				;= $FE3C				; [(HL) -> BC]
                        	   369: 
                        	   370: VectorEnd:
03:FE3F FF              	   371: 	ds		StackPage-$,$FF		; $FF the rest of the jump table all the way to the stack area
03:FE40 *
                        	   372: 
                        	   373: 
                        	   374: ;  ____    _                    _    
                        	   375: ; / ___|  | |_    __ _    ___  | | __
                        	   376: ; \___ \  | __|  / _` |  / __| | |/ /
                        	   377: ;  ___) | | |_  | (_| | | (__  |   < 
                        	   378: ; |____/   \__|  \__,_|  \___| |_|\_\
                        	   379: ;
                        	   380: ; ---------------------------------------------------------------------------------------------------------------------
                        	   381: ; STACK AREA, ClEAR OUT WITH ZEROS
                        	   382: 
                        	   383: 	.org	$FF00
                        	   384: 
                        	   385: StackPage:
                        	   386: 
04:FF00 00              	   387: 	ds		$FFFF-$,$00			; Zero the stack all the way to end of ROM
04:FF01 *
                        	   388: 
                        	   389: BiosEnd:
                        	   390: .end


Symbols by name:
ABPASS                           A:9BF3
ABS                              A:A23F
ACCSUM                           A:945C
ACPASS                           A:9BF2
ADD30                            A:A751
ADD301                           A:A761
ADDEXP                           A:A1D8
ADDIG                            A:A37E
ADDPHL                           A:9FC5
ALLFOL                           A:9EC1
ANTVLU                           A:975C
ARET                             A:A6CF
ARETN                            A:A81A
ARLDSV                           A:9B13
ARREND                           E:10DA
ARRLP                            A:9D8C
ASCC                             A:9E92
Ascii2BcdDigit                   A:8169
Ascii2HexByte                    A:818D
Ascii2HexByteErr                 A:81A9
Ascii2HexNibble                  A:8169
Ascii2HexNibbleEnd               A:8186
Ascii2HexNibbleErr               A:818B
Ascii2HexNibbleOK                A:817E
Ascii2HexWord                    A:81AC
Ascii2HexWordErr                 A:81BC
ASCTFP                           A:A321
ASPCS                            A:96BE
ATN                              A:A683
ATN1                             A:A6A0
ATNTAB                           A:A6AA
ATOH                             A:9497
BADINP                           A:96E3
BadMemory1Err                    A:ADDC
BadMemory2Err                    A:ADE6
BAKSTK                           A:8F19
BAKTMP                           A:9E72
BankCopyLoop                     A:0083
BankSelect                       E:0030
BASIC                            A:8B45
BASTXT                           E:105E
BCDEFP                           A:A266
BFREE                            A:8C71
BIN                              A:A7A3
BIN2                             A:A7A9
BINERR                           A:A800
BINIT                            A:A7DF
BINTFP                           A:A7D5
BiosEnd                          A:FFFF
BiosRange                        A:B00E
BITOUT                           A:A7BD
BITOUT2                          A:A7C1
BKSP                             E:0008
BN                               E:0028
BNORM                            A:A025
BNRMLP                           A:A028
BootMsg                          A:A829
BRK                              A:940E
BRKFLG                           E:104D
BRKLIN                           E:10CE
BRKMSG                           A:8F13
BRKRET                           A:8C6B
BS                               E:0010
BSERR                            A:9B46
BUFFER                           E:1061
BufferPointer                    A:B086
BYT2ASC                          A:A748
BytesFree                        E:CBCE
ByteTransfer                     A:B0AD
BYTSFT                           A:A15D
Carry                            E:0000
CFEVAL                           A:9AA9
CHARTY                           A:9A57
CheckIfCold                      A:8B54
CheckIfWarm                      A:8B61
ChecksumErr                      E:0001
CHEKFN                           A:9C8A
CHKBIN                           A:A7F2
CHKLTR                           A:9469
CHKSTK                           A:8F4D
CHKSUM                           E:104A
CHKSYN                           A:923E
CHKTYP                           A:983D
CHR                              A:9EA3
CLEAR                            A:94BC
ClearScreen                      A:82AA
ClearScreenSeq                   A:AB87
CLOTST                           A:9273
CLREG                            A:90A2
CLRPTR                           A:907D
CLS                              A:A6D4
CmdErrorPointer                  A:B088
CMPFP                            A:A2AF
CMPLG1                           A:99BD
CMPLOG                           A:99BB
CMPNUM                           A:A295
CMPRES                           A:99FF
CMPSTR                           A:99E7
CN                               E:0020
CNVNUM                           A:A32D
CodeEndAddr                      A:FD06
CodeStartAddr                    A:FD04
COLD                             A:8BCA
ColdOrWarm                       A:8B4E
COMMAN                           E:1043
CommandBuffer                    A:B068
CommandList                      A:A8B2
CommandPrompt                    A:889F
COMPL                            A:A085
CONCAT                           A:9E07
CONEXP                           A:A35D
CONPOS                           A:A022
CONT                             A:9441
CONTAD                           E:10D4
CONVAR                           A:9928
CopyBlock                        A:82B3
CopyDestinationAddress           A:82C8
CopyEnd                          A:8313
CopyNoOverlap                    A:8307
CopyNoParameter                  A:830B
CopyNothing                      A:8310
CopyNumberOfBytes                A:82D6
CopySourceAddress                A:82BA
COPYY                            A:8BE4
COS                              A:A607
COUNT                            A:92E3
CPDEHL                           A:9238
CPYLIT                           A:9174
CR                               E:000D
CRARLP                           A:9B66
CREARY                           A:9B4B
CRESTR                           A:95BB
CRNCLP                           A:90D5
CRTMST                           A:9CC3
CRTST                            A:9CCF
CRTSTE                           A:9CE5
CRUNCH                           A:90CC
CSTART                           A:8BD5
CTLOFG                           E:1045
CTRLC                            E:0003
CTRLG                            E:0007
CTRLO                            E:000F
CTRLQ                            E:0011
CTRLR                            E:0012
CTRLS                            E:0013
CTRLU                            E:0015
CUROPR                           E:10C5
CURPOS                           E:10AB
CurrentAddress                   A:B08A
CurrentBank                      A:B089
DATAA                            A:9562
DATFLG                           E:10AE
DATLIN                           E:10C9
DATSNR                           A:8F6A
DCBCDE                           A:A2E6
DD                               E:0012
DDERR                            A:8F79
Dec2Hex                          A:81BF
Dec2HexEnd                       A:8209
Dec2HexInvalidDec                A:8202
Dec2HexLoop                      A:81C8
Dec2HexOutOfRange                A:81FC
Dec2HexShuffleRegs               A:81F6
DecErrorPointer                  A:88BF
DEEK                             A:A6EE
DEF                              A:9C07
DEFSIZ                           A:9B6E
DEINT                            A:947D
DEL                              E:007F
DELCHR                           A:91A4
DELIMITER                        E:0020
DEPINT                           A:9477
DETHL4                           A:A275
DETHLB                           A:A277
DiagMemoryAddr                   A:83AC
DiagMemoryError                  A:8395
Diagnostics                      A:8318
DiagnosticsBankLoop              A:8326
DiagnosticsEnd                   A:83CF
DiagnosticsEnd2                  A:83DF
DiagnosticsTest                  A:8361
DiagnosticsTestLoop              A:8364
DigitString                      A:B08C
DIGTXT                           A:A427
DIM                              A:9A29
DIMRET                           A:9A20
DINPOS                           A:926D
DIV                              A:A16E
DIV1                             E:100A
DIV10                            A:A162
DIV2                             E:100E
DIV3                             E:1012
DIV4                             E:1015
DIVLP                            A:A195
DIVSUP                           E:1009
DOAGN                            A:90BB
DOCOM                            A:968F
DODEL                            A:9184
DOEBIT                           A:A467
DOFN                             A:9C34
DOKE                             A:A6F9
DONULL                           A:967D
DOSPC                            A:96B9
DOTAB                            A:96A6
DownloadedBytesMsg               A:AECC
DPOINT                           A:A359
DTSTR                            A:9CD3
DVBCDE                           A:A170
DZ                               E:0014
DZERR                            A:8F73
ECHDEL                           A:9198
EDIGIT                           A:A3A0
EndAddress                       A:B0A7
EndAddressAlt                    A:B0AB
ENDBUF                           A:917B
ENDCON                           A:A36C
ENDDIM                           A:9BCD
ENDINP                           A:966E
ENDNAM                           A:9A4B
EndOfCode                        A:B0B2
ENDPRG                           A:941D
ENFMEM                           A:8F56
EOT                              E:00FF
ERRIN                            A:8FA4
ERRLIN                           E:10D2
ERRMSG                           A:8F01
ERROR                            A:8F84
ERRORPTR                         E:005E
ErrorPtrOffset                   E:0008
ERRORS                           A:8E77
ESC                              E:001B
EVAL                             A:984A
EVAL1                            A:984D
EVAL2                            A:9856
EVAL3                            A:9859
EVLPAR                           A:990F
EVNOT                            A:9A09
EXCUTE                           A:93A8
EXPLP                            A:A34B
EXPP                             A:A501
EXPTAB                           A:A541
EXPTEN                           A:A479
EXTIG                            A:97B8
FANDT                            A:97E2
FC                               E:0008
FCERR                            A:9492
FDTLP                            A:97C9
FillByte                         A:8412
FillEndAddr                      A:8405
FillHelp                         A:AEE0
FillMemory                       A:83E8
FillMemoryEnd                    A:8482
FillNoParameter                  A:8476
FillPrintHelp                    A:847C
FillRange1                       A:8424
FillRange2                       A:844C
FillStartAddr                    A:83EF
FINDEL                           A:9BA9
FlagBits                         A:AB81
FlagCarryClear                   A:8778
FlagHalfClear                    A:8754
FlagNegativeClear                A:876C
FlagOverClear                    A:8760
FlagSignClear                    A:873C
FlagsReg                         A:B0A4
FlagZeroClear                    A:8748
FLGDIF                           A:A225
FLGREL                           A:A22C
FNARG                            E:10E0
FNCTAB                           A:8CC1
FNDARY                           A:9B19
FNDELP                           A:9BAE
FNDEND                           A:9050
FNDNUM                           A:9F96
FNDTOK                           A:92C2
FNDVAR                           A:9A90
FNDWRD                           A:90FF
FNOFST                           A:9939
FNRGNM                           E:10DE
FNTHR                            A:9A9E
FNVAL                            A:9960
FOPRND                           A:9882
FOR                              A:930F
FORFLG                           E:10CB
FORFND                           A:933F
FORSLP                           A:9323
FPADD                            A:9FD4
FPBCDE                           A:A25B
FPEXP                            E:10E7
FPINT                            A:A2C2
FPMULT                           A:A10F
FPREG                            E:10E4
FPROND                           A:A06C
FPSINT                           A:9471
FPTHL                            A:A272
FRE                              A:9BD1
FRENUM                           A:9BED
FRMEVL                           A:992B
GARBGE                           A:9D54
GARBLP                           A:9D57
GETCHR                           A:93C8
GETCMD                           A:8FC8
GetErrorPointerLoop              A:8935
GETHEX                           A:A77E
GetHexParameter                  A:88C9
GETINP                           A:A6D0
GETINT                           A:9F99
GETLEN                           A:9E87
GETLIN                           A:91B5
GETLN                            A:9498
GETNUM                           A:9838
GETNXT                           A:911A
GetParamCount                    A:88CF
GetParamErrorEnd                 A:8948
GetParameterEnd                  A:892C
GetParamFetch                    A:88E0
GetParamFetch0                   A:88E5
GetParamFetch1                   A:88ED
GetParamFetch2                   A:88FD
GetParamFetch3                   A:890B
GetParamFetch4                   A:8921
GetParamHelp                     A:892E
GetParamHexError                 A:8942
GetParamNumberError              A:8933
GETSTR                           A:9E51
GETVAR                           A:9A2E
GNXARY                           A:9D8B
GOFUNC                           A:9968
GOSUB                            A:950E
GOTO                             A:951F
GRBARY                           A:9DAB
GRBDON                           A:9D2C
GRBLP                            A:9D65
GSTRCU                           A:9E54
GSTRDE                           A:9E58
GSTRHL                           A:9E57
GTFLNM                           A:9E96
GTFNAM                           A:9A33
GTLNLP                           A:949B
GTSIXD                           A:A3F1
GTVLUS                           A:9734
HALF                             A:A498
HalfCarry                        E:0004
HALFPI                           A:A651
HELP                             E:000F
HEX                              A:A710
HEX1                             A:A729
HEX2                             A:A72B
Hex2Dec                          A:820C
Hex2Dec1                         A:8289
Hex2Dec10                        A:826C
Hex2Dec100                       A:824F
Hex2Dec1000                      A:8232
Hex2Dec10000                     A:8217
Hex2Dec10000Loop                 A:8219
Hex2Dec10000Set                  A:8229
Hex2Dec1000Loop                  A:8234
Hex2Dec1000Set                   A:8246
Hex2Dec100Loop                   A:8251
Hex2Dec100Set                    A:8263
Hex2Dec10Loop                    A:826E
Hex2Dec10Set                     A:8280
Hex2DecEnd                       A:8296
HEX3                             A:A739
HEX4                             A:A73B
HexDefaultLines                  A:84B2
HexDisplayContent                A:84B4
HexDump                          A:8487
HexDumpEnd                       A:84FE
HexDumpHelp                      A:AF4B
HexDumpPrintHelp                 A:84F8
HEXIT                            A:A795
HexLinesToRead                   A:849F
HEXLP                            A:A771
HEXLP1                           A:A776
HexNextByte                      A:84C5
HexNextChar                      A:84D8
HexNextLine                      A:84B5
HexPrintChar                     A:84E5
HexReplaceDot                    A:84E3
HEXTFP                           A:A765
HorizTextRes                     E:0028
HX                               E:0026
HXERR                            A:A79E
ID                               E:0016
IDTEST                           A:9C7C
IFF                              A:95F1
IFGO                             A:95FF
IFJMP                            A:93AF
IncErrorPointer                  A:894A
INCHL                            A:A270
INCLEN                           A:9269
INDFND                           A:8F33
INEWLN                           A:9018
INIT                             A:8BDC
INITAB                           A:8EA1
INITBE                           A:8F01
INITST                           A:A812
INMSG                            A:8F08
INP                              A:9F56
INPBIN                           A:9786
INPBRK                           A:941A
INPORT                           E:103F
INPSUB                           E:103E
INPUT                            A:96F4
INRNG                            A:A3FA
INT                              A:A2ED
IntelHex                         A:8503
IntelHexAbort                    A:85A8
IntelHexAbortedMsg               A:AEB1
IntelHexAddress                  A:8535
IntelHexByteCount                A:8530
IntelHexCheckOk                  A:8576
IntelHexChecksum                 A:8568
IntelHexData                     A:855D
IntelHexEnd                      A:85CC
IntelHexFinishedMsg              A:AE55
IntelHexHelp                     A:AFB0
IntelHexLoadMsg                  A:AE74
IntelHexParamError               A:85BE
IntelHexPrintEndMsg              A:8583
IntelHexPrintHelp                A:85C6
IntelHexPrintNotOk               A:8595
IntelHexPrintStatus              A:8578
IntelHexRecordType               A:854A
IntelHexStartCode                A:8522
IntelHexSuccessMsg               A:AE65
IntelHexUnsupported              A:85B0
IntelHexUnsupportedErr           A:AD22
InterruptVectorEnd               A:0080
INTVAR                           A:908C
IntVectorEnd                     A:FD00
InvalidBank                      A:B02C
InvalidBankNumberErr             A:AD8C
InvalidDecimalNumber             A:B050
InvalidDecimalNumberErr          A:ADAA
InvalidHexDigit                  A:B03E
InvalidHexDigitErr               A:AC7F
InvalidVectorRange               A:AFFC
InvalidVectorRangeErr            A:AD3C
INVSGN                           A:A243
ITMSEP                           A:9777
JJUMP1                           A:A805
JSTZER                           A:A483
JUMP                             E:00C3
JumpTable                        A:FE00
KILFOR                           A:9828
KILIN                            A:91AF
LastRec                          E:0007
LCRFLG                           E:10AC
LEFT                             A:9EB3
LEN                              A:9E83
LET                              A:9579
LETNUM                           A:95CC
LETSTR                           A:9594
LF                               E:000A
LFRGNM                           A:9F4C
LINEAT                           E:105C
LINEIN                           A:A3AC
LINES                            A:A6DF
LINESC                           E:1046
LINESN                           E:1048
LINFND                           A:9001
ListCmd                          A:85D3
LISTLP                           A:9290
ListOfCommands                   A:A92C
LISTT                            A:9284
LOADFP                           A:A269
LOG                              A:A0CE
LOGTAB                           A:A0C1
LOKFOR                           A:8F1D
LOOPST                           E:10C7
LS                               E:001C
LSTBIN                           E:10CC
LSTLP2                           A:92B0
LSTLP3                           A:92B3
LSTRAM                           E:10AF
LSTRND                           E:103A
LTSTND                           A:9791
LWIDTH                           E:1042
Main                             A:8044
MAKINT                           A:9F9C
MAKNUM                           A:A416
MANLP                            A:A335
MATCH                            A:914C
MEMMSG                           A:8CB6
MemoryTestPassedMsg              A:AE31
MID                              A:9EED
MID1                             A:9EB9
MIDNUM                           A:9F51
MINCDE                           A:A014
MINUS                            A:9917
MissingParameterErr              A:ACD1
MKTMST                           A:9CC0
MLDBLP                           A:A30E
MLDEBC                           A:A306
MLOOP                            A:8C0C
MLSP10                           A:A203
MO                               E:0024
MONITR                           A:A80F
MONOUT                           A:A80C
MORDT                            A:979D
MORINP                           A:91BE
MOVBUF                           A:9037
MOVDIR                           A:9154
MOVLP                            A:8F42
MOVSTR                           A:8F3F
MOVUP                            A:8F3C
MRPRNT                           A:9611
MSIZE                            A:8BF9
MUL8LP                           A:A13A
MULLN2                           A:A106
MULT8                            A:A131
MULTEN                           A:A377
MULTT                            A:A10D
MULVAL                           E:10F6
MVSTPT                           A:95C3
NEDMOR                           A:9730
NEGAFT                           A:A4AE
Negative                         E:0001
NEW                              A:907C
NEXITM                           A:96C9
NEXT                             A:97ED
NEXT1                            A:97F0
NF                               E:0000
NFERR                            A:8F76
NMI66                            A:0066
NOCHNG                           A:9144
NOENED                           A:A486
NOLIN                            A:9430
NOMADD                           A:A14B
NOMLAD                           A:A31C
NoParameter                      A:B020
NOPMPT                           A:970E
NORMAL                           A:A03F
NOSPC                            A:913B
NOSUB7                           A:A791
NOSWAP                           A:9FEE
NOTAMP                           A:98EC
NothingToCopy                    A:B059
NothingToCopyErr                 A:ADF9
NOTSTR                           A:9A66
NOXOR                            A:9F7C
NSCFOR                           A:9A76
NULFLG                           E:1044
NULLL                            A:9454
NULLP                            A:9684
NULLS                            E:1041
NUMASC                           A:A3BF
NumberOutOfRange                 A:B047
NumberOutOfRangeErr              A:ADC3
NXTARY                           A:9B2D
NXTBYT                           A:912A
NXTCHR                           A:916B
NXTDAT                           E:10DC
NXTDTA                           A:9561
NXTITM                           A:9728
NXTOPR                           E:10D0
NXTSTL                           A:9568
NXTSTT                           A:956B
OD                               E:0006
OKMSG                            A:8F0D
OM                               E:000C
OMERR                            A:8F65
ON                               A:95D3
ONGO                             A:95E2
ONGOLP                           A:95E3
ONJMP                            A:93B0
OPNPAR                           A:9846
OPRND                            A:98C1
OS                               E:001A
OTKLN                            A:91AC
OTPORT                           E:1007
OUTC                             A:9249
OUTEXP                           A:A477
OUTIT                            A:922A
OUTNBS                           A:9230
OUTNCR                           A:A823
OUTSUB                           E:1006
OUTWRD                           A:92CC
OV                               E:000A
Overflow                         E:0002
OVERR                            A:8F7F
OVTST1                           A:A1F6
OVTST2                           A:A1FB
OVTST3                           A:A1FC
PADD                             A:A39B
PAND                             A:9982
ParseEnd                         A:89B5
ParseExecute                     A:89A0
ParseInvalid                     A:89AF
ParseInvalidErr                  A:AC59
ParseNextChar                    A:896E
ParseNextCmd                     A:8986
Parser                           A:8954
ParseSaveHL                      A:B095
ParseValidate                    A:8997
PASSA                            A:9C02
PBUFF                            E:10E9
PEEK                             A:9FAA
PeekAddress                      A:85E8
PeekCmd                          A:85E2
PeekDefault                      A:85F4
PeekEnd                          A:860D
PeekRead                         A:85F8
PEND                             A:9415
PHLTFP                           A:A258
PLUCDE                           A:A079
PNORM                            A:A047
POINT                            E:1051
POKE                             A:9FB1
PokeAddress                      A:8617
PokeByte                         A:8625
PokeCmd                          A:8611
PokeEnd                          A:864A
PokeNoParameter                  A:8647
PokeWrite                        A:862F
POPAF                            A:9D46
POPHL                            A:9E70
POPHRT                           A:A15B
POPNOK                           A:8FBA
POR                              A:9981
POR1                             A:99A4
POS                              A:9BFF
POSINT                           A:9474
POUT                             A:9F62
POWER                            A:A4BC
POWER1                           A:A4CC
POWER2                           A:A4E9
POWERS                           A:A49C
PrintByte                        A:8061
PrintChar                        A:8074
PrintCharTxWait                  A:8075
PrintCRLF                        A:807F
PrintDec                         A:8058
PrintErrorLoop                   A:89C2
PrintErrorPointer                A:89BC
PrintLine                        A:808C
PrintLineLoop                    A:8093
PrintNibble                      A:809E
PrintNibbleEnd                   A:80A9
PrintString                      A:80AE
PrintStringEnd                   A:80BA
PrintStringLoop                  A:80AF
PRINTT                           A:9615
PrintWord                        A:80BC
PRITAB                           A:8E62
PRNTCRLF                         A:9673
PRNTHL                           A:A3B4
PRNTLP                           A:9618
PRNTNB                           A:965B
PRNTOK                           A:8FBB
PRNTST                           A:965F
PRNUMS                           A:9D10
PROCES                           A:91D7
PROGND                           E:10D6
PROGST                           E:10F9
PROMPT                           A:90BF
PRS                              A:9D11
PRS1                             A:9D14
PRSLP                            A:9D1B
PSET                             E:1054
PSUB                             A:9FCF
PTRLP                            A:9044
PUTBUF                           A:9216
PUTCTL                           A:921B
PUTFID                           A:9384
QTSTLP                           A:9CD6
QTSTR                            A:9CD0
QUARTR                           A:A655
Range                            A:AFF3
RangeInverted                    A:B017
RangeMsg                         A:AE46
RangeTooSmall                    A:B005
RangeTooSmallErr                 A:AD6F
RangeValidation                  A:89D4
RangeValidationEnd               A:8B2B
RangeValidationError             A:8B27
READ                             A:9723
ReadByte                         A:80DB
ReadChar                         A:80C7
ReadCharNoWait                   A:80D0
READFG                           E:10CD
ReadString                       A:80EE
ReadStringBS                     A:8119
ReadStringChar                   A:80F6
ReadStringCR                     A:8133
ReadStringESC                    A:8132
ReadStringSave                   A:810D
ReadWord                         A:813D
REDO                             A:96D0
RegA                             A:B097
RegBC                            A:B098
RegDE                            A:B09A
RegHL                            A:B09C
Registers                        A:864E
RegIX                            A:B09E
RegIY                            A:B0A0
REM                              A:9564
RESDIV                           A:A1A8
RESEED                           A:A5F3
ReservedBiosAreaErr              A:AD59
RESET                            E:1057
ResetErrorPointer                A:8B2F
RESTNL                           A:93ED
RESTOR                           A:93D8
RESZER                           A:A03A
RETADR                           A:9ADD
RETINT                           A:A231
RETLIN                           A:955C
RETNAD                           A:9150
RETNUL                           A:9AE0
RETNUM                           A:9923
RETREL                           A:A223
RETURN                           A:953D
RG                               E:0004
RIGHT                            A:9EE3
RIGHT1                           A:9EB7
RINPUT                           E:104E
RLTLP                            A:9866
RND                              A:A592
RND1                             A:A5CE
RND2                             A:A5EA
RNDTAB                           A:A5FB
RNGTST                           A:A489
ROMCopy                          A:0098
RomDisable                       E:0038
RONDB                            A:A05B
RONDUP                           A:A05A
ROUND                            A:9FC2
RSCALE                           A:A395
RSLNBK                           A:9306
RST00                            A:0000
RST08                            A:0008
RST10                            A:0010
RST18                            A:0018
RST20                            A:0020
RST28                            A:0028
RST30                            A:0030
RST38                            A:0038
RSTSTR                           A:9F06
RUN                              A:9502
RunCallBC                        A:8798
RUNCNT                           A:9388
RunCode                          A:8788
RunEnd                           A:879A
RUNFST                           A:9088
RUNLIN                           A:951E
SAVEXP                           A:A03B
SAVSTP                           A:937B
SAVSTR                           A:9CAB
SBSCPT                           A:9AEB
SCALE                            A:A099
SCALLP                           A:A09B
SCALMI                           A:A360
SCALPL                           A:A376
SCNEND                           A:9DE2
SCPTLP                           A:9AF1
SEARCH                           A:9118
SEED                             E:1017
SetAddress                       A:879B
SetAddressDefault                A:87B1
SetAddressEnd                    A:87B7
SetBank                          A:87BC
SetBankDefault                   A:87DC
SetBankEnd                       A:87E8
SetBankError                     A:87E5
SETIO                            A:9F86
SETLIN                           A:92DA
SETLIT                           A:9162
SETPTR                           A:903F
SETTOP                           A:8C30
SFTPRG                           A:9009
SGN                              A:A229
SGNEXP                           A:9971
SGNRES                           E:10E8
ShadowCopy                       A:0080
SHRITE                           A:A0A8
SHRLP                            A:A0AB
SHRT1                            A:A0AF
Sign                             E:0007
SIGNON                           A:8C80
SignOnMsg                        A:8B6E
SIGNS                            A:A280
SIN                              A:A60D
SIN1                             A:A63D
SINTAB                           A:A659
SIO_Init                         A:814B
SIO_PortA_Ctrl                   E:0002
SIO_PortA_Data                   E:0000
SIXDIG                           A:A3DC
SkipSpaces                       A:8B37
SkipSpacesEnd                    A:8B43
SkipSpacesLoop                   A:8B38
SMPVAR                           A:9D76
SMSER1                           A:A571
SN                               E:0002
SNERR                            A:8F70
SPCFST                           A:A3CD
SPCLP                            A:96C2
SQR                              A:A4B3
SQUOT                            A:B0B1
SRCHLN                           A:905C
SRCHLP                           A:905F
SREM                             A:B0B0
SSTSA                            A:9E3E
ST                               E:001E
STACK                            E:1066
StackPage                        A:FF00
StackPtr                         A:B0A2
STAKFP                           A:A24B
STALL                            A:9402
StartAddr                        E:0000
StartAddress                     A:B0A5
StartAddressAlt                  A:B0A9
StartGreaterEndErr               A:AD01
StartOfCode                      A:8000
STKTHS                           A:98AA
STLOOK                           E:115D
STOPP                            A:9413
STORED                           A:94DF
STPOOL                           A:9DB9
STR1                             A:9CA1
STRADD                           A:9DBC
STRBOT                           E:10C3
STRENT                           A:977A
STRR                             A:9C9B
STRSPC                           E:105A
STTLIN                           A:9666
SUBCDE                           A:9FD1
SUBPHL                           A:9FCB
SUMLP                            A:A57A
SUMSER                           A:A562
SUPTLZ                           A:A45B
SVNAM2                           A:9A4A
SVSTAD                           A:9CC9
SysInfo                          A:87ED
SysInfoMsg                       A:AB94
TAN                              A:A66E
TestingBankNumberMsg             A:AE0B
TestingHighRamMsg                A:AE1E
TESTOS                           A:9D48
TESTR                            A:9D2A
TM                               E:0018
TMERR                            A:8F82
TMPSTR                           E:10BF
TMSTPL                           E:10B3
TMSTPT                           E:10B1
TooManyDigits                    A:B035
TooManyDigitsErr                 A:ACA8
TOPOOL                           A:9EAF
TOSTRA                           A:9E47
TRYAGN                           A:A436
TSALP                            A:9E48
TSTBIT                           A:A81C
TSTBRK                           A:93F3
TSTMEM                           A:8C1E
TSTNUM                           A:983B
TSTOPL                           A:9CF1
TSTRED                           A:99A9
TSTREM                           A:9165
TSTSGN                           A:A21A
TSTSTR                           A:983C
TTYLIN                           A:91B5
TYPE                             E:10AD
UF                               E:0022
UFERR                            A:8F7C
UL                               E:000E
ULERR                            A:9538
UNITY                            A:A0BD
UnrecognizedParamErr             A:ACE8
UPDATA                           A:93EE
UpperCase                        A:829F
UpperCaseEnd                     A:82A9
UserCodeSize                     A:B0AE
USR                              E:1003
VAL                              A:9F1D
VAL1                             A:9F3B
VAL2                             A:9F45
VAL3                             A:9F48
ValBiosOverlap                   A:8A9C
ValBiosRangeError                A:8B15
ValCheckBiosHi                   A:8A37
ValCheckBiosLow                  A:8A2C
ValCheckHigh                     A:8A45
ValCheckHighBios                 A:8A6B
ValCheckHighLimit                A:8A0F
ValCheckHighLimit2               A:8A20
ValCheckIfZeroDataHigh           A:8AC8
ValCheckIfZeroDataLow            A:8AB8
ValCheckInverted                 A:89E2
ValCheckLow                      A:8A79
ValCheckLowBios                  A:8A93
ValCheckLowLimit                 A:89F2
ValCheckLowLimit2                A:8A03
ValInvertedError                 A:8B21
ValPrintRange                    A:8AD8
ValPrintRange1                   A:8ADB
ValPrintRange2                   A:8AF5
ValPrintRangeEnd                 A:8B0F
ValRangeTooSmallError            A:8B1B
VAREND                           E:10D8
VectorCopy                       A:00A3
VectorEnd                        A:FE3F
VectorTable                      A:FD00
VectorTableStart                 A:FD02
VertTextRes                      E:0018
WAIT                             A:9F68
WAITLP                           A:9F7D
WARM                             A:8C68
WIDTH                            A:A6D7
WORDS                            A:8CF9
WORDTB                           A:8E18
Write                            A:880A
WriteEnd                         A:8855
WriteFirstByte                   A:881D
WriteGetAddress                  A:8811
WriteNoParameter                 A:8852
WriteRemainingBytes              A:8831
WriteTooManyDigits               A:8847
WRKSPC                           E:1000
ZDATA                            E:0083
ZEND                             E:0080
ZEQUAL                           E:00B4
ZERARY                           A:9B8C
ZERBYT                           E:8F0C
Zero                             E:0006
ZeroAllRam                       A:885A
ZeroEnd                          A:889A
ZeroHighRange                    A:8881
ZeroLowRange                     A:8860
ZEROLP                           A:9ACF
ZEROSUP                          A:A7AF
ZFN                              E:00A7
ZFOR                             E:0081
ZGOSUB                           E:008C
ZGOTO                            E:0088
ZGTR                             E:00B3
ZLEFT                            E:00CF
ZLTH                             E:00B5
ZMINUS                           E:00AD
ZNEW                             E:00A4
ZNOT                             E:00AA
ZONELP                           A:969D
ZOR                              E:00B2
ZPLUS                            E:00AC
ZPRINT                           E:009E
ZREM                             E:008E
ZSGN                             E:00B6
ZSPC                             E:00A8
ZSTEP                            E:00AB
ZTAB                             E:00A5
ZTHEN                            E:00A9
ZTO                              E:00A6

Symbols by value:
0000 StartAddr
0000 RST00
0000 Carry
0000 SIO_PortA_Data
0000 NF
0001 Negative
0001 ChecksumErr
0002 SN
0002 Overflow
0002 SIO_PortA_Ctrl
0003 CTRLC
0004 HalfCarry
0004 RG
0006 Zero
0006 OD
0007 CTRLG
0007 LastRec
0007 Sign
0008 RST08
0008 ErrorPtrOffset
0008 FC
0008 BKSP
000A LF
000A OV
000C OM
000D CR
000E UL
000F CTRLO
000F HELP
0010 RST10
0010 BS
0011 CTRLQ
0012 CTRLR
0012 DD
0013 CTRLS
0014 DZ
0015 CTRLU
0016 ID
0018 RST18
0018 TM
0018 VertTextRes
001A OS
001B ESC
001C LS
001E ST
0020 DELIMITER
0020 CN
0020 RST20
0022 UF
0024 MO
0026 HX
0028 BN
0028 RST28
0028 HorizTextRes
0030 RST30
0030 BankSelect
0038 RomDisable
0038 RST38
005E ERRORPTR
0066 NMI66
007F DEL
0080 ZEND
0080 InterruptVectorEnd
0080 ShadowCopy
0081 ZFOR
0083 ZDATA
0083 BankCopyLoop
0088 ZGOTO
008C ZGOSUB
008E ZREM
0098 ROMCopy
009E ZPRINT
00A3 VectorCopy
00A4 ZNEW
00A5 ZTAB
00A6 ZTO
00A7 ZFN
00A8 ZSPC
00A9 ZTHEN
00AA ZNOT
00AB ZSTEP
00AC ZPLUS
00AD ZMINUS
00B2 ZOR
00B3 ZGTR
00B4 ZEQUAL
00B5 ZLTH
00B6 ZSGN
00C3 JUMP
00CF ZLEFT
00FF EOT
1000 WRKSPC
1003 USR
1006 OUTSUB
1007 OTPORT
1009 DIVSUP
100A DIV1
100E DIV2
1012 DIV3
1015 DIV4
1017 SEED
103A LSTRND
103E INPSUB
103F INPORT
1041 NULLS
1042 LWIDTH
1043 COMMAN
1044 NULFLG
1045 CTLOFG
1046 LINESC
1048 LINESN
104A CHKSUM
104D BRKFLG
104E RINPUT
1051 POINT
1054 PSET
1057 RESET
105A STRSPC
105C LINEAT
105E BASTXT
1061 BUFFER
1066 STACK
10AB CURPOS
10AC LCRFLG
10AD TYPE
10AE DATFLG
10AF LSTRAM
10B1 TMSTPT
10B3 TMSTPL
10BF TMPSTR
10C3 STRBOT
10C5 CUROPR
10C7 LOOPST
10C9 DATLIN
10CB FORFLG
10CC LSTBIN
10CD READFG
10CE BRKLIN
10D0 NXTOPR
10D2 ERRLIN
10D4 CONTAD
10D6 PROGND
10D8 VAREND
10DA ARREND
10DC NXTDAT
10DE FNRGNM
10E0 FNARG
10E4 FPREG
10E7 FPEXP
10E8 SGNRES
10E9 PBUFF
10F6 MULVAL
10F9 PROGST
115D STLOOK
8000 StartOfCode
8044 Main
8058 PrintDec
8061 PrintByte
8074 PrintChar
8075 PrintCharTxWait
807F PrintCRLF
808C PrintLine
8093 PrintLineLoop
809E PrintNibble
80A9 PrintNibbleEnd
80AE PrintString
80AF PrintStringLoop
80BA PrintStringEnd
80BC PrintWord
80C7 ReadChar
80D0 ReadCharNoWait
80DB ReadByte
80EE ReadString
80F6 ReadStringChar
810D ReadStringSave
8119 ReadStringBS
8132 ReadStringESC
8133 ReadStringCR
813D ReadWord
814B SIO_Init
8169 Ascii2HexNibble
8169 Ascii2BcdDigit
817E Ascii2HexNibbleOK
8186 Ascii2HexNibbleEnd
818B Ascii2HexNibbleErr
818D Ascii2HexByte
81A9 Ascii2HexByteErr
81AC Ascii2HexWord
81BC Ascii2HexWordErr
81BF Dec2Hex
81C8 Dec2HexLoop
81F6 Dec2HexShuffleRegs
81FC Dec2HexOutOfRange
8202 Dec2HexInvalidDec
8209 Dec2HexEnd
820C Hex2Dec
8217 Hex2Dec10000
8219 Hex2Dec10000Loop
8229 Hex2Dec10000Set
8232 Hex2Dec1000
8234 Hex2Dec1000Loop
8246 Hex2Dec1000Set
824F Hex2Dec100
8251 Hex2Dec100Loop
8263 Hex2Dec100Set
826C Hex2Dec10
826E Hex2Dec10Loop
8280 Hex2Dec10Set
8289 Hex2Dec1
8296 Hex2DecEnd
829F UpperCase
82A9 UpperCaseEnd
82AA ClearScreen
82B3 CopyBlock
82BA CopySourceAddress
82C8 CopyDestinationAddress
82D6 CopyNumberOfBytes
8307 CopyNoOverlap
830B CopyNoParameter
8310 CopyNothing
8313 CopyEnd
8318 Diagnostics
8326 DiagnosticsBankLoop
8361 DiagnosticsTest
8364 DiagnosticsTestLoop
8395 DiagMemoryError
83AC DiagMemoryAddr
83CF DiagnosticsEnd
83DF DiagnosticsEnd2
83E8 FillMemory
83EF FillStartAddr
8405 FillEndAddr
8412 FillByte
8424 FillRange1
844C FillRange2
8476 FillNoParameter
847C FillPrintHelp
8482 FillMemoryEnd
8487 HexDump
849F HexLinesToRead
84B2 HexDefaultLines
84B4 HexDisplayContent
84B5 HexNextLine
84C5 HexNextByte
84D8 HexNextChar
84E3 HexReplaceDot
84E5 HexPrintChar
84F8 HexDumpPrintHelp
84FE HexDumpEnd
8503 IntelHex
8522 IntelHexStartCode
8530 IntelHexByteCount
8535 IntelHexAddress
854A IntelHexRecordType
855D IntelHexData
8568 IntelHexChecksum
8576 IntelHexCheckOk
8578 IntelHexPrintStatus
8583 IntelHexPrintEndMsg
8595 IntelHexPrintNotOk
85A8 IntelHexAbort
85B0 IntelHexUnsupported
85BE IntelHexParamError
85C6 IntelHexPrintHelp
85CC IntelHexEnd
85D3 ListCmd
85E2 PeekCmd
85E8 PeekAddress
85F4 PeekDefault
85F8 PeekRead
860D PeekEnd
8611 PokeCmd
8617 PokeAddress
8625 PokeByte
862F PokeWrite
8647 PokeNoParameter
864A PokeEnd
864E Registers
873C FlagSignClear
8748 FlagZeroClear
8754 FlagHalfClear
8760 FlagOverClear
876C FlagNegativeClear
8778 FlagCarryClear
8788 RunCode
8798 RunCallBC
879A RunEnd
879B SetAddress
87B1 SetAddressDefault
87B7 SetAddressEnd
87BC SetBank
87DC SetBankDefault
87E5 SetBankError
87E8 SetBankEnd
87ED SysInfo
880A Write
8811 WriteGetAddress
881D WriteFirstByte
8831 WriteRemainingBytes
8847 WriteTooManyDigits
8852 WriteNoParameter
8855 WriteEnd
885A ZeroAllRam
8860 ZeroLowRange
8881 ZeroHighRange
889A ZeroEnd
889F CommandPrompt
88BF DecErrorPointer
88C9 GetHexParameter
88CF GetParamCount
88E0 GetParamFetch
88E5 GetParamFetch0
88ED GetParamFetch1
88FD GetParamFetch2
890B GetParamFetch3
8921 GetParamFetch4
892C GetParameterEnd
892E GetParamHelp
8933 GetParamNumberError
8935 GetErrorPointerLoop
8942 GetParamHexError
8948 GetParamErrorEnd
894A IncErrorPointer
8954 Parser
896E ParseNextChar
8986 ParseNextCmd
8997 ParseValidate
89A0 ParseExecute
89AF ParseInvalid
89B5 ParseEnd
89BC PrintErrorPointer
89C2 PrintErrorLoop
89D4 RangeValidation
89E2 ValCheckInverted
89F2 ValCheckLowLimit
8A03 ValCheckLowLimit2
8A0F ValCheckHighLimit
8A20 ValCheckHighLimit2
8A2C ValCheckBiosLow
8A37 ValCheckBiosHi
8A45 ValCheckHigh
8A6B ValCheckHighBios
8A79 ValCheckLow
8A93 ValCheckLowBios
8A9C ValBiosOverlap
8AB8 ValCheckIfZeroDataLow
8AC8 ValCheckIfZeroDataHigh
8AD8 ValPrintRange
8ADB ValPrintRange1
8AF5 ValPrintRange2
8B0F ValPrintRangeEnd
8B15 ValBiosRangeError
8B1B ValRangeTooSmallError
8B21 ValInvertedError
8B27 RangeValidationError
8B2B RangeValidationEnd
8B2F ResetErrorPointer
8B37 SkipSpaces
8B38 SkipSpacesLoop
8B43 SkipSpacesEnd
8B45 BASIC
8B4E ColdOrWarm
8B54 CheckIfCold
8B61 CheckIfWarm
8B6E SignOnMsg
8BCA COLD
8BD5 CSTART
8BDC INIT
8BE4 COPYY
8BF9 MSIZE
8C0C MLOOP
8C1E TSTMEM
8C30 SETTOP
8C68 WARM
8C6B BRKRET
8C71 BFREE
8C80 SIGNON
8CB6 MEMMSG
8CC1 FNCTAB
8CF9 WORDS
8E18 WORDTB
8E62 PRITAB
8E77 ERRORS
8EA1 INITAB
8F01 ERRMSG
8F01 INITBE
8F08 INMSG
8F0C ZERBYT
8F0D OKMSG
8F13 BRKMSG
8F19 BAKSTK
8F1D LOKFOR
8F33 INDFND
8F3C MOVUP
8F3F MOVSTR
8F42 MOVLP
8F4D CHKSTK
8F56 ENFMEM
8F65 OMERR
8F6A DATSNR
8F70 SNERR
8F73 DZERR
8F76 NFERR
8F79 DDERR
8F7C UFERR
8F7F OVERR
8F82 TMERR
8F84 ERROR
8FA4 ERRIN
8FBA POPNOK
8FBB PRNTOK
8FC8 GETCMD
9001 LINFND
9009 SFTPRG
9018 INEWLN
9037 MOVBUF
903F SETPTR
9044 PTRLP
9050 FNDEND
905C SRCHLN
905F SRCHLP
907C NEW
907D CLRPTR
9088 RUNFST
908C INTVAR
90A2 CLREG
90BB DOAGN
90BF PROMPT
90CC CRUNCH
90D5 CRNCLP
90FF FNDWRD
9118 SEARCH
911A GETNXT
912A NXTBYT
913B NOSPC
9144 NOCHNG
914C MATCH
9150 RETNAD
9154 MOVDIR
9162 SETLIT
9165 TSTREM
916B NXTCHR
9174 CPYLIT
917B ENDBUF
9184 DODEL
9198 ECHDEL
91A4 DELCHR
91AC OTKLN
91AF KILIN
91B5 GETLIN
91B5 TTYLIN
91BE MORINP
91D7 PROCES
9216 PUTBUF
921B PUTCTL
922A OUTIT
9230 OUTNBS
9238 CPDEHL
923E CHKSYN
9249 OUTC
9269 INCLEN
926D DINPOS
9273 CLOTST
9284 LISTT
9290 LISTLP
92B0 LSTLP2
92B3 LSTLP3
92C2 FNDTOK
92CC OUTWRD
92DA SETLIN
92E3 COUNT
9306 RSLNBK
930F FOR
9323 FORSLP
933F FORFND
937B SAVSTP
9384 PUTFID
9388 RUNCNT
93A8 EXCUTE
93AF IFJMP
93B0 ONJMP
93C8 GETCHR
93D8 RESTOR
93ED RESTNL
93EE UPDATA
93F3 TSTBRK
9402 STALL
940E BRK
9413 STOPP
9415 PEND
941A INPBRK
941D ENDPRG
9430 NOLIN
9441 CONT
9454 NULLL
945C ACCSUM
9469 CHKLTR
9471 FPSINT
9474 POSINT
9477 DEPINT
947D DEINT
9492 FCERR
9497 ATOH
9498 GETLN
949B GTLNLP
94BC CLEAR
94DF STORED
9502 RUN
950E GOSUB
951E RUNLIN
951F GOTO
9538 ULERR
953D RETURN
955C RETLIN
9561 NXTDTA
9562 DATAA
9564 REM
9568 NXTSTL
956B NXTSTT
9579 LET
9594 LETSTR
95BB CRESTR
95C3 MVSTPT
95CC LETNUM
95D3 ON
95E2 ONGO
95E3 ONGOLP
95F1 IFF
95FF IFGO
9611 MRPRNT
9615 PRINTT
9618 PRNTLP
965B PRNTNB
965F PRNTST
9666 STTLIN
966E ENDINP
9673 PRNTCRLF
967D DONULL
9684 NULLP
968F DOCOM
969D ZONELP
96A6 DOTAB
96B9 DOSPC
96BE ASPCS
96C2 SPCLP
96C9 NEXITM
96D0 REDO
96E3 BADINP
96F4 INPUT
970E NOPMPT
9723 READ
9728 NXTITM
9730 NEDMOR
9734 GTVLUS
975C ANTVLU
9777 ITMSEP
977A STRENT
9786 INPBIN
9791 LTSTND
979D MORDT
97B8 EXTIG
97C9 FDTLP
97E2 FANDT
97ED NEXT
97F0 NEXT1
9828 KILFOR
9838 GETNUM
983B TSTNUM
983C TSTSTR
983D CHKTYP
9846 OPNPAR
984A EVAL
984D EVAL1
9856 EVAL2
9859 EVAL3
9866 RLTLP
9882 FOPRND
98AA STKTHS
98C1 OPRND
98EC NOTAMP
990F EVLPAR
9917 MINUS
9923 RETNUM
9928 CONVAR
992B FRMEVL
9939 FNOFST
9960 FNVAL
9968 GOFUNC
9971 SGNEXP
9981 POR
9982 PAND
99A4 POR1
99A9 TSTRED
99BB CMPLOG
99BD CMPLG1
99E7 CMPSTR
99FF CMPRES
9A09 EVNOT
9A20 DIMRET
9A29 DIM
9A2E GETVAR
9A33 GTFNAM
9A4A SVNAM2
9A4B ENDNAM
9A57 CHARTY
9A66 NOTSTR
9A76 NSCFOR
9A90 FNDVAR
9A9E FNTHR
9AA9 CFEVAL
9ACF ZEROLP
9ADD RETADR
9AE0 RETNUL
9AEB SBSCPT
9AF1 SCPTLP
9B13 ARLDSV
9B19 FNDARY
9B2D NXTARY
9B46 BSERR
9B4B CREARY
9B66 CRARLP
9B6E DEFSIZ
9B8C ZERARY
9BA9 FINDEL
9BAE FNDELP
9BCD ENDDIM
9BD1 FRE
9BED FRENUM
9BF2 ACPASS
9BF3 ABPASS
9BFF POS
9C02 PASSA
9C07 DEF
9C34 DOFN
9C7C IDTEST
9C8A CHEKFN
9C9B STRR
9CA1 STR1
9CAB SAVSTR
9CC0 MKTMST
9CC3 CRTMST
9CC9 SVSTAD
9CCF CRTST
9CD0 QTSTR
9CD3 DTSTR
9CD6 QTSTLP
9CE5 CRTSTE
9CF1 TSTOPL
9D10 PRNUMS
9D11 PRS
9D14 PRS1
9D1B PRSLP
9D2A TESTR
9D2C GRBDON
9D46 POPAF
9D48 TESTOS
9D54 GARBGE
9D57 GARBLP
9D65 GRBLP
9D76 SMPVAR
9D8B GNXARY
9D8C ARRLP
9DAB GRBARY
9DB9 STPOOL
9DBC STRADD
9DE2 SCNEND
9E07 CONCAT
9E3E SSTSA
9E47 TOSTRA
9E48 TSALP
9E51 GETSTR
9E54 GSTRCU
9E57 GSTRHL
9E58 GSTRDE
9E70 POPHL
9E72 BAKTMP
9E83 LEN
9E87 GETLEN
9E92 ASCC
9E96 GTFLNM
9EA3 CHR
9EAF TOPOOL
9EB3 LEFT
9EB7 RIGHT1
9EB9 MID1
9EC1 ALLFOL
9EE3 RIGHT
9EED MID
9F06 RSTSTR
9F1D VAL
9F3B VAL1
9F45 VAL2
9F48 VAL3
9F4C LFRGNM
9F51 MIDNUM
9F56 INP
9F62 POUT
9F68 WAIT
9F7C NOXOR
9F7D WAITLP
9F86 SETIO
9F96 FNDNUM
9F99 GETINT
9F9C MAKINT
9FAA PEEK
9FB1 POKE
9FC2 ROUND
9FC5 ADDPHL
9FCB SUBPHL
9FCF PSUB
9FD1 SUBCDE
9FD4 FPADD
9FEE NOSWAP
A014 MINCDE
A022 CONPOS
A025 BNORM
A028 BNRMLP
A03A RESZER
A03B SAVEXP
A03F NORMAL
A047 PNORM
A05A RONDUP
A05B RONDB
A06C FPROND
A079 PLUCDE
A085 COMPL
A099 SCALE
A09B SCALLP
A0A8 SHRITE
A0AB SHRLP
A0AF SHRT1
A0BD UNITY
A0C1 LOGTAB
A0CE LOG
A106 MULLN2
A10D MULTT
A10F FPMULT
A131 MULT8
A13A MUL8LP
A14B NOMADD
A15B POPHRT
A15D BYTSFT
A162 DIV10
A16E DIV
A170 DVBCDE
A195 DIVLP
A1A8 RESDIV
A1D8 ADDEXP
A1F6 OVTST1
A1FB OVTST2
A1FC OVTST3
A203 MLSP10
A21A TSTSGN
A223 RETREL
A225 FLGDIF
A229 SGN
A22C FLGREL
A231 RETINT
A23F ABS
A243 INVSGN
A24B STAKFP
A258 PHLTFP
A25B FPBCDE
A266 BCDEFP
A269 LOADFP
A270 INCHL
A272 FPTHL
A275 DETHL4
A277 DETHLB
A280 SIGNS
A295 CMPNUM
A2AF CMPFP
A2C2 FPINT
A2E6 DCBCDE
A2ED INT
A306 MLDEBC
A30E MLDBLP
A31C NOMLAD
A321 ASCTFP
A32D CNVNUM
A335 MANLP
A34B EXPLP
A359 DPOINT
A35D CONEXP
A360 SCALMI
A36C ENDCON
A376 SCALPL
A377 MULTEN
A37E ADDIG
A395 RSCALE
A39B PADD
A3A0 EDIGIT
A3AC LINEIN
A3B4 PRNTHL
A3BF NUMASC
A3CD SPCFST
A3DC SIXDIG
A3F1 GTSIXD
A3FA INRNG
A416 MAKNUM
A427 DIGTXT
A436 TRYAGN
A45B SUPTLZ
A467 DOEBIT
A477 OUTEXP
A479 EXPTEN
A483 JSTZER
A486 NOENED
A489 RNGTST
A498 HALF
A49C POWERS
A4AE NEGAFT
A4B3 SQR
A4BC POWER
A4CC POWER1
A4E9 POWER2
A501 EXPP
A541 EXPTAB
A562 SUMSER
A571 SMSER1
A57A SUMLP
A592 RND
A5CE RND1
A5EA RND2
A5F3 RESEED
A5FB RNDTAB
A607 COS
A60D SIN
A63D SIN1
A651 HALFPI
A655 QUARTR
A659 SINTAB
A66E TAN
A683 ATN
A6A0 ATN1
A6AA ATNTAB
A6CF ARET
A6D0 GETINP
A6D4 CLS
A6D7 WIDTH
A6DF LINES
A6EE DEEK
A6F9 DOKE
A710 HEX
A729 HEX1
A72B HEX2
A739 HEX3
A73B HEX4
A748 BYT2ASC
A751 ADD30
A761 ADD301
A765 HEXTFP
A771 HEXLP
A776 HEXLP1
A77E GETHEX
A791 NOSUB7
A795 HEXIT
A79E HXERR
A7A3 BIN
A7A9 BIN2
A7AF ZEROSUP
A7BD BITOUT
A7C1 BITOUT2
A7D5 BINTFP
A7DF BINIT
A7F2 CHKBIN
A800 BINERR
A805 JJUMP1
A80C MONOUT
A80F MONITR
A812 INITST
A81A ARETN
A81C TSTBIT
A823 OUTNCR
A829 BootMsg
A8B2 CommandList
A92C ListOfCommands
AB81 FlagBits
AB87 ClearScreenSeq
AB94 SysInfoMsg
AC59 ParseInvalidErr
AC7F InvalidHexDigitErr
ACA8 TooManyDigitsErr
ACD1 MissingParameterErr
ACE8 UnrecognizedParamErr
AD01 StartGreaterEndErr
AD22 IntelHexUnsupportedErr
AD3C InvalidVectorRangeErr
AD59 ReservedBiosAreaErr
AD6F RangeTooSmallErr
AD8C InvalidBankNumberErr
ADAA InvalidDecimalNumberErr
ADC3 NumberOutOfRangeErr
ADDC BadMemory1Err
ADE6 BadMemory2Err
ADF9 NothingToCopyErr
AE0B TestingBankNumberMsg
AE1E TestingHighRamMsg
AE31 MemoryTestPassedMsg
AE46 RangeMsg
AE55 IntelHexFinishedMsg
AE65 IntelHexSuccessMsg
AE74 IntelHexLoadMsg
AEB1 IntelHexAbortedMsg
AECC DownloadedBytesMsg
AEE0 FillHelp
AF4B HexDumpHelp
AFB0 IntelHexHelp
AFF3 Range
AFFC InvalidVectorRange
B005 RangeTooSmall
B00E BiosRange
B017 RangeInverted
B020 NoParameter
B02C InvalidBank
B035 TooManyDigits
B03E InvalidHexDigit
B047 NumberOutOfRange
B050 InvalidDecimalNumber
B059 NothingToCopy
B068 CommandBuffer
B086 BufferPointer
B088 CmdErrorPointer
B089 CurrentBank
B08A CurrentAddress
B08C DigitString
B095 ParseSaveHL
B097 RegA
B098 RegBC
B09A RegDE
B09C RegHL
B09E RegIX
B0A0 RegIY
B0A2 StackPtr
B0A4 FlagsReg
B0A5 StartAddress
B0A7 EndAddress
B0A9 StartAddressAlt
B0AB EndAddressAlt
B0AD ByteTransfer
B0AE UserCodeSize
B0B0 SREM
B0B1 SQUOT
B0B2 EndOfCode
CBCE BytesFree
FD00 VectorTable
FD00 IntVectorEnd
FD02 VectorTableStart
FD04 CodeStartAddr
FD06 CodeEndAddr
FE00 JumpTable
FE3F VectorEnd
FF00 StackPage
FFFF BiosEnd
